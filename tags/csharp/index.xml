<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Csharp on 7sharp9</title>
    <link>http://7sharpnine.com/tags/csharp/</link>
    <description>Recent content in Csharp on 7sharp9</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <copyright>Dave Thomas</copyright>
    <lastBuildDate>Sun, 01 Jun 2014 00:00:00 +0000</lastBuildDate>
    <atom:link href="http://7sharpnine.com/tags/csharp/index.xml" rel="self" type="application/rss+xml" />
    
    <item>
      <title>Anything you can do ...</title>
      <link>http://7sharpnine.com/2014/06/01/2014-06-01-anything-you-can-do/</link>
      <pubDate>Sun, 01 Jun 2014 00:00:00 +0000</pubDate>
      
      <guid>http://7sharpnine.com/2014/06/01/2014-06-01-anything-you-can-do/</guid>
      <description>&lt;p&gt;For any of you that are aware of the newly updated Xamarin Web site, you may have seen the &lt;a href=&#34;https://xamarin.com/platform&#34;&gt;following&lt;/a&gt;:&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;Objective-C was ahead of its time 30 years ago.
C# is ahead of its time today.
Anything you can do in Objective-C or Java, you can do in C# with Xamarin—usually more succinctly and with fewer bugs.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;What is also true is that F# is way ahead of its time, and you can produce even more succinct code with even fewer bugs than C#!&lt;br /&gt;
&lt;!-- more --&gt;
Take the code snippets from that page.&lt;/p&gt;

&lt;p&gt;First up the Objective C version:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;@interface Person : NSObject
@property (strong, nonatomic) NSString *name;
@end

@implementation Person
- (id)initWithName:(NSString *)name {
    self = [super init];
    if (self) {
        self.name = name;
    }
    return self;
}

+ (NSArray *)getNames
{
    NSArray *people = @[
      [[Person alloc] initWithName:@&amp;quot;David&amp;quot;],
      [[Person alloc] initWithName:@&amp;quot;Vinicius&amp;quot;],
      [[Person alloc] initWithName:@&amp;quot;Serena&amp;quot;],
    ];
    NSMutableArray *names = [NSMutableArray array];
    for (Person *person in people) {
        [names addObject:person.name];
    }
    return names;
}
@end
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Heres the C# version:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-csharp&#34;&gt;class Person : NSObject {
  public string Name { get; set; }
  
  public static string[] GetNames() {
    var people = new[] {
        new Person { Name=&amp;quot;David&amp;quot; },
        new Person { Name=&amp;quot;Vinicius&amp;quot; },
        new Person { Name=&amp;quot;Serena&amp;quot; },
    };
    return people.Select(person =&amp;gt; person.Name).ToArray();
  }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;And finally the F# version:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-fsharp&#34;&gt;type Person() =
   inherit NSObject()
   member val Name = &amp;quot;&amp;quot; with get, set
   static member GetNames() =
      [| new Person(Name=&amp;quot;David&amp;quot;)
         new Person(Name=&amp;quot;Vinicius&amp;quot;)
         new Person(Name=&amp;quot;Serena&amp;quot;) |]
      |&amp;gt; Array.map(fun person -&amp;gt; person.Name)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;You can see the F# version is doing exactly the same, although we are using the &lt;code&gt;map&lt;/code&gt; function from the &lt;a href=&#34;http://msdn.microsoft.com/en-us/library/ee370273.aspx&#34;&gt;&lt;code&gt;Array&lt;/code&gt; module&lt;/a&gt; rather than the &lt;a href=&#34;http://msdn.microsoft.com/en-us/library/bb397926.aspx&#34;&gt;Linq&lt;/a&gt; &lt;code&gt;Select&lt;/code&gt; extension method.&lt;/p&gt;

&lt;p&gt;Its not all about the lines of code though, using F# gives you all many advantages:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Using the type system to make sure the code is behaving how you expect before you even compile.&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://msdn.microsoft.com/en-gb/library/dd547125.aspx&#34;&gt;Pattern matching&lt;/a&gt; in F# is amazing!  It can vastly simplify complex control logic, add Active patterns to that and you are ready to take on the world!&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;Problems are approached from a functional perspective which often leads to succinct functions that are easy to reason about, test, and compose.&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;F# emphasizes immutability and functional composition rather than inheritance, again this boils down to simplicity.&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;Features like &lt;a href=&#34;http://msdn.microsoft.com/en-gb/library/hh156509.aspx&#34;&gt;Type providers&lt;/a&gt; can vastly simplify how you deal with data within your application, making access to data really easy and intuitive.&lt;br /&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Theres are many areas that F# can really help productivity during development.  I hope to write a few more short posts to really bring attention to these.  I use F# all the time and often forget how awesome it is until I go back to another language thats missing those features.&lt;/p&gt;

&lt;p&gt;Until next time!&lt;/p&gt;

&lt;hr style=&#34;margin: 1em 0&#34;&gt;
&lt;h1 id=&#34;essential-listening&#34;&gt;Essential listening:&lt;/h1&gt;


&lt;div class=&#34;pure-g&#34;&gt;

  
  
  
  
  &lt;div class=&#34;&#34;&gt;
    &lt;div style=&#34;width: 20%; float: left;padding: 0 .2em .2em 0&#34;&gt;
        &lt;figure style=&#34;margin: 0&#34;&gt;
            &lt;img src=&#34;http://upload.wikimedia.org/wikipedia/en/a/a6/Sr_independent.jpg&#34; style=&#34;margin: 0&#34;
                 alt=&#34;Sacred Reich - Independent&#34; /&gt;
            &lt;figcaption&gt;
                &lt;h6&gt;Sacred Reich - Independent&lt;/h4&gt;
            &lt;/figcaption&gt;
        &lt;/figure&gt;
    &lt;/div&gt;
  &lt;/div&gt;
  

  
  
  
  
  &lt;div class=&#34;&#34;&gt;
    &lt;div style=&#34;width: 20%; float: left;padding: 0 .2em .2em 0&#34;&gt;
        &lt;figure style=&#34;margin: 0&#34;&gt;
            &lt;img src=&#34;http://upload.wikimedia.org/wikipedia/en/4/46/For_Whose_Advantage.jpg&#34; style=&#34;margin: 0&#34;
                 alt=&#34;Xentrix - For Whose Advantage&#34; /&gt;
            &lt;figcaption&gt;
                &lt;h6&gt;Xentrix - For Whose Advantage&lt;/h4&gt;
            &lt;/figcaption&gt;
        &lt;/figure&gt;
    &lt;/div&gt;
  &lt;/div&gt;
  

&lt;/div&gt;




</description>
    </item>
    
    <item>
      <title>Can I have some F# with that?</title>
      <link>http://7sharpnine.com/2013/06/21/2013-06-21-can-i-have-some-fsharp-with-that/</link>
      <pubDate>Fri, 21 Jun 2013 00:00:00 +0000</pubDate>
      
      <guid>http://7sharpnine.com/2013/06/21/2013-06-21-can-i-have-some-fsharp-with-that/</guid>
      <description>

&lt;p&gt;
&lt;figure class=&#34;img-left sixth&#34;&gt;
    
        &lt;img src=&#34;http://scriptcs.net/images/logo@2x.png&#34; /&gt;
    
    
&lt;/figure&gt;
 There&amp;rsquo;s been a fair bit of activity lately from a project called &lt;a href=&#34;http://scriptcs.net&#34;&gt;ScriptCS&lt;/a&gt;, it allows you to put together a project using C# as a lightweight scripting language, forgoing the use of Visual Studio which can sometimes be too bloated and bulky.&lt;/p&gt;

&lt;p&gt;It also allows you to use C# in a Read Evaluate Print Loop - &lt;a href=&#34;http://en.wikipedia.org/wiki/Read–eval–print_loop&#34;&gt;REPL&lt;/a&gt;.  This is nothing new to F# and indeed lots of other languages have REPL&amp;rsquo;s too.  One of the other benefits of ScriptCs is that it also integrates nicely with Nuget allowing you to use your favourite libraries quite easily.  Finally there are Script Sacks which can be used to further reduce the amount of code you need to write when working with common frameworks.&lt;/p&gt;

&lt;p&gt;It would be nice to leverage some of this new functionality from F#, and I don&amp;rsquo;t like to see F# left out, especially when F# already has a REPL environment and is a really great language for scripting.&lt;br /&gt;
&lt;!-- more --&gt;
The F# compiler is also open source so we can utilize the code to add various tooling and features like refactoring, formatting, and analysis.  See &lt;a href=&#34;https://github.com/dungpa/fantomas&#34;&gt;Fantomas&lt;/a&gt;, &lt;a href=&#34;https://github.com/Lewix/fsharp-refactor&#34;&gt;FSharp-Refactor&lt;/a&gt;, and the &lt;a href=&#34;https://github.com/fsharp/fsharpbinding&#34;&gt;FSharpBinding&lt;/a&gt; for more details.&lt;/p&gt;

&lt;hr /&gt;

&lt;h3 id=&#34;lets-get-to-work&#34;&gt;Lets get to work&lt;/h3&gt;

&lt;p&gt;The interface for adding a new script engines looks like this:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;public interface IScriptEngine
{
    string BaseDirectory { get; set; }
    ScriptResult Execute(string code, 
                         string[] scriptArgs, 
                         IEnumerable&amp;lt;string&amp;gt; references, 
                         IEnumerable&amp;lt;string&amp;gt; namespaces, 
                         ScriptPackSession scriptPackSession);
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;First lets create a new namespace and open up all the namespaces we need:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-fsharp&#34;&gt;namespace ScriptCs.Engine.FSharp
open ScriptCs
open Common.Logging
open System
open System.IO
open System.Collections.Generic
open Microsoft.FSharp.Compiler.Interactive.Shell
open ExtCore
open System.Linq
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Next we need to store the result of an attempted expression evaluation.  When we send code to an interactive session we might be in one of three different states:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Incomplete - We have entereed a line but the expression is not complete, in F# we use &lt;code&gt;;;&lt;/code&gt; to indicate the end of an expression.&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;Error - The entered expression resulted in an error.&lt;/li&gt;
&lt;li&gt;Success - The expression that was entered was evaluated successfully.&lt;br /&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;We can model this with a &lt;a href=&#34;http://msdn.microsoft.com/en-us/library/dd233226.aspx&#34;&gt;discriminated union&lt;/a&gt; like this:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-fsharp&#34;&gt;type Result = 
| Success of String 
| Error of string 
| Incomplete
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Next we will augment the existing &lt;a href=&#34;https://github.com/fsharp/fsharp/blob/master/src/fsharp/fsi/fsi.fs#l2219&#34;&gt;FsiEvaluationSession&lt;/a&gt; type to allow it to be encapsulated and used by our interface.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-fsharp&#34;&gt;type FSharpEngine(host:ScriptHost) = 
   let stdin        = new StreamReader(System.IO.Stream.Null)
   let stdoutStream = new CompilerOutputStream()
   let stdout       = StreamWriter.Synchronized(new StreamWriter(stdoutStream, AutoFlush=true))
   let stderrStream = new CompilerOutputStream()
   let stderr       = StreamWriter.Synchronized(new StreamWriter(stderrStream, AutoFlush=true))
    
   let getOutput (session: FsiEvaluationSession) code = 

      let tryget() = 
         let error = stderrStream.Read()
         if error.Length &amp;gt; 0 then Error(error) else
         Success(stdoutStream.Read())

      try session.EvalInteraction(code)
          if code.EndsWith &amp;quot;;;&amp;quot; then tryget() 
          else Incomplete
      with ex -&amp;gt; Error ex.Message
        
   let commonOptions = [| &amp;quot;fsi.exe&amp;quot;; &amp;quot;--nologo&amp;quot;; &amp;quot;--readline-&amp;quot;|]
   let session = FsiEvaluationSession(commonOptions, stdin, stdout, stderr)

   let (&amp;gt;&amp;gt;=) (d1:#IDisposable) (d2:#IDisposable) = 
      {new IDisposable with member x.Dispose() = d1.Dispose(); d2.Dispose()}

   member x.Execute(code) = 
      getOutput session code

   member x.AddReference(ref) =
      session.EvalInteraction(sprintf &amp;quot;#r @\&amp;quot;%s\&amp;quot;&amp;quot; ref)

   member x.SilentAddReference(ref) = 
      x.AddReference(ref)
      stdoutStream.Read() |&amp;gt; ignore

   member x.ImportNamespace(namespace&#39;) =
      session.EvalInteraction(sprintf &amp;quot;open %s&amp;quot; namespace&#39;)

   member x.SilentImportNamespace(namespace&#39;) =
      x.ImportNamespace(namespace&#39;)
      stdoutStream.Read() |&amp;gt; ignore

   interface IDisposable with
      member x.Dispose() =
         (stdin &amp;gt;&amp;gt;= stdoutStream &amp;gt;&amp;gt;= stdout &amp;gt;&amp;gt;= stderrStream &amp;gt;&amp;gt;= stderr).Dispose()
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;We are mainly just wrapping the &lt;code&gt;FsiEvaluationSession&lt;/code&gt; here, adding convenience methods to evaluate code and gather the output from the compiler streams.  The current open source implementation of &lt;code&gt;FsiEvaluationSession&lt;/code&gt; uses streams to add input and receive the output and errors.  Stream processing makes sense when you are just dealing with a Console with in, out, and error streams, but it gets decidedly more complex if you want deterministic evaluation.  Stream observation, polling, and looking for termination characters is fairly awkward to get right.&lt;/p&gt;

&lt;p&gt;After a few conversations with &lt;a href=&#34;http://blogs.msdn.com/b/dsyme/&#34;&gt;Don Syme&lt;/a&gt; he kindly assisted with an experimental version of &lt;code&gt;FsiEvaluationSession&lt;/code&gt; that allowed expressions to be evaluated using the &lt;code&gt;EvalInteraction&lt;/code&gt; and &lt;code&gt;EvalExpression&lt;/code&gt; functions rather than writing directly to the input stream.  I&amp;rsquo;m very grateful for the work Don has done so far to help me with this.  I think more work on hosted compilation will result in a lot of very useful tools and techniques.&lt;/p&gt;

&lt;p&gt;You can also see in this section that I was also playing around with the symbolic operator &lt;code&gt;&amp;gt;&amp;gt;=&lt;/code&gt; to compose together all the disposable streams at once.  I suppose the inspiration for this (If you can call it that) is &lt;a href=&#34;http://msdn.microsoft.com/en-us/data/gg577609.aspx&#34;&gt;Reactive Extensions&lt;/a&gt; which has a &lt;a href=&#34;http://msdn.microsoft.com/en-us/library/system.reactive.disposables.compositedisposable(v=vs.103).aspx&#34;&gt;CompositeDisposable&lt;/a&gt;, and also the disposable computation builder that &lt;a href=&#34;http://tomasp.net/blog/&#34;&gt;Tomas Petricek&lt;/a&gt; made available as &lt;a href=&#34;http://www.fssnip.net&#34;&gt;fssnip&lt;/a&gt;.  The &lt;a href=&#34;http://msdn.microsoft.com/en-us/library/dd233237.aspx&#34;&gt;object expression&lt;/a&gt; that I used here seemed like a sensible option, and also shows the usefulness of object expressions.&lt;/p&gt;

&lt;p&gt;Finally we implement the interface using the &lt;code&gt;FSharpEngine&lt;/code&gt; as the type to be stored in the scripting session:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-fsharp&#34;&gt;type  FSharpScriptEngine( scriptHostFactory:IScriptHostFactory, logger: ILog) =
   let mutable baseDir = String.empty
   let [&amp;lt;Literal&amp;gt;]sessionKey = &amp;quot;F# Session&amp;quot;
   
   interface IScriptEngine with
      member x.BaseDirectory with get() = baseDir and set value = baseDir &amp;lt;- value
      member x.Execute(code, args, references, namespaces, scriptPackSession) =
         let distinctReferences = references.Union(scriptPackSession.References).Distinct()
         let sessionState = 
            match scriptPackSession.State.TryGetValue sessionKey with
            | false, _ -&amp;gt; let host = scriptHostFactory.CreateScriptHost(ScriptPackManager(scriptPackSession.Contexts), args)
                          logger.Debug(&amp;quot;Creating session&amp;quot;)
                          let session = new FSharpEngine(host)
                 
                          distinctReferences |&amp;gt; Seq.iter (fun ref -&amp;gt; logger.DebugFormat(&amp;quot;Adding reference to {0}&amp;quot;, ref)
                                                                     session.SilentAddReference ref )
                 
                          namespaces.Union(scriptPackSession.Namespaces).Distinct() 
                          |&amp;gt; Seq.iter (fun ns -&amp;gt; logger.DebugFormat(&amp;quot;Importing namespace {0}&amp;quot;, ns)
                                                 session.SilentImportNamespace ns)
                 
                          let sessionState = SessionState&amp;lt;_&amp;gt;(References = distinctReferences, Session = session)
                          scriptPackSession.State.Add(sessionKey, sessionState)
                          sessionState 
            | true, res -&amp;gt; logger.Debug(&amp;quot;Reusing existing session&amp;quot;) 
                           let sessionState = res :?&amp;gt; SessionState&amp;lt;FSharpEngine&amp;gt;
                           
                           let newReferences = match sessionState.References with
                                               | null -&amp;gt; distinctReferences
                                               | refs when Seq.isEmpty refs -&amp;gt; distinctReferences
                                               | refs -&amp;gt;  distinctReferences.Except refs
                           newReferences |&amp;gt; Seq.iter (fun ref -&amp;gt; logger.DebugFormat(&amp;quot;Adding reference to {0}&amp;quot;, ref)
                                                                 sessionState.Session.AddReference ref ) 
                           sessionState      

         match sessionState.Session.Execute(code) with
         | Success result -&amp;gt; let cleaned = 
                                result.Split([|&amp;quot;\r&amp;quot;; &amp;quot;\n&amp;quot;|], StringSplitOptions.RemoveEmptyEntries)
                                |&amp;gt; Array.filter (fun str -&amp;gt; not(str = &amp;quot;&amp;gt; &amp;quot;))
                                |&amp;gt; String.concat &amp;quot;\r\n&amp;quot;
                             ScriptResult(ReturnValue = cleaned)
         | Error e -&amp;gt; ScriptResult(CompileException = exn e )
         | Incomplete -&amp;gt; ScriptResult()
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;For the most part &lt;code&gt;Execute&lt;/code&gt; is a simple port of the Roslyn implementation, mainly due to the way ScriptCs is currently implemented.  There is a preprocessor that amongst other things parses reference additions &lt;code&gt;(#r)&lt;/code&gt;, passing them down to the &lt;code&gt;Execute&lt;/code&gt; method.  I think eventually a registrable command plugin for ScriptCs will appear that will make custom REPL commands easy to add and configure.&lt;/p&gt;

&lt;p&gt;Any new references are added in this snippet, where we leverage pattern matching.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-fsharp&#34;&gt;let newReferences = match sessionState.References with
                    | null -&amp;gt; distinctReferences
                    | refs when Seq.isEmpty refs -&amp;gt; distinctReferences
                    | refs -&amp;gt;  distinctReferences.Except refs
newReferences |&amp;gt; Seq.iter (fun ref -&amp;gt; logger.DebugFormat(&amp;quot;Adding reference to {0}&amp;quot;, ref)
                                      sessionState.Session.AddReference ref )
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Also of note is the final matching block &lt;code&gt;match sessionState.Session.Execute(code) with&lt;/code&gt;  we use pattern matching against the discriminated union that is returned by &lt;code&gt;Session.Execute(code)&lt;/code&gt;.  If &lt;code&gt;Execute&lt;/code&gt; returns a &lt;code&gt;Success&lt;/code&gt; we do a bit of a clean up on the result.  We split the string based on carriage returns and newlines, filter out any prompts &lt;code&gt;&amp;gt;&lt;/code&gt;, then reassemble the sting using &lt;code&gt;String.Concat&lt;/code&gt;.  We put this into the &lt;code&gt;Result&lt;/code&gt; property of a &lt;code&gt;ScriptResult&lt;/code&gt;.  I do actually have a version of &lt;code&gt;FsiEvaluationSession&lt;/code&gt; that suppresses prompts but I&amp;rsquo;ve not merged that in yet.  An &lt;code&gt;Error&lt;/code&gt; results in the &lt;code&gt;CompileException&lt;/code&gt; property being used on the &lt;code&gt;ScriptResult&lt;/code&gt;.  Finally if the expression is &lt;code&gt;Incomplete&lt;/code&gt; we don&amp;rsquo;t output a result or display an error as we are waiting for more input, we simply return an empty &lt;code&gt;ScriptResult&lt;/code&gt;.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-fsharp&#34;&gt;match sessionState.Session.Execute(code) with
| Success result -&amp;gt; let cleaned = 
                       result.Split([|&amp;quot;\r&amp;quot;; &amp;quot;\n&amp;quot;|], StringSplitOptions.RemoveEmptyEntries)
                       |&amp;gt; Array.filter (fun str -&amp;gt; not(str = &amp;quot;&amp;gt; &amp;quot;))
                       |&amp;gt; String.concat &amp;quot;\r\n&amp;quot;
                    ScriptResult(ReturnValue = cleaned)
| Error e -&amp;gt; ScriptResult(CompileException = exn e )
| Incomplete -&amp;gt; ScriptResult()
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The final part is to plug this into ScriptSC, we do this by changing the &lt;code&gt;Initialize&lt;/code&gt; method of &lt;code&gt;CompositionRoot&lt;/code&gt;, all we need to do is Register our engine rather than the &lt;code&gt;RoslynScriptEngine&lt;/code&gt; one:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;builder.RegisterType&amp;lt;ScriptExecutor&amp;gt;().As&amp;lt;IScriptExecutor&amp;gt;();
builder.RegisterType&amp;lt;RoslynScriptEngine&amp;gt;().As&amp;lt;IScriptEngine&amp;gt;();
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;To this:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;builder.RegisterType&amp;lt;ScriptExecutor&amp;gt;().As&amp;lt;IScriptExecutor&amp;gt;();
builder.RegisterType&amp;lt;FSharpScriptEngine&amp;gt;().As&amp;lt;IScriptEngine&amp;gt;();
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;And there we have it, hack session complete!&lt;/p&gt;

&lt;p&gt;Several thing are missing from my implementation, namely debug support and script pack support.  The guys over at ScriptCs are continuing to evolve the API to allow plugins like this to work properly.  Multi-line support should be coming soon, if you run a REPL session using F# then a prompt is added when you hit return.  There is also a GitHub issue raised to &lt;a href=&#34;https://github.com/scriptcs/scriptcs/issues/346&#34;&gt;add runtime packs for plugging in different runtimes/languages&lt;/a&gt;, this will pave the way for ScriptCs to be available on Mono too &lt;em&gt;(If you disable the Roslyn based project and only use the F# Engine then it does actually work on Mono now.)&lt;/em&gt;.&lt;/p&gt;

&lt;p&gt;Once these issues are resolved in ScriptCs then hopefully F# will become a simple language plugin or even be merged into ScriptCs itself.&lt;/p&gt;

&lt;p&gt;You can find my GitHub repository &lt;a href=&#34;https://github.com/7sharp9/scriptcs&#34;&gt;here&lt;/a&gt;, feel free to hack away, add issues, pull requests are welcome too!&lt;/p&gt;

&lt;p&gt;Until next time!&lt;/p&gt;

&lt;hr style=&#34;margin: 1em 0&#34;&gt;
&lt;h1 id=&#34;essential-listening&#34;&gt;Essential listening:&lt;/h1&gt;


&lt;div class=&#34;pure-g&#34;&gt;

  
  
  
  
  &lt;div class=&#34;&#34;&gt;
    &lt;div style=&#34;width: 20%; float: left;padding: 0 .2em .2em 0&#34;&gt;
        &lt;figure style=&#34;margin: 0&#34;&gt;
            &lt;img src=&#34;http://upload.wikimedia.org/wikipedia/en/8/81/The_Smashing_Pumpkins_-_Oceania_cover.jpg&#34; style=&#34;margin: 0&#34;
                 alt=&#34;Smashing Pumpkins - Oceania&#34; /&gt;
            &lt;figcaption&gt;
                &lt;h6&gt;Smashing Pumpkins - Oceania&lt;/h4&gt;
            &lt;/figcaption&gt;
        &lt;/figure&gt;
    &lt;/div&gt;
  &lt;/div&gt;
  

  
  
  
  
  &lt;div class=&#34;&#34;&gt;
    &lt;div style=&#34;width: 20%; float: left;padding: 0 .2em .2em 0&#34;&gt;
        &lt;figure style=&#34;margin: 0&#34;&gt;
            &lt;img src=&#34;http://upload.wikimedia.org/wikipedia/en/d/dc/Megadeth-RustInPeace.jpg&#34; style=&#34;margin: 0&#34;
                 alt=&#34;Megadeth - Rust In Peace&#34; /&gt;
            &lt;figcaption&gt;
                &lt;h6&gt;Megadeth - Rust In Peace&lt;/h4&gt;
            &lt;/figcaption&gt;
        &lt;/figure&gt;
    &lt;/div&gt;
  &lt;/div&gt;
  

&lt;/div&gt;




</description>
    </item>
    
    <item>
      <title>Monster Zero - Revisited</title>
      <link>http://7sharpnine.com/2013/06/05/2013-06-05-monster-zero-revisited/</link>
      <pubDate>Wed, 05 Jun 2013 00:00:00 +0000</pubDate>
      
      <guid>http://7sharpnine.com/2013/06/05/2013-06-05-monster-zero-revisited/</guid>
      <description>

&lt;p&gt;
&lt;figure class=&#34;img-left&#34;&gt;
    
        &lt;img src=&#34;http://upload.wikimedia.org/wikipedia/en/c/ce/KingGhidorah.jpg&#34; /&gt;
    
    
&lt;/figure&gt;
&lt;br /&gt;
This creature is capable of tremendous destruction due to it&amp;rsquo;s size, flight &lt;em&gt;(with the creature&amp;rsquo;s wings also generating hurricane strength winds)&lt;/em&gt; and possesses several breath weapons &lt;em&gt;(e.g., heat and energy)&lt;/em&gt;.&lt;/p&gt;

&lt;p&gt;What am I talking about here?  Maybe it&amp;rsquo;s &lt;a href=&#34;http://en.wikipedia.org/wiki/King_Ghidorah&#34;&gt;Monster Zero&lt;/a&gt; or &lt;a href=&#34;http://en.wikipedia.org/wiki/King_Ghidorah&#34;&gt;King Ghidorah&lt;/a&gt; as it&amp;rsquo;s sometimes known.  No it&amp;rsquo;s &lt;a href=&#34;http://msdn.microsoft.com/en-us/library/hh228603.aspx&#34;&gt;TPL Dataflow&lt;/a&gt;!  &lt;!-- more --&gt;&lt;/p&gt;

&lt;p&gt;Yeah, yeah, I have a penchant for being over dramatic and writing quirky intros.  This post is about &lt;a href=&#34;http://msdn.microsoft.com/en-us/library/hh228603.aspx&#34;&gt;TPL Dataflow&lt;/a&gt; otherwise known as TDF.  I have blogged about this before in my &lt;a href=&#34;http://7sharpnine.com/2012/01/22/2012-01-22-fsharp-dataflow-agents-i/&#34;&gt;TDF agent series&lt;/a&gt; but I thought it might be worth while returning to it while on the subject of monsters.&lt;/p&gt;

&lt;p&gt;The purpose of these posts is not to put you of using these libraries but to give you feel of how they might be used from an F# viewpoint.  Its not always easy to use these libraries even from C#, so jumping to another paradigm can sometimes leave you feeling bewildered, frustrated and lost.&lt;/p&gt;

&lt;h3 id=&#34;what-is-tpl-dataflow&#34;&gt;What is TPL Dataflow&lt;/h3&gt;

&lt;p&gt;According to MSDN here&amp;rsquo;s the description of TPL dataflow:&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;The Task Parallel Library (TPL) provides dataflow components to help increase the robustness of concurrency-enabled applications. These dataflow components are collectively referred to as the TPL Dataflow Library. This dataflow model promotes actor-based programming by providing in-process message passing for coarse-grained dataflow and pipelining tasks.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;Checkout the &lt;a href=&#34;http://msdn.microsoft.com/en-us/library/hh228603.aspx&#34;&gt;MSDN&lt;/a&gt; if you want to read a more in depth outline on TDF, or you could also refer to my &lt;a href=&#34;http://7sharpnine.com/2012/01/22/2012-01-22-fsharp-dataflow-agents-i/&#34;&gt;earlier posts&lt;/a&gt; too.&lt;/p&gt;

&lt;h3 id=&#34;sample-problem&#34;&gt;Sample problem&lt;/h3&gt;

&lt;p&gt;Here&amp;rsquo;s a sample problem:  We have two documents that we want to use to collate a list of word occurrences, we then want to collect the results from both documents and print out the combined results.&lt;/p&gt;

&lt;p&gt;Although we&amp;rsquo;re using TDF to solve this problem, we could of also used F# agents, Reactive Extensions, Linq, TPL, or a mix of all of those.&lt;/p&gt;

&lt;p&gt;We will stick to using the &lt;a href=&#34;http://msdn.microsoft.com/en-us/library/dd233175.aspx&#34;&gt;F# REPL&lt;/a&gt; for this post as it&amp;rsquo;s fairly simple example and allows for a bit of interactivity.  Lets start by adding a reference, open up a few namespace&amp;rsquo;s and read a couple of text files in.  In this instance we&amp;rsquo;re going to use &lt;a href=&#34;http://en.wikipedia.org/wiki/Jane_Eyre&#34;&gt;Jane Eyre&lt;/a&gt; by Charlotte Bronte, and &lt;a href=&#34;http://en.wikipedia.org/wiki/Algernon_Blackwood#Novels&#34;&gt;The Wendigo&lt;/a&gt; by Algernon Blackwood, for no reason other than they were free to download and use as samples.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-fsharp&#34;&gt;#r &amp;quot;System.Threading.Tasks.Dataflow&amp;quot;
open System
open System.IO
open System.Threading.Tasks.Dataflow

let janeEyre = File.ReadAllText(@&amp;quot;Jane Eyre [Charlotte Bronte].txt&amp;quot;)
let theWendigo = File.ReadAllText(@&amp;quot;The Wendigo [Algernon Blackwood].txt&amp;quot;)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The next thing we need to think about is how to count the words.  Let&amp;rsquo;s create a recursive function that counts each occurrence of a passed in word against the full text.  The &lt;code&gt;wordCount&lt;/code&gt; function recurses until &lt;code&gt;-1&lt;/code&gt; is returned from the &lt;code&gt;IndexOf&lt;/code&gt; function.  Before you argue about memory allocation, laziness etc, we&amp;rsquo;re not interested in that at the moment, we just want to solve the problem at hand.  It would be fairly easy to split the input into a lazy sequence and iterate over it so we only keep a single line in memory.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-fsharp&#34;&gt;let wordCount (text: String) word =
   let rec loop position count =
      match text.IndexOf(word, position, StringComparison.InvariantCultureIgnoreCase) with
      | -1 -&amp;gt; count
      | i -&amp;gt;  loop (i + word.Length) (count + 1)
   loop 0 0
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Now we can start to create some TDF blocks, we shall create a &lt;a href=&#34;http://msdn.microsoft.com/en-us/library/hh160447.aspx&#34;&gt;BroadcastBlock&lt;/a&gt; first.&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;A BroadcastBlock provides a buffer for storing at most one element at time, overwriting each message with the next as it arrives.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;Messages are broadcast to all linked targets, all of which may consume a clone of the message.&lt;/p&gt;

&lt;p&gt;The lambda expression passed into the &lt;code&gt;BroadcastBlock&lt;/code&gt; is it&amp;rsquo;s clone function, in this case we will just use the string that is passed in: &lt;code&gt;fun s -&amp;gt; s&lt;/code&gt;.  We will be using the &lt;code&gt;BroadcastBlock&lt;/code&gt; to send the same message to multiple destinations later on.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-fsharp&#34;&gt;let broadcast = BroadcastBlock(fun s -&amp;gt; s)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Now we will create a couple of &lt;a href=&#34;http://msdn.microsoft.com/en-us/library/hh194782.aspx&#34;&gt;TransformBlocks&lt;/a&gt;.&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;A TransformBlock provides a dataflow block that invokes a provided Func(T, TResult) delegate for every data element received.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;The &lt;code&gt;TransformBlock&lt;/code&gt; will accept a data element and transform it by invoking it&amp;rsquo;s transform function.  Here we will &lt;a href=&#34;http://msdn.microsoft.com/en-us/library/dd233229.aspx&#34;&gt;partially apply&lt;/a&gt; the &lt;code&gt;wordCount&lt;/code&gt; function by passing in the first parameter &lt;code&gt;text&lt;/code&gt;.  This means that whenever the &lt;code&gt;TransformBlock&lt;/code&gt; is passed data the &lt;code&gt;wordCount&lt;/code&gt; function will already have the &lt;code&gt;text&lt;/code&gt; parameter applied and will return the number of matches from the document.  The context of passed data here will be the word that we want to find.  We&amp;rsquo;ll create one for Jane Eyre and one for The Wendigo:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-fsharp&#34;&gt;let transformJaneEyre = TransformBlock(wordCount janeEyre)
let transformTheWendigo  = TransformBlock(wordCount theWendigo)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Now that we have created three blocks we need to think about linking them together.  You can do this with the &lt;code&gt;LinkTo&lt;/code&gt; method that every dataflow block has.  We could do that by calling the &lt;code&gt;LinkTo&lt;/code&gt; methods as usual like this:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-fsharp&#34;&gt;broadcast.LinkTo(transformJaneEyre) |&amp;gt; ignore
broadcast.LinkTo(transformTheWendigo) |&amp;gt; ignore
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;That seems a little awkward, especially as we&amp;rsquo;re not interested in the return parameter in this example, so instead we&amp;rsquo;re going to create a little function to make this a little bit easier for ourselves:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-fsharp&#34;&gt;let (--&amp;gt;) source target = DataflowBlock.LinkTo(source, target) |&amp;gt; ignore
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The &lt;code&gt;LinkTo&lt;/code&gt; method returns an &lt;code&gt;IDisposable&lt;/code&gt; that can be use to sever the link between the blocks that have just been joined.  There are also overloads of &lt;code&gt;LinkTo&lt;/code&gt; that allow you to specify a predicate.  There is also an overload that takes a &lt;code&gt;DataflowLinkOptions&lt;/code&gt; type which allows you to specify whether the new link is appended (&lt;code&gt;Append&lt;/code&gt;), the maximum message that can be passed before the block is unlinked (&lt;code&gt;MaxMessages&lt;/code&gt;), and finally and whether or not the completion of the former block is propagated to the latter (&lt;code&gt;PropagateCompletion&lt;/code&gt;).&lt;/p&gt;

&lt;p&gt;We can now use the &lt;code&gt;--&amp;gt;&lt;/code&gt; symbolic operator and use &lt;a href=&#34;http://msdn.microsoft.com/en-us/library/dd233204.aspx&#34;&gt;infix notation&lt;/a&gt; to link the blocks together.  Infix operators are expected to be placed between the two operands, which means we can define the links between the block like this:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-fsharp&#34;&gt;broadcast --&amp;gt; transformJaneEyre
broadcast --&amp;gt; transformTheWendigo
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Next we create a &lt;a href=&#34;http://msdn.microsoft.com/en-us/library/hh160286.aspx&#34;&gt;JoinBlock&lt;/a&gt;.&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;A JoinBlock provides a dataflow block that joins across multiple dataflow sources, which are not necessarily of the same type, waiting for one item to arrive for each type before they’re all released together as a tuple that contains one item per type.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;pre&gt;&lt;code class=&#34;language-fsharp&#34;&gt;let join = JoinBlock&amp;lt;_,_,_&amp;gt;()

broadcast           --&amp;gt; join.Target1
transformJaneEyre   --&amp;gt; join.Target2
transformTheWendigo --&amp;gt; join.Target3
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;We create the &lt;code&gt;JoinBlock&lt;/code&gt; then link the &lt;code&gt;broadcast&lt;/code&gt;, &lt;code&gt;transformJaneEyre&lt;/code&gt;, and &lt;code&gt;transformTheWendigo&lt;/code&gt; to it.  This means that the &lt;code&gt;JoinBlock&lt;/code&gt; will wait for data from &lt;strong&gt;all&lt;/strong&gt; three blocks before sending the data on as a tuple of the three values.&lt;/p&gt;

&lt;p&gt;Finally we create the last block which is an &lt;a href=&#34;http://msdn.microsoft.com/en-us/library/hh194684.aspx&#34;&gt;ActionBlock&lt;/a&gt;&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;An ActionBlock provides a dataflow block that invokes a provided Action(T) delegate for every data element received.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;pre&gt;&lt;code class=&#34;language-fsharp&#34;&gt;let writeOutput = 
    ActionBlock(fun(word:String, count1, count2) -&amp;gt; 
       Console.WriteLine(&amp;quot;Word: {0}, Jane Eyre: {1}, The Wendigo: {2}&amp;quot;, 
                         word.PadRight(10),
                         (string count1).PadLeft(3), 
                         (string count2).PadLeft(3) ) )
    
join --&amp;gt; writeOutput
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Right, that completes the hook up, now all that&amp;rsquo;s left is to test it.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-fsharp&#34;&gt;let words = [|&amp;quot;cat&amp;quot;;&amp;quot;cake&amp;quot;;&amp;quot;anything&amp;quot;;&amp;quot;laugh&amp;quot;;&amp;quot;breeze&amp;quot;;&amp;quot;hysterical&amp;quot;;&amp;quot;ball&amp;quot;;&amp;quot;them&amp;quot;;&amp;quot;home&amp;quot;;&amp;quot;bird&amp;quot;|]
for word in words do 
  broadcast.Post(word) |&amp;gt; ignore
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;If we execute this then we we get the following output:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;Word: cat       , Jane Eyre: 212, The Wendigo:  73
Word: cake      , Jane Eyre:  15, The Wendigo:   0
Word: anything  , Jane Eyre:  60, The Wendigo:  19
Word: laugh     , Jane Eyre:  68, The Wendigo:  17
Word: breeze    , Jane Eyre:  11, The Wendigo:   0
Word: hysterical, Jane Eyre:   1, The Wendigo:   1
Word: ball      , Jane Eyre:  11, The Wendigo:   1
Word: them      , Jane Eyre: 432, The Wendigo:  72
Word: home      , Jane Eyre:  90, The Wendigo:  11
Word: bird      , Jane Eyre:  35, The Wendigo:   0
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;summary&#34;&gt;Summary&lt;/h3&gt;

&lt;p&gt;From a conceptual viewpoint of view we&amp;rsquo;re creating a BroadcastBlock which connects to two TransformBlocks.  The two TransformBlocks are then connected to the JoinBlock along with the BroadcastBlock.  Finally, the JoinBlock is connected to the ActionBlock.&lt;/p&gt;

&lt;p&gt;This creates a mini network where you can simply post a message to the input of the dataflow network and it will propagate through the network.  As with Reactive Extensions marble diagrams and pipeline diagrams are a great way to visualise the process flow.&lt;/p&gt;


&lt;figure &gt;
    
        &lt;img src=&#34;https://lh5.googleusercontent.com/-r5TZAl6VERo/UbCwd4MXGTI/AAAAAAAABpg/MmQIb_0nwb8/w769-h218-no/Screen&amp;#43;Shot&amp;#43;2013-06-06&amp;#43;at&amp;#43;16.50.31.png&#34; /&gt;
    
    
&lt;/figure&gt;


&lt;p&gt;I hope that sheds a little bit of light on how a dataflow network can be created with TDF.  Extremely complex behaviour&amp;rsquo;s can be created by connecting up the simple dataflow building blocks, especially as the different block&amp;rsquo;s can run with multiple degrees of parallelism an also run asynchronously using &lt;code&gt;Task&amp;lt;T&amp;gt;&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;Until next time!&lt;/p&gt;

&lt;hr style=&#34;margin: 1em 0&#34;&gt;
&lt;h1 id=&#34;essential-listening&#34;&gt;Essential listening:&lt;/h1&gt;


&lt;div class=&#34;pure-g&#34;&gt;

  
  
  
  
  &lt;div class=&#34;&#34;&gt;
    &lt;div style=&#34;width: 20%; float: left;padding: 0 .2em .2em 0&#34;&gt;
        &lt;figure style=&#34;margin: 0&#34;&gt;
            &lt;img src=&#34;http://upload.wikimedia.org/wikipedia/en/4/43/AIC_Unplugged.jpg&#34; style=&#34;margin: 0&#34;
                 alt=&#34;Alice In Chains - Unplugged&#34; /&gt;
            &lt;figcaption&gt;
                &lt;h6&gt;Alice In Chains - Unplugged&lt;/h4&gt;
            &lt;/figcaption&gt;
        &lt;/figure&gt;
    &lt;/div&gt;
  &lt;/div&gt;
  

  
  
  
  
  &lt;div class=&#34;&#34;&gt;
    &lt;div style=&#34;width: 20%; float: left;padding: 0 .2em .2em 0&#34;&gt;
        &lt;figure style=&#34;margin: 0&#34;&gt;
            &lt;img src=&#34;http://upload.wikimedia.org/wikipedia/en/6/64/MeteoraLP.jpg&#34; style=&#34;margin: 0&#34;
                 alt=&#34;Linkin Park - Meteora&#34; /&gt;
            &lt;figcaption&gt;
                &lt;h6&gt;Linkin Park - Meteora&lt;/h4&gt;
            &lt;/figcaption&gt;
        &lt;/figure&gt;
    &lt;/div&gt;
  &lt;/div&gt;
  

  
  
  
  
  &lt;div class=&#34;&#34;&gt;
    &lt;div style=&#34;width: 20%; float: left;padding: 0 .2em .2em 0&#34;&gt;
        &lt;figure style=&#34;margin: 0&#34;&gt;
            &lt;img src=&#34;http://upload.wikimedia.org/wikipedia/en/4/44/Soilscars.jpg&#34; style=&#34;margin: 0&#34;
                 alt=&#34;Soil - Scars&#34; /&gt;
            &lt;figcaption&gt;
                &lt;h6&gt;Soil - Scars&lt;/h4&gt;
            &lt;/figcaption&gt;
        &lt;/figure&gt;
    &lt;/div&gt;
  &lt;/div&gt;
  

&lt;/div&gt;




</description>
    </item>
    
    <item>
      <title>Some kind of monster</title>
      <link>http://7sharpnine.com/2013/06/01/2013-06-01-some-kind-of-monster/</link>
      <pubDate>Sat, 01 Jun 2013 00:00:00 +0000</pubDate>
      
      <guid>http://7sharpnine.com/2013/06/01/2013-06-01-some-kind-of-monster/</guid>
      <description>

&lt;p&gt;
&lt;figure class=&#34;img-left third&#34;&gt;
    
        &lt;img src=&#34;http://upload.wikimedia.org/wikipedia/en/2/29/Godzilla_%2754_design.jpg&#34; /&gt;
    
    
&lt;/figure&gt;

What&amp;rsquo;s 100 meters high and weighs in at around 60,000 tons?   No its not Godzilla, its Reactive extensions!&lt;/p&gt;

&lt;p&gt;Lately on one of my projects I have been doing a lot of stream manipulation, and although I solved the problem quite easily using F# async workflows, there were other solutions available to help solve the problem.  I could of used things like &lt;a href=&#34;http://msdn.microsoft.com/en-us/library/vstudio/hh191443.aspx&#34;&gt;async await&lt;/a&gt;, &lt;a href=&#34;http://msdn.microsoft.com/en-us/library/hh228603.aspx&#34;&gt;TPL Dataflow(TDF)&lt;/a&gt;, and &lt;a href=&#34;http://rx.codeplex.com&#34;&gt;Reactive Extensions (Rx)&lt;/a&gt;.  This is going to be a short post on using Rx with F#.  &lt;!-- more --&gt;&lt;/p&gt;

&lt;h3 id=&#34;what-is-rx&#34;&gt;What is Rx?&lt;/h3&gt;

&lt;p&gt;Well for those of you that don&amp;rsquo;t know anything about Rx I would suggest reading up a bit of the introduction material &lt;a href=&#34;http://rx.codeplex.com&#34;&gt;here&lt;/a&gt;.  Here&amp;rsquo;s a quick recap of what Rx is for everyone else:
&amp;gt; The Reactive Extensions (Rx) is a library for composing asynchronous and event-based programs using observable sequences and LINQ-style query operators. Using Rx, developers represent asynchronous data streams with Observables , query asynchronous data streams using LINQ operators , and parameterize the concurrency in the asynchronous data streams using Schedulers . Simply put, Rx = Observables + LINQ + Schedulers.&lt;/p&gt;

&lt;h3 id=&#34;sample-problem&#34;&gt;Sample problem&lt;/h3&gt;

&lt;p&gt;Here&amp;rsquo;s a sample problem:  I want to read from a file in buffered chunks and perform an action whenever a chunk is read.  As I said before there a many different ways to solve this problem but We&amp;rsquo;ll use C# as a base to see how it could be done first in C#.  For this example We&amp;rsquo;ll add an Extension extension method to the &lt;code&gt;Stream&lt;/code&gt; class:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-csharp&#34;&gt;public static class Extensions
{
   public static IObservable&amp;lt;byte[]&amp;gt; ToObservable (this Stream stream, int size)
   {
      return Observable.Create&amp;lt;byte[]&amp;gt; (observer =&amp;gt;
      {
         byte[] buffer = new byte[size];
         var deferedRead = Observable.Defer(() =&amp;gt; stream.ReadAsync (buffer, 0, size).ToObservable());
         return Observable.Repeat(deferedRead)
                          .Select (i =&amp;gt; buffer.Take(i).ToArray ())
                          .Subscribe (data =&amp;gt; { if (data.Length &amp;gt; 0) observer.OnNext (data);
                                                else observer.OnCompleted ();
                                              }, observer.OnError, observer.OnCompleted);
      });
   }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Using this extension method we can then do something like this:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-csharp&#34;&gt;var source = new FileStream (@&amp;quot;test.txt&amp;quot;, FileMode.Open, FileAccess.Read);
source.ToObservable (16).Subscribe (_ =&amp;gt; Console.WriteLine(_.Length));
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;This will print to the console the length of each chunk as it is read.&lt;/p&gt;

&lt;p&gt;There are quite a few different Rx operators in this example, &lt;code&gt;Create&lt;/code&gt;, &lt;code&gt;Defer&lt;/code&gt;, &lt;code&gt;ToObservable&lt;/code&gt;, &lt;code&gt;Repeat&lt;/code&gt;, &lt;code&gt;Select&lt;/code&gt;, and &lt;code&gt;Subscribe&lt;/code&gt;.  Lets quickly go though the example and see what&amp;rsquo;s going on.&lt;/p&gt;

&lt;p&gt;First of all we create a custom observable sequence using &lt;code&gt;Observable.Create&lt;/code&gt;.  This takes a lambda function with a single parameter &lt;code&gt;observer&lt;/code&gt;, which is of type &lt;code&gt;IObserver&amp;lt;byte[]&amp;gt;&lt;/code&gt;.  Using the &lt;code&gt;observer&lt;/code&gt; we can produce elements in the sequence by using the methods &lt;code&gt;OnNext&lt;/code&gt;, &lt;code&gt;OnError&lt;/code&gt; and &lt;code&gt;OnCompleted&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;Next up we create a buffer to hold the data which will be read from the file in chunks.  This is just a simple array allocation &lt;code&gt;byte[] buffer = new byte[size];&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;To allow us to consume the data from the file stream we can use the &lt;code&gt;ReadAsync&lt;/code&gt; method which will return a &lt;code&gt;Task&amp;lt;byte[]&amp;gt;&lt;/code&gt;.  There is an Rx extension method on &lt;code&gt;Task&lt;/code&gt; called &lt;code&gt;ToObservable&lt;/code&gt; so we use that too.  You will notice in the code that we are using &lt;code&gt;Observable.Defer&lt;/code&gt;.  Why are we using that?  What would happen if we didn&amp;rsquo;t?  Well, if we don&amp;rsquo;t defer the &lt;code&gt;Task&lt;/code&gt; for later execution and simply use to &lt;code&gt;Task.ToObservable()&lt;/code&gt; we would be creating a new instance of the &lt;code&gt;Observable&lt;/code&gt; sequence each time &lt;code&gt;ReadAsync&lt;/code&gt; is called - This would mean we would have an infinite sequence comprised of the first chunk of the file, which isnt waht we want at all.  By using &lt;code&gt;Defer&lt;/code&gt; we don&amp;rsquo;t invoke the &lt;code&gt;Observable&lt;/code&gt; &lt;code&gt;Task&lt;/code&gt; until first subscription to the &lt;code&gt;Observable&lt;/code&gt; sequence.&lt;/p&gt;

&lt;p&gt;We use a fluent style to repeat the deferred Observable &lt;code&gt;deferedRead&lt;/code&gt; using the &lt;code&gt;Repeat&lt;/code&gt; method.&lt;/p&gt;

&lt;p&gt;&lt;code&gt;Select&lt;/code&gt; is now used to take the number of bytes from the &lt;code&gt;buffer&lt;/code&gt;, we might have a stream which is not divisible by the buffer size which will mean that the last read will not be the size of the buffer.  In the lambda expression the &lt;code&gt;i&lt;/code&gt; parameter is the number of the bytes returned from &lt;code&gt;ReadAsync&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;Finally we have &lt;code&gt;Subscribe&lt;/code&gt;, this takes a lambda that is passed &lt;code&gt;data&lt;/code&gt;, data being the current chunk or &lt;code&gt;byte[]&lt;/code&gt;.  In the body of the lambda we check to see if we have received any bytes, if so then we call &lt;code&gt;observer.OnNext(data)&lt;/code&gt; which creates the next element in the sequence.  If we didn&amp;rsquo;t receive data then we call &lt;code&gt;observer.OnCompleted()&lt;/code&gt;, which completes the sequence.  The last two parameters for &lt;code&gt;Subscribe&lt;/code&gt; are the error and completed actions, we simply use the ones in the observer - &lt;code&gt;observer.OnError&lt;/code&gt; and &lt;code&gt;observer.OnCompleted&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;If you read through the code again now it probably makes more sense the second time around, there&amp;rsquo;s a lot of functionality squeezed into a small space but by using tried and tested components / functions in Rx you should have a better experience than rolling your own parts, of course you can do the same with &lt;a href=&#34;http://msdn.microsoft.com/en-us/library/hh228603.aspx&#34;&gt;TDF&lt;/a&gt; but I wont go into that here.&lt;/p&gt;

&lt;p&gt;So what would all this look like in F#?&lt;/p&gt;

&lt;p&gt;Well, if you try to do a direct port you start to hit a few issues due to the amount of overloads for some of the methods, &lt;code&gt;Zip&lt;/code&gt; for example, has a staggering 19 overloads!!   This almost always means your working right at the edge of the ability of &lt;a href=&#34;http://stackoverflow.com/a/501356/607275&#34;&gt;type inferencing&lt;/a&gt;.  In order to determine what method overload you intended to use you have to add further type parameters, this can sometimes be a tricky business as F# lambda&amp;rsquo;s are not always correctly typed back to &lt;code&gt;Action&lt;/code&gt; and &lt;code&gt;Func&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;Lets see an example of that now:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-fsharp&#34;&gt;module StreamExt =
   type Stream with
      member x.ToObservable(size) =
         Observable.Create(fun (observer: IObserver&amp;lt;_&amp;gt;) -&amp;gt;
            let buffer = Array.zeroCreate size
            let defered = Observable.Defer(fun () -&amp;gt; (x.ReadAsync (buffer, 0, size)).ToObservable())
            Observable.Repeat&amp;lt;int&amp;gt;(defered)
                      .Select(fun i -&amp;gt; buffer.Take(i).ToArray())
                      .Subscribe( (fun (data:byte[]) -&amp;gt; if data.Length &amp;gt; 0 then observer.OnNext(data)
                                                        else observer.OnCompleted()), observer.OnError, observer.OnCompleted ))
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;I had to add quite a few type annotations to get this working.  You can end up spending quite a while adding explicit types which isn&amp;rsquo;t exactly an enjoyable or productive way of spending your time, sometimes you can hit a wall and have to annotate the function separately to see where the inference is failing.&lt;/p&gt;

&lt;p&gt;To make things easier you can wrap the overloads with F# friendly versions.  In fact this has already been done in the &lt;a href=&#34;https://github.com/fsharp/FSharp.Reactive&#34;&gt;Fsharp.Reactive&lt;/a&gt; repo on GitHub.  As I&amp;rsquo;m using Mono I had to do a quick compilation against the Reactive Extensions that come bundled with Mono 3.x rather than the nuget references.  I also added in a couple of function&amp;rsquo;s that were missing from this version.   Here&amp;rsquo;s the result usin &lt;code&gt;FSharp.Reactive&lt;/code&gt;, I think you&amp;rsquo;ll agree it looks a bit better and seems to flow quite nice with the pipeline operators in place.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-fsharp&#34;&gt;module StreamExt =
   type Stream with
      member x.ToObservable(size) =
         Observable.Create (fun (observer: IObserver&amp;lt;_&amp;gt;) -&amp;gt;
            let buffer = Array.zeroCreate size
            Observable.Defer(fun () -&amp;gt; (x.ReadAsync (buffer, 0, size)).ToObservable())
            |&amp;gt; Observable.repeat
            |&amp;gt; Observable.map(fun i -&amp;gt; buffer |&amp;gt; Seq.take i |&amp;gt; Seq.toArray)
            |&amp;gt; Observable.subscribe(function
                                    | data when data.Length &amp;gt; 0 -&amp;gt; observer.OnNext(data)
                                    | _ -&amp;gt; observer.OnCompleted()) observer.OnError observer.OnCompleted)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Notable difference are the &lt;code&gt;Observable.Defer&lt;/code&gt; is piped into &lt;code&gt;repeat&lt;/code&gt;, &lt;code&gt;map&lt;/code&gt; and &lt;code&gt;subscribe&lt;/code&gt;.  Finally, the last piece that&amp;rsquo;s different is the use of the Seq expression &lt;code&gt;(fun i -&amp;gt; buffer |&amp;gt; Seq.take i |&amp;gt; Seq.toArray)&lt;/code&gt;  rather than the Linq &lt;code&gt;Take&lt;/code&gt; function &lt;code&gt;.Select (i =&amp;gt; buffer.Take(i).ToArray ())&lt;/code&gt;.  To be honest there&amp;rsquo;s not really much difference between the two, sequence expressions just seem more natural while using F#.  Lastly I switched from the if else expression to a pattern matching using the &lt;a href=&#34;http://msdn.microsoft.com/en-us/library/dd233242.aspx&#34;&gt;function&lt;/a&gt; keyword.  It&amp;rsquo;s used in pattern matching when we want to match against only one parameter that&amp;rsquo;s passed into the function.  This makes the subscribe function a little more compact.&lt;/p&gt;

&lt;p&gt;Here is the details of the functions that were used in the above snippet so that you don&amp;rsquo;t have to go looking in GitHub for details:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-fsharp&#34;&gt;module Observable =
   ///Repeats the observable
   let repeat f = Observable.Repeat(source = f)

   /// maps the given observable with the given function
   let map f source = Observable.Select(source, Func&amp;lt;_,_&amp;gt;(f))

   /// Subscribes to the observable with all three callbacks
   let subscribe onNext onError onCompleted (observable: &#39;a IObservable) =
       observable.Subscribe(Observer.Create(Action&amp;lt;_&amp;gt; onNext, Action&amp;lt;_&amp;gt; onError, Action onCompleted))
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;I think that Rx is a very useful library but it&amp;rsquo;s ironic that a functional programming oriented library is not easily usable from a functional language like F#.   There are over 400 Observable extension methods if you include all the overloads.  Its like ten thousand spoons when all you need is a knife! &amp;hellip;  Joking aside I wish the API designers had taken it easy when adding all the extension methods, when you are developing code the last thing you want to do is scroll up and down through method overloads trying to spot which exact overload you are looking for.&lt;/p&gt;

&lt;p&gt;If you want some more samples you might want to take a look at &lt;a href=&#34;http://rxwiki.wikidot.com/101samples&#34;&gt;101 Rx Samples&lt;/a&gt;.  Also for reference when building something new, make sure you check out the &lt;a href=&#34;http://go.microsoft.com/fwlink/?LinkID=205219&#34;&gt;Reactive Extensions design Guide&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;Until next time!&lt;/p&gt;

&lt;hr style=&#34;margin: 1em 0&#34;&gt;
&lt;h1 id=&#34;essential-listening&#34;&gt;Essential listening:&lt;/h1&gt;


&lt;div class=&#34;pure-g&#34;&gt;

  
  
  
  
  &lt;div class=&#34;&#34;&gt;
    &lt;div style=&#34;width: 20%; float: left;padding: 0 .2em .2em 0&#34;&gt;
        &lt;figure style=&#34;margin: 0&#34;&gt;
            &lt;img src=&#34;http://upload.wikimedia.org/wikipedia/en/f/f5/Elephantalarmclock.jpg&#34; style=&#34;margin: 0&#34;
                 alt=&#34;Buckethead- The Elephant Man&amp;#39;s Alarm Clock&#34; /&gt;
            &lt;figcaption&gt;
                &lt;h6&gt;Buckethead- The Elephant Man&amp;#39;s Alarm Clock&lt;/h4&gt;
            &lt;/figcaption&gt;
        &lt;/figure&gt;
    &lt;/div&gt;
  &lt;/div&gt;
  

  
  
  
  
  &lt;div class=&#34;&#34;&gt;
    &lt;div style=&#34;width: 20%; float: left;padding: 0 .2em .2em 0&#34;&gt;
        &lt;figure style=&#34;margin: 0&#34;&gt;
            &lt;img src=&#34;http://upload.wikimedia.org/wikipedia/en/c/c9/Linkin_park_hybrid_theory.jpg&#34; style=&#34;margin: 0&#34;
                 alt=&#34;Linkin Park - Hybrid Theory&#34; /&gt;
            &lt;figcaption&gt;
                &lt;h6&gt;Linkin Park - Hybrid Theory&lt;/h4&gt;
            &lt;/figcaption&gt;
        &lt;/figure&gt;
    &lt;/div&gt;
  &lt;/div&gt;
  

  
  
  
  
  &lt;div class=&#34;&#34;&gt;
    &lt;div style=&#34;width: 20%; float: left;padding: 0 .2em .2em 0&#34;&gt;
        &lt;figure style=&#34;margin: 0&#34;&gt;
            &lt;img src=&#34;http://upload.wikimedia.org/wikipedia/en/a/ac/Audioslave_-_Audioslave.jpg&#34; style=&#34;margin: 0&#34;
                 alt=&#34;Audioslave - Audioslave&#34; /&gt;
            &lt;figcaption&gt;
                &lt;h6&gt;Audioslave - Audioslave&lt;/h4&gt;
            &lt;/figcaption&gt;
        &lt;/figure&gt;
    &lt;/div&gt;
  &lt;/div&gt;
  

&lt;/div&gt;




</description>
    </item>
    
    <item>
      <title>I node something (Bout You)</title>
      <link>http://7sharpnine.com/2013/05/05/2013-05-05-i-node-something/</link>
      <pubDate>Sun, 05 May 2013 00:00:00 +0000</pubDate>
      
      <guid>http://7sharpnine.com/2013/05/05/2013-05-05-i-node-something/</guid>
      <description>

&lt;h1 id=&#34;what-is-edge-js&#34;&gt;What is Edge.js?&lt;/h1&gt;


&lt;figure class=&#34;img-left sixth&#34;&gt;
    
        &lt;img src=&#34;http://nodejs.org/images/logos/nodejs-dark.png&#34; /&gt;
    
    
&lt;/figure&gt;


&lt;p&gt;Unless you &lt;em&gt;live in a hole&lt;/em&gt; you have probably heard of &lt;a href=&#34;http://nodejs.org&#34;&gt;node.js&lt;/a&gt; so I&amp;rsquo;ll not bother to explain what it is or what it does.  An interesting project has come to light lately, namely &lt;a href=&#34;http://tjanczuk.github.io/edge/#/&#34;&gt;Edge.js&lt;/a&gt;.  The Edge.js project allows you to connect node.js with .Net.&lt;/p&gt;

&lt;p&gt;The creator of Edge.js Tomasz Janczuk sums this up nicely:&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;An edge connects two nodes&lt;br /&gt;
This edge connects node.js with .NET&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;Currently Edge.js is only available on Windows but there is work underway to bring this to Mono, thus opening up the possibilities even further.  &lt;!-- more --&gt;&lt;/p&gt;

&lt;p&gt;The coding model for Edge.js offers different integration options depending on the quantity of code you are writing, and whether you want to call a .Net dll directly.&lt;/p&gt;

&lt;p&gt;Here are a few examples:&lt;/p&gt;

&lt;h2 id=&#34;single-line-lambda-expressions&#34;&gt;Single line lambda expressions:&lt;/h2&gt;

&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;var edge = require(&#39;edge&#39;);
var hello = edge.func(
    &#39;async (input) =&amp;gt; { return &amp;quot;.NET welcomes &amp;quot; + input.ToString(); }&#39;
);

hello(&#39;Node.js&#39;, function (error, result) {
    if (error) throw error;
    console.log(result);
});
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;multi-line-lambda-expressions&#34;&gt;Multi line lambda expressions:&lt;/h2&gt;

&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;var hello = require(&#39;edge&#39;).func(function () {/*
    async (input) =&amp;gt; {
        return &amp;quot;.NET welcomes &amp;quot; + input.ToString(); 
    }
*/});

hello(&#39;Node.js&#39;, function (error, result) { ... });
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;file-based-expresions&#34;&gt;File based expresions:&lt;/h2&gt;

&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;var hello = require(&#39;edge&#39;).func(&#39;hello.csx&#39;);

hello(&#39;Node.js&#39;, function (error, result) { ... });
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;invoking-via-a-dll&#34;&gt;Invoking via a dll:&lt;/h2&gt;

&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;var add7 = require(&#39;edge&#39;).func(&#39;My.Sample.dll&#39;);

add7(12, function (error, result) { ... }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The entry point into your .NET code is a delegate normalized to a &lt;code&gt;Func&amp;lt;object,Task&amp;lt;object&amp;gt;&amp;gt;&lt;/code&gt;. This allows node.js code to call the .NET code asynchronously and avoid blocking the node.js event loop.  If you think about the possibilities of this for a moment, a lot of different options begin to open up with this framework.  I can foresee a lot of interesting things appearing in the future.&lt;/p&gt;

&lt;p&gt;There are currently two .Net compilers part of Edge.js.  A C# based compiler and an &lt;a href=&#34;http://ironpython.net&#34;&gt;IronPython&lt;/a&gt; one.  You can probably guess what I&amp;rsquo;m going say next&amp;hellip;&lt;/p&gt;

&lt;h1 id=&#34;introducing-edge-fs-an-f-complier-for-edge-js&#34;&gt;Introducing Edge-fs - An F# complier for edge.js&lt;/h1&gt;

&lt;p&gt;First let&amp;rsquo;s look at the interop model for Edge.js:&lt;br /&gt;

&lt;figure class=&#34;6u&#34;&gt;
    &lt;a href=&#34;http://tjanczuk.github.io/edge/#/4&#34;&gt;
        &lt;img src=&#34;https://f.cloud.github.com/assets/822369/234085/b305625c-8768-11e2-8de0-e03ae98e7249.PNG&#34; /&gt;
    &lt;/a&gt;
    
&lt;/figure&gt;
&lt;/p&gt;

&lt;p&gt;In summary, if we want to integrate with Edge.js then we must coerce whatever input that is passed to a single delegate function &lt;code&gt;Func&amp;lt;Object, Task&amp;lt;Object&amp;gt;&amp;gt;&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;In terms of the C# Edge compiler a lambda expression is passed in the &lt;a href=&#34;http://msdn.microsoft.com/en-us/library/vstudio/hh191443.aspx&#34;&gt;async await&lt;/a&gt; style:-&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-csharp&#34;&gt;async (input) =&amp;gt; { return &amp;quot;.NET welcomes &amp;quot; + input.ToString(); }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The Python Edge compiler is passed a lambda in it&amp;rsquo;s native format too:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;def hello(input):
        return &amp;quot;Python welcomes &amp;quot; + input

    lambda x: hello(x)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;So where does that leave us with F# compiler support?  Well, I suppose the most intuitive support for F# would be to use F# async workflow support.  This would mean the that lambda expression would look like this:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-fsharp&#34;&gt;fun input -&amp;gt; async{return &amp;quot;.NET welcomes &amp;quot; + input.ToString()}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;You can see it&amp;rsquo;s not that different from C#&amp;rsquo;s&amp;rsquo; async await style syntax, you can really see the F# async workflow heritage here.&lt;/p&gt;

&lt;h2 id=&#34;script-example&#34;&gt;Script Example&lt;/h2&gt;

&lt;p&gt;Now lets look at how a script file or dll and have a look to see how this would fits:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-fsharp&#34;&gt;namespace global
type Startup() =
    let addSeven v =  v + 7
    member x.Invoke(input:obj) =
        let v = input :?&amp;gt; int
        async.Return (addSeven v :&amp;gt; obj) |&amp;gt; Async.StartAsTask
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;This is really easy too, the Async module has a StartAsTask function that perfectly fits here.&lt;/p&gt;

&lt;p&gt;By default Edge.js looks for a type in the global namespace called &lt;code&gt;Startup&lt;/code&gt; with a public method called &lt;code&gt;Invoke&lt;/code&gt;.  The invoke method takes a single parameter &lt;code&gt;input&lt;/code&gt; which is of the type &lt;code&gt;Object&lt;/code&gt;.  The return type of this method is as you might have guessed &lt;code&gt;Task&amp;lt;Object&amp;gt;&lt;/code&gt;.  You can also add parameters to the node.js to indicate the location of the assembly, type and method name using the &lt;code&gt;assemblyName&lt;/code&gt;, &lt;code&gt;typeName&lt;/code&gt; and &lt;code&gt;methodName&lt;/code&gt; parameters respectively.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;var clrMethod = edge.func({
    assemblyFile: &#39;My.Edge.Samples.dll&#39;,
    typeName: &#39;Samples.FooBar.MyType&#39;,
    methodName: &#39;MyMethod&#39;
});
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;further-documentation&#34;&gt;Further Documentation&lt;/h2&gt;

&lt;p&gt;Edge.js has some really good &lt;a href=&#34;https://github.com/tjanczuk/edge&#34;&gt;documentation&lt;/a&gt; so if your interested then you really should check it out.  I plan on supporting all of the calling conventions that the C# edge compiler has to offer.  At the moment only the in-line lambdas and the file based inputs have been tested, but I&amp;rsquo;m working on further examples, and fixes as needed.&lt;/p&gt;

&lt;h2 id=&#34;why-do-you-need-a-custom-compiler&#34;&gt;Why do you need a Custom Compiler&lt;/h2&gt;

&lt;p&gt;As an aside, with dll based inputs any .Net language would work with Edge.js, you don&amp;rsquo;t need a custom compiler.  The internals of Edge.js invoke your dll via reflection.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;Handle&amp;lt;v8::Value&amp;gt; ClrFunc::Initialize(const v8::Arguments&amp;amp; args)
{
    ...
    // reference .NET code through pre-compiled CLR assembly 
    String::Utf8Value assemblyFile(jsassemblyFile);
    String::Utf8Value nativeTypeName(options-&amp;gt;Get(String::NewSymbol(&amp;quot;typeName&amp;quot;)));
    String::Utf8Value nativeMethodName(options-&amp;gt;Get(String::NewSymbol(&amp;quot;methodName&amp;quot;)));  
    typeName = gcnew System::String(*nativeTypeName);
    methodName = gcnew System::String(*nativeMethodName);      
    assembly = Assembly::LoadFrom(gcnew System::String(*assemblyFile));
    ClrFuncReflectionWrap^ wrap = ClrFuncReflectionWrap::Create(assembly, typeName, methodName);
    result = ClrFunc::Initialize(
        gcnew System::Func&amp;lt;System::Object^,Task&amp;lt;System::Object^&amp;gt;^&amp;gt;(
            wrap, &amp;amp;ClrFuncReflectionWrap::Call));
    ...
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;A custom compiler is only required for compiling code in the form of scripts or lambda expressions.  It&amp;rsquo;s expected that this will be a common use case so it&amp;rsquo;s important to have a native F# compiler support.&lt;/p&gt;

&lt;p&gt;So there we have it, a very quick whistle stop tour of &lt;strong&gt;Edge-fs&lt;/strong&gt; the F# compiler for Edge.js.  I realise that this post only just skims the surface but I just wanted to get this out in the wild.  Ill be updating my &lt;a href=&#34;https://github.com/7sharp9/edge-fs&#34;&gt;repo&lt;/a&gt; over the next day or so, and a stable release will go out via the &lt;a href=&#34;https://npmjs.org&#34;&gt;npm package&lt;/a&gt; as soon as things stabilise.&lt;/p&gt;

&lt;p&gt;Next time we&amp;rsquo;re going to lift the lid on the F# Edge compiler and take a look at it&amp;rsquo;s guts, we&amp;rsquo;ll also go through some of the trials and tribulations I had along the way.  Ill also continue the series with some more documentation and samples too.&lt;/p&gt;

&lt;p&gt;Until next time!&lt;/p&gt;

&lt;hr style=&#34;margin: 1em 0&#34;&gt;
&lt;h1 id=&#34;essential-listening&#34;&gt;Essential listening:&lt;/h1&gt;


&lt;div class=&#34;pure-g&#34;&gt;

  
  
  
  
  &lt;div class=&#34;&#34;&gt;
    &lt;div style=&#34;width: 20%; float: left;padding: 0 .2em .2em 0&#34;&gt;
        &lt;figure style=&#34;margin: 0&#34;&gt;
            &lt;img src=&#34;http://upload.wikimedia.org/wikipedia/en/4/43/Alice_In_Chains-Facelift.jpg&#34; style=&#34;margin: 0&#34;
                 alt=&#34;Alice In Chains - Facelift&#34; /&gt;
            &lt;figcaption&gt;
                &lt;h6&gt;Alice In Chains - Facelift&lt;/h4&gt;
            &lt;/figcaption&gt;
        &lt;/figure&gt;
    &lt;/div&gt;
  &lt;/div&gt;
  

  
  
  
  
  &lt;div class=&#34;&#34;&gt;
    &lt;div style=&#34;width: 20%; float: left;padding: 0 .2em .2em 0&#34;&gt;
        &lt;figure style=&#34;margin: 0&#34;&gt;
            &lt;img src=&#34;http://upload.wikimedia.org/wikipedia/en/1/12/PanteraVulgarDisplayofPower.jpg&#34; style=&#34;margin: 0&#34;
                 alt=&#34;Pantera - Vulgar Display Of Power&#34; /&gt;
            &lt;figcaption&gt;
                &lt;h6&gt;Pantera - Vulgar Display Of Power&lt;/h4&gt;
            &lt;/figcaption&gt;
        &lt;/figure&gt;
    &lt;/div&gt;
  &lt;/div&gt;
  

&lt;/div&gt;




</description>
    </item>
    
    <item>
      <title>iOS async revisited</title>
      <link>http://7sharpnine.com/2013/04/18/2013-04-18-ios-async-revisited/</link>
      <pubDate>Thu, 18 Apr 2013 00:00:00 +0000</pubDate>
      
      <guid>http://7sharpnine.com/2013/04/18/2013-04-18-ios-async-revisited/</guid>
      <description>

&lt;p&gt;In this post weare going to look as async again, but from the perspective of F#.&lt;/p&gt;

&lt;h3 id=&#34;xamarin-evolve-2013&#34;&gt;Xamarin Evolve 2013&lt;/h3&gt;

&lt;p&gt;
&lt;figure &gt;
    
        &lt;img src=&#34;http://blog.xamarin.com/wp-content/uploads/2013/04/Screen-Shot-2013-04-03-at-11.07.21-AM.png&#34; /&gt;
    
    
&lt;/figure&gt;
&lt;br /&gt;
I have been watching the Xamarin Evolve conference this week and it was good to see Miguel announce full support for F#.  Those that follow me on twitter etc, will know that I have been doing F# for quite a while in MonoDevelop and Xamarin Studio.  The new support currently entails some new project templates so that you can easily create epic new F# Apps without having to refer to my blog.  While its sad that my content now falls into the archives its nice to get official support announced in such a grand fashion.  &lt;!-- more --&gt;&lt;/p&gt;

&lt;h3 id=&#34;f-async&#34;&gt;F# Async&lt;/h3&gt;

&lt;p&gt;Kudos to Miguel for covering some history of C#&amp;rsquo;s async feature right back down to its F# heritage too, which appeared in 2007, thanks to the work of Don Syme and the F# team.  You can read more about that on &lt;a href=&#34;http://blogs.msdn.com/b/dsyme/archive/2013/03/24/asynchronous-programming-from-f-to-python.aspx&#34;&gt;Don Syme&amp;rsquo;s blog&lt;/a&gt; or have a look at the research paper &lt;a href=&#34;http://research.microsoft.com/apps/pubs/default.aspx?id=147194&#34;&gt;here&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;So the highly anticipated async await model in C# that&amp;rsquo;s just gone beta in Xamarin addin channel?  We&amp;rsquo;ve had it for ages in F#!  In fact, I suspect you will have been able to use it for quite some time, even before I started hacking together support for F# in iOS!  Anyway, that&amp;rsquo;s enough of the smugness :-) lets get on and see what it looks like using some of the code from the previous post as a reference.&lt;/p&gt;

&lt;p&gt;Ill include the C# version first so that you can see the difference rather than having to open my last post.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-csharp&#34;&gt;// Asynchronous HTTP request
public async void HttpSample ()
{
    Application.Busy ();
    var request = WebRequest.Create (Application.WisdomUrl);

    //async await version
    try{
        var response = await request.GetResponseAsync();
        Application.Done ();
        ad.RenderRssStream(response.GetResponseStream());
    } catch {
        // Error
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;One of the advantages of the F# Async model is it&amp;rsquo;s composable nature and controllability.  The key to F# async is that its defined with F#&amp;rsquo;s &lt;a href=&#34;http://msdn.microsoft.com/en-gb/library/dd233182.aspx&#34;&gt;computation expression&lt;/a&gt; syntax:&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;Computation expressions in F# provide a convenient syntax for writing computations that can be sequenced and combined using control flow constructs and bindings.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;There are several built in workflows: &lt;a href=&#34;http://msdn.microsoft.com/en-gb/library/dd233209.aspx&#34;&gt;Sequences&lt;/a&gt;, &lt;a href=&#34;http://msdn.microsoft.com/en-gb/library/dd233250.aspx&#34;&gt;Asynchronous Workflows&lt;/a&gt;, and &lt;a href=&#34;http://msdn.microsoft.com/en-gb/library/hh225374.aspx&#34;&gt;Query Expressions&lt;/a&gt;.  Whenever you use a computation expression it is as follows:- &lt;code&gt;builder-name { expression }&lt;/code&gt;.  With that tiny bit of background, lets look at the corresponding F# async code:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-fsharp&#34;&gt;member x.HttpSample() =
    Application.Busy() 
    let request = WebRequest.Create(Application.WisdomUrl )
    
    //F# async version
    async {try let! response = request.AsyncGetResponse()
               Application.Done()
               ad(response.GetResponseStream())
           with ex -&amp;gt; () } |&amp;gt; Async.Start
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;You can see there is quite a similarity between this snippet and the C# one and you should be able to figure out what&amp;rsquo;s happening given the knowledge from the previous post.&lt;/p&gt;

&lt;p&gt;One of the first things you will notice the builder - &lt;code&gt;async { ...&lt;/code&gt;, followed by the &lt;code&gt;let!&lt;/code&gt; statement.  You can think of the &lt;code&gt;let!&lt;/code&gt; as the C# equivalent of await.  &lt;code&gt;let!&lt;/code&gt; starts the computation &lt;code&gt;request.AsyncGetResponse()&lt;/code&gt;, and then the thread is suspended until the result is available, at this point execution continues to the next statment, which in this case is &lt;code&gt;Application.Done()&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;Those of you comparing the difference will notice that in the C# version after &lt;code&gt;Application.Done();&lt;/code&gt; we call &lt;code&gt;ad.RenderRssStream(response.GetResponseStream())&lt;/code&gt; but in the F# version we simply call &lt;code&gt;ad(response.GetResponseStream())&lt;/code&gt;.  If we take a quick look at the constructors for the types that hold these methods I can show you the difference a bit better:&lt;/p&gt;

&lt;p&gt;The C# version looks like this:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-csharp&#34;&gt;public class DotNet 
{
	AppDelegate ad;

	public DotNet (AppDelegate ad)
	{
		this.ad = ad;
	}
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The F# one I can show on a single line:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-fsharp&#34;&gt;type DotNet(ad: Stream -&amp;gt; unit) =
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The main difference is that The C# version has the entire &lt;code&gt;AppDelegate&lt;/code&gt; class is passed in, whereas the F# version just takes a function with the signature &lt;code&gt;Stream -&amp;gt; unit&lt;/code&gt;.  In fact the F# version doesn&amp;rsquo;t even need to be placed inside a type like the C# version, we can use a &lt;a href=&#34;http://msdn.microsoft.com/en-gb/library/dd233221.aspx&#34;&gt;module&lt;/a&gt;, again Ill quote from MSDN:&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;In the context of the F# language, a module is a grouping of F# code, such as values, types, and function values, in an F# program. Grouping code in modules helps keep related code together and helps avoid name conflicts in your program.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h3 id=&#34;f-modules&#34;&gt;F# Modules&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&#34;language-fsharp&#34;&gt;module DotNet&#39; =
    let HttpSample(ad) =
            Application.Busy() 
            let request = WebRequest.Create(Application.WisdomUrl )
            
            //F# async version
            async {try let! response = request.AsyncGetResponse()
                       Application.Done()
                       ad(response.GetResponseStream())
                   with ex -&amp;gt; () } |&amp;gt; Async.Start
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;When we want to call this code we can open the module like you would a namespace:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-fsharp&#34;&gt;open DotNet
HttpSample(ad)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Or access it fully qualified by including the &lt;code&gt;module&lt;/code&gt; name:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-fsharp&#34;&gt;DotNet.HttpSample(ad)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;How would this code look from the context of this sample application?&lt;/p&gt;

&lt;p&gt;Here is a snipped from the AppDelegate code which makes use of this module&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-fsharp&#34;&gt;// This method is invoked when the application has loaded its UI and its ready to run
override x.FinishedLaunching (app:UIApplication, options:NSDictionary) =
    x.window.AddSubview (x.navigationController.View)
    x.button1.TouchDown.Add 
        (fun _ -&amp;gt;  if not UIApplication.SharedApplication.NetworkActivityIndicatorVisible then           
                       match x.stack.SelectedRow() with
                       | 0 -&amp;gt; DotNet.HttpSample x.RenderRssStream
                       | 1 -&amp;gt; DotNet.HttpSecureSample x.RenderStream
                       | _ -&amp;gt; (new Cocoa(x.RenderRssStream)).HttpSample() |&amp;gt; ignore )    
    TableViewSelector.Configure (x.stack, [|&amp;quot;http  - WebRequest&amp;quot;
                                            &amp;quot;https - WebRequest&amp;quot;
                                            &amp;quot;http  - NSUrlConnection&amp;quot; |] )                    
    x.window.MakeKeyAndVisible()
    true
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;There are a few departures from the C# sample code which Ill include below now:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;// This method is invoked when the application has loaded its UI and its ready to run
public override bool FinishedLaunching (UIApplication app, NSDictionary options)
{
  window.AddSubview (navigationController.View);

  button1.TouchDown += Button1TouchDown;
  TableViewSelector.Configure (this.stack, new string [] {
    &amp;quot;http  - WebRequest&amp;quot;,
    &amp;quot;https - WebRequest&amp;quot;,
    &amp;quot;http  - NSUrlConnection&amp;quot;
  });

  window.MakeKeyAndVisible ();

  return true;
}

void Button1TouchDown (object sender, EventArgs e)
{
  // Do not queue more than one request
  if (UIApplication.SharedApplication.NetworkActivityIndicatorVisible)
    return;

  switch (stack.SelectedRow ()){
  case 0:
    new DotNet (this).HttpSample ();
    break;

  case 1:
    new DotNet (this).HttpSecureSample ();
    break;

  case 2:
    new Cocoa (this).HttpSample ();
    break;
  }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Firstly we are using an lambda expression for the event handler via the Add method rather than the += handler which we use in C#.  We are also using F#&amp;rsquo;s awesome &lt;a href=&#34;http://msdn.microsoft.com/en-gb/library/dd547125.aspx&#34;&gt;pattern matching&lt;/a&gt; feature on the results of &lt;code&gt;x.stack.SelectedRow()&lt;/code&gt;.  This allows you to encode complex logic and also have the compiler assist you by catching non covered cases.&lt;/p&gt;

&lt;p&gt;I&amp;rsquo;m going to leave it there for now as I don&amp;rsquo;t want to bombard any newcomers with tons of new F# features, and I also don&amp;rsquo;t want to teach any of my regular F# followers how to suck eggs.  If anyone has a preference for more in depth comparisons to the C# version then let me know then I can tailor that into further posts on the subject.&lt;/p&gt;

&lt;p&gt;Until next time!&lt;/p&gt;

&lt;hr style=&#34;margin: 1em 0&#34;&gt;
&lt;h1 id=&#34;essential-listening&#34;&gt;Essential listening:&lt;/h1&gt;


&lt;div class=&#34;pure-g&#34;&gt;

  
  
  
  
  &lt;div class=&#34;&#34;&gt;
    &lt;div style=&#34;width: 20%; float: left;padding: 0 .2em .2em 0&#34;&gt;
        &lt;figure style=&#34;margin: 0&#34;&gt;
            &lt;img src=&#34;http://upload.wikimedia.org/wikipedia/en/b/b4/PerpetualBurn.jpg&#34; style=&#34;margin: 0&#34;
                 alt=&#34;Jason Becker - Perpetual Burn&#34; /&gt;
            &lt;figcaption&gt;
                &lt;h6&gt;Jason Becker - Perpetual Burn&lt;/h4&gt;
            &lt;/figcaption&gt;
        &lt;/figure&gt;
    &lt;/div&gt;
  &lt;/div&gt;
  

  
  
  
  
  &lt;div class=&#34;&#34;&gt;
    &lt;div style=&#34;width: 20%; float: left;padding: 0 .2em .2em 0&#34;&gt;
        &lt;figure style=&#34;margin: 0&#34;&gt;
            &lt;img src=&#34;http://upload.wikimedia.org/wikipedia/en/d/dc/Megadeth-RustInPeace.jpg&#34; style=&#34;margin: 0&#34;
                 alt=&#34;Megadeth - Rust In Peace&#34; /&gt;
            &lt;figcaption&gt;
                &lt;h6&gt;Megadeth - Rust In Peace&lt;/h4&gt;
            &lt;/figcaption&gt;
        &lt;/figure&gt;
    &lt;/div&gt;
  &lt;/div&gt;
  

  
  
  
  
  &lt;div class=&#34;&#34;&gt;
    &lt;div style=&#34;width: 20%; float: left;padding: 0 .2em .2em 0&#34;&gt;
        &lt;figure style=&#34;margin: 0&#34;&gt;
            &lt;img src=&#34;http://www.metal-archives.com/images/4/6/3/9/4639.jpg?3304&#34; style=&#34;margin: 0&#34;
                 alt=&#34;&#34; /&gt;
            &lt;figcaption&gt;
                &lt;h6&gt;&lt;/h4&gt;
            &lt;/figcaption&gt;
        &lt;/figure&gt;
    &lt;/div&gt;
  &lt;/div&gt;
  

&lt;/div&gt;




</description>
    </item>
    
    <item>
      <title>A little bit of iOS async</title>
      <link>http://7sharpnine.com/2013/04/16/2013-04-16-a-little-bit-of-ios-async/</link>
      <pubDate>Tue, 16 Apr 2013 00:00:00 +0000</pubDate>
      
      <guid>http://7sharpnine.com/2013/04/16/2013-04-16-a-little-bit-of-ios-async/</guid>
      <description>&lt;p&gt;I was going to title this post as &amp;lsquo;Now for something completely different&amp;rsquo; but felt that a little bit too &lt;a href=&#34;http://en.wiktionary.org/wiki/Pythonesque&#34;&gt;Pythonesque&lt;/a&gt;, and when I thought about it a bit it isn&amp;rsquo;t really completely just slightly different, namely C# rather than my usual F# posts.  &lt;!-- more --&gt;&lt;/p&gt;

&lt;p&gt;Right, enough of the waffling, this post is a little tour into the relatively unknown area of async on iOS.  Xamarin announced the alpha preview of async await on March 11th this year (2013).  There are a couple of blog post floating around on the net if you look around, Rodrigo Kumpera posted a small example &lt;a href=&#34;http://blog.xamarin.com/brave-new-async-mobile-world/&#34;&gt;here&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;I&amp;rsquo;m no stranger to async, I have spent a great deal of time over the years debugging and refining &lt;a href=&#34;http://msdn.microsoft.com/en-GB/library/system.iasyncresult.aspx&#34;&gt;IAsyncResult&lt;/a&gt; style procedures and found Jeffrey Richter and Joe Duffy&amp;rsquo;s books below to be an excellent reference for those interested.&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;http://www.amazon.com/gp/product/0735667454/ref=as_li_ss_il?ie=UTF8&amp;camp=1789&amp;creative=390957&amp;creativeASIN=0735667454&amp;linkCode=as2&amp;tag=blacguitandge-20&#34;&gt;&lt;img border=&#34;0&#34; src=&#34;http://ws.assoc-amazon.com/widgets/q?_encoding=UTF8&amp;ASIN=0735667454&amp;Format=_SL160_&amp;ID=AsinImage&amp;MarketPlace=US&amp;ServiceVersion=20070822&amp;WS=1&amp;tag=blacguitandge-20&#34; &gt;&lt;/a&gt;&lt;img src=&#34;http://www.assoc-amazon.com/e/ir?t=blacguitandge-20&amp;l=as2&amp;o=1&amp;a=0735667454&#34; width=&#34;1&#34; height=&#34;1&#34; border=&#34;0&#34; alt=&#34;&#34; style=&#34;border:none !important; margin:0px !important;&#34; /&gt;&lt;a href=&#34;http://www.amazon.com/gp/product/032143482X/ref=as_li_ss_il?ie=UTF8&amp;camp=1789&amp;creative=390957&amp;creativeASIN=032143482X&amp;linkCode=as2&amp;tag=blacguitandge-20&#34;&gt;&lt;img border=&#34;0&#34; src=&#34;http://ws.assoc-amazon.com/widgets/q?_encoding=UTF8&amp;ASIN=032143482X&amp;Format=_SL160_&amp;ID=AsinImage&amp;MarketPlace=US&amp;ServiceVersion=20070822&amp;WS=1&amp;tag=blacguitandge-20&#34; &gt;&lt;/a&gt;&lt;img src=&#34;http://www.assoc-amazon.com/e/ir?t=blacguitandge-20&amp;l=as2&amp;o=1&amp;a=032143482X&#34; width=&#34;1&#34; height=&#34;1&#34; border=&#34;0&#34; alt=&#34;&#34; style=&#34;border:none !important; margin:0px !important;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;If you looking for a book on TPL/parallel programming then Parallel Programming with Microsoft .NET by Stephen Toub et al. is also a good read.&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;http://www.amazon.com/gp/product/0735651590/ref=as_li_ss_il?ie=UTF8&amp;camp=1789&amp;creative=390957&amp;creativeASIN=0735651590&amp;linkCode=as2&amp;tag=blacguitandge-20&#34;&gt;&lt;img border=&#34;0&#34; src=&#34;http://ws.assoc-amazon.com/widgets/q?_encoding=UTF8&amp;ASIN=0735651590&amp;Format=_SL160_&amp;ID=AsinImage&amp;MarketPlace=US&amp;ServiceVersion=20070822&amp;WS=1&amp;tag=blacguitandge-20&#34; &gt;&lt;/a&gt;&lt;img src=&#34;http://www.assoc-amazon.com/e/ir?t=blacguitandge-20&amp;l=as2&amp;o=1&amp;a=0735651590&#34; width=&#34;1&#34; height=&#34;1&#34; border=&#34;0&#34; alt=&#34;&#34; style=&#34;border:none !important; margin:0px !important;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;Anyway, enough of the book references lets look at an iOS example of async using the &lt;a href=&#34;https://github.com/xamarin/monotouch-samples&#34;&gt;MonoTouch samples&lt;/a&gt; from Xamarin as a reference.&lt;/p&gt;

&lt;p&gt;We are going to use the &lt;a href=&#34;https://github.com/xamarin/monotouch-samples/tree/master/HttpClient&#34;&gt;HttpSample&lt;/a&gt;.  Its a relatively simple example that has several buttons which trigger an asynchronous request for data, when the data is returned it&amp;rsquo;s simply rendered onto the screen.&lt;/p&gt;

&lt;p&gt;Lets look at the first asynchronous call in the &lt;a href=&#34;https://github.com/xamarin/monotouch-samples/blob/master/HttpClient/DotNet.cs&#34;&gt;DotNet.cs&lt;/a&gt; file, the &lt;code&gt;HttpSample&lt;/code&gt;  method:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-csharp&#34;&gt;// Asynchronous HTTP request
public void HttpSample ()
{
	Application.Busy ();
	var request = WebRequest.Create (Application.WisdomUrl);
	request.BeginGetResponse (FeedDownloaded, request);
}

// Invoked when we get the stream back from the twitter feed
// We parse the RSS feed and push the data into a table.
void FeedDownloaded (IAsyncResult result)
{
	Application.Done ();
	var request = result.AsyncState as HttpWebRequest;
	
	try {
    		var response = request.EndGetResponse (result);
		    ad.RenderRssStream (response.GetResponseStream ());
	} catch {
		// Error				
	}
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;To convert this to the async await style all we have to do is use the async and await keywords (surprise surprise!), and in this instance use the new &lt;strong&gt;Async&lt;/strong&gt; suffixed methods on the &lt;code&gt;WebRequest&lt;/code&gt; class.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-csharp&#34;&gt;// Asynchronous HTTP request
public async void HttpSample ()
{
	Application.Busy ();
	var request = WebRequest.Create (Application.WisdomUrl);

	//async await version
	try{
		var response = await request.GetResponseAsync();
		Application.Done ();
	    ad.RenderRssStream(response.GetResponseStream());
	} catch {
		// Error
	}
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;As you can see the &lt;code&gt;request.BeginGetResponse&lt;/code&gt; method has been changed to &lt;code&gt;await request.GetResponseAsync()&lt;/code&gt; and the callback method &lt;code&gt;FeedDownloaded&lt;/code&gt; which was passed into the &lt;code&gt;BeginGetRespose&lt;/code&gt; method has now been assimilated into the &lt;code&gt;HttpSample&lt;/code&gt; method.  The await keyword is acting as a wait point or suspension while the asynchronous method completes.  As soon the asynchronous call completes then processing continues to the line below, much in the same way that the callback code is executed in the IAsyncResult version.  For an in depth description then you can take a look at the &lt;a href=&#34;http://msdn.microsoft.com/en-gb/library/vstudio/hh191443.aspx&#34;&gt;MSDN documentation&lt;/a&gt; on the subject.&lt;/p&gt;

&lt;p&gt;You could add a WebException to the catch block here, you would expect on situations like network outage which would result in DNS lookup failures from the async call.&lt;/p&gt;

&lt;p&gt;We can look at the next asynchronous method too the &amp;lsquo;HttpSecureSample&amp;rsquo; method&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-csharp&#34;&gt;// Asynchornous HTTPS request
public void HttpSecureSample ()
{
	var https = (HttpWebRequest) WebRequest.Create (&amp;quot;https://gmail.com&amp;quot;);

	// To not depend on the root certficates, we will accept any certificates:
	ServicePointManager.ServerCertificateValidationCallback = (sender, cert, chain, ssl) =&amp;gt;  true;

	https.BeginGetResponse (GmailDownloaded, https);
}

// This sample just gets the result from calling https://gmail.com, an HTTPS secure 
// connection, we do not attempt to parse the output, but merely dump it as text
void GmailDownloaded (IAsyncResult result)
{
	Application.Done ();
	var request = result.AsyncState as HttpWebRequest;

	try {
    		var response = request.EndGetResponse (result);
		    ad.RenderStream (response.GetResponseStream ());
	} catch {
		// Error
	}
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Lets have a look at the async await version of that:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-csharp&#34;&gt;// Asynchornous HTTPS request
public async void HttpSecureSample ()
{
	var https = (HttpWebRequest) WebRequest.Create (&amp;quot;https://gmail.com&amp;quot;);

	// To not depend on the root certficates, we will accept any certificates:
	ServicePointManager.ServerCertificateValidationCallback = (sender, cert, chain, ssl) =&amp;gt;  true;

    try {
			var response = await https.GetResponseAsync();
			Application.Done ();
			ad.RenderRssStream (response.GetResponseStream ());
	} catch {
		// Error
	}
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;In this situation there was also a version of the IAsyncResult Begin/End pattern that had been converted to async - &lt;code&gt;https.GetResponseAsync()&lt;/code&gt; and we also had to add the &lt;code&gt;async&lt;/code&gt; keyword to the &lt;code&gt;HttpSecureSample&lt;/code&gt; method.&lt;/p&gt;

&lt;p&gt;For the situations where there is no &lt;strong&gt;Async&lt;/strong&gt; suffixed method available you can build your own using the &lt;a href=&#34;http://msdn.microsoft.com/en-us/library/system.threading.tasks.taskfactory.fromasync.aspx&#34;&gt;Task.Factory.FromAsync&lt;/a&gt; methods.  I wont go into the details of that here but if anyone wants any information on that then just give me a shout and I can revisit in in a future post.&lt;/p&gt;

&lt;p&gt;Ah yes, I almost forgot, there are some common pitfalls of using async await and Tomas Petricek posted a good compilation of them the other day: &lt;a href=&#34;http://tomasp.net/blog/csharp-async-gotchas.aspx&#34;&gt;C# async gotchas&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;Until next time!&lt;/p&gt;

&lt;hr style=&#34;margin: 1em 0&#34;&gt;
&lt;h1 id=&#34;essential-listening&#34;&gt;Essential listening:&lt;/h1&gt;


&lt;div class=&#34;pure-g&#34;&gt;

  
  
  
  
  &lt;div class=&#34;&#34;&gt;
    &lt;div style=&#34;width: 20%; float: left;padding: 0 .2em .2em 0&#34;&gt;
        &lt;figure style=&#34;margin: 0&#34;&gt;
            &lt;img src=&#34;http://upload.wikimedia.org/wikipedia/en/6/69/Silence_Followed_By_a_Deafening_Roar_album.jpg&#34; style=&#34;margin: 0&#34;
                 alt=&#34;Paul Gilbert - Silence Followed By A Deafening Roar&#34; /&gt;
            &lt;figcaption&gt;
                &lt;h6&gt;Paul Gilbert - Silence Followed By A Deafening Roar&lt;/h4&gt;
            &lt;/figcaption&gt;
        &lt;/figure&gt;
    &lt;/div&gt;
  &lt;/div&gt;
  

  
  
  
  
  &lt;div class=&#34;&#34;&gt;
    &lt;div style=&#34;width: 20%; float: left;padding: 0 .2em .2em 0&#34;&gt;
        &lt;figure style=&#34;margin: 0&#34;&gt;
            &lt;img src=&#34;http://upload.wikimedia.org/wikipedia/en/0/0d/FooFighters-TheColourAndTheShape.jpg&#34; style=&#34;margin: 0&#34;
                 alt=&#34;FooFighters - The Colour And The Shape&#34; /&gt;
            &lt;figcaption&gt;
                &lt;h6&gt;FooFighters - The Colour And The Shape&lt;/h4&gt;
            &lt;/figcaption&gt;
        &lt;/figure&gt;
    &lt;/div&gt;
  &lt;/div&gt;
  

&lt;/div&gt;




</description>
    </item>
    
    <item>
      <title>Whats in your toolbox?</title>
      <link>http://7sharpnine.com/2012/08/27/2012-08-23-whats-in-your-toolbox/</link>
      <pubDate>Mon, 27 Aug 2012 00:00:00 +0000</pubDate>
      
      <guid>http://7sharpnine.com/2012/08/27/2012-08-23-whats-in-your-toolbox/</guid>
      <description>

&lt;p&gt;If I walk into my garage now and open up a toolbox, whats inside?&lt;/p&gt;

&lt;p&gt;Here&amp;rsquo;s a quick selection:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Ball-peen hammer&lt;/li&gt;
&lt;li&gt;Jointer plane&lt;/li&gt;
&lt;li&gt;&lt;sup&gt;1&lt;/sup&gt;&amp;frasl;&lt;sub&gt;2&lt;/sub&gt; inch mortise chisel&lt;/li&gt;
&lt;li&gt;Soldering iron&lt;/li&gt;
&lt;li&gt;Set square&lt;/li&gt;
&lt;li&gt;Low angle block plane&lt;/li&gt;
&lt;li&gt;Torx screw drivers&lt;/li&gt;
&lt;li&gt;Hack saw&lt;/li&gt;
&lt;li&gt;Monkey wrench&lt;/li&gt;
&lt;li&gt;Pipe cutter&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Notice it doesn&amp;rsquo;t just contain:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;A sledge hammer.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Different tools have different purposes, you wouldn&amp;rsquo;t use a hammer and try to cut down a tree, or use a chisel to hammer a nail.&lt;/p&gt;

&lt;!-- more --&gt;

&lt;h2 id=&#34;software&#34;&gt;Software&lt;/h2&gt;


&lt;figure &gt;
    
        &lt;img src=&#34;http://farm9.staticflickr.com/8287/7817531406_9d651ccc57_d.jpg%20Stanley%20Wood%20Plane&#34; /&gt;
    
    
&lt;/figure&gt;


&lt;p&gt;In the software industry we also have access to a vast array of different tools all for different purposes:  Image editors, text editors, social media clients, email clients, it&amp;rsquo;s endless!  Most of the time we pick the right tool for the job.  You wouldn&amp;rsquo;t use notepad or TextMate to edit an image file, although you could, you just wouldn&amp;rsquo;t.&lt;/p&gt;

&lt;h2 id=&#34;programming&#34;&gt;Programming&lt;/h2&gt;

&lt;p&gt;The same can be said about programming languages.  Programming languages fall into different styles, no single programming style is best suited to solve every problem.&lt;/p&gt;

&lt;p&gt;There are four main styles or paradigms:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;http://en.wikipedia.org/wiki/Imperative_programming&#34;&gt;Imperative&lt;/a&gt;  - The imperative style spells out the problem in detail, the programmer explicitly defined the exacting steps the program must follow.&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://en.wikipedia.org/wiki/Functional_programming&#34;&gt;Functional&lt;/a&gt; - Functional programming favors immutability and functional composition, the programmer thinks about the problem as sequence of stateless function evaluations.&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://en.wikipedia.org/wiki/Logical_programming&#34;&gt;Logic&lt;/a&gt; - based on the idea of using logical sentences to represent programs and to perform computations.&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://en.wikipedia.org/wiki/Object-oriented_programming&#34;&gt;Object-oriented&lt;/a&gt; - The programmer thinks about the problem as a collection of interacting objects.&lt;br /&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Some languages are said to be multi-paradigm, supposedly allowing you to use you the right tool for the job.  This only helps to a certain extent as most languages embrace a single paradigm more than others.  In addition, there are also classes of problems that cannot be easily solved simply with one of the main paradigms.  Problems such as distributed communication and fault tolerance which I will touch on later.&lt;/p&gt;

&lt;h2 id=&#34;a-bit-of-history&#34;&gt;A bit of history&lt;/h2&gt;


&lt;figure class=&#34;img-left&#34;&gt;
    
        &lt;img src=&#34;http://farm9.staticflickr.com/8432/7817529026_3168c8b8dc_d.jpg&#34; alt=&#34;Swiss Bastard File&#34; /&gt;
    
    
&lt;/figure&gt;


&lt;p&gt;Early on in my career I worked solely in C#.  For years I toiled away using ASP.Net, WinForms, ADO.Net, etc before moving into back-end server-side problems.  I always found myself solving problems which other people shied away from, like multi-threading and performance profiling, so I spent another few years heavily engaged in server-side projects.&lt;/p&gt;

&lt;p&gt;Several years ago a colleague and I were brought in to fix an existing application which had to be scaled out to support thousands of concurrently connected clients.  It was written in C# to replace an aging C++ version which had also failed to deliver.  We found ourselves rapidly rewriting most of the core application from the inside out.  We developed a solid core framework before proceeding any further.&lt;/p&gt;

&lt;p&gt;I have always found that following design principles like &lt;a href=&#34;http://en.wikipedia.org/wiki/SOLID_(object-oriented_design)&#34;&gt;SOLID&lt;/a&gt; rather than blindly following patterns results in a well rounded solution.  The design that followed had a distinct functional nature, although we didn&amp;rsquo;t know that at the time, in hindsight we had discovered functional programming for ourselves.&lt;/p&gt;

&lt;p&gt;I cant remember exactly how it happened now, but at the time I was reading about Ocaml and F#.  This is when I really started to embrace functional programming, I started to tie together the design decisions we had made during the project against the functional programming concepts I was reading about.&lt;/p&gt;

&lt;hr /&gt;

&lt;h2 id=&#34;where-am-i-now&#34;&gt;Where am I now?&lt;/h2&gt;


&lt;figure &gt;
    
        &lt;img src=&#34;http://farm8.staticflickr.com/7255/7817534648_bb65b0e5cc_c.jpg&#34; /&gt;
    
    
&lt;/figure&gt;


&lt;p&gt;Now that I have a better awareness of different styles I can more readily think through the problem at hand and tailor the solution in the right direction.   I&amp;rsquo;m now also using Clojure, Erlang, and Haskell.  Failure to at least be aware of different languages, what they are good at, and what problems they effectively solve is a big mistake in my eyes.  I try to do everything to the best of my ability, if your going to do something you might as well do it properly!&lt;/p&gt;

&lt;p&gt;Throughout my professional career various problems have came up at different times and by far the most time consuming problems are those in the realm of concurrency, scalability, and fault tolerance.  I have often found myself devoting large amounts of time to solving these issues, but there are languages which exist which deal with this at their core level - namely Erlang.  This is also something that I have been looking into recently.&lt;/p&gt;

&lt;h2 id=&#34;this-blog&#34;&gt;This blog&lt;/h2&gt;

&lt;p&gt;This blog will be about using different tools for different jobs.  It will also be a place for me to have a rant about things which are bugging me.  Don&amp;rsquo;t expect my usual pure F# output, expect posts on: Erlang, Clojure, Haskell, C#, or even, dare I say it, Javascript!  Don&amp;rsquo;t worry though, there will still be plenty of F# content too.&lt;/p&gt;

&lt;p&gt;All the photos in this post are of my own tools taken by my wife Lynsey who is a keen photographer, you can find some more examples of her work on &lt;a href=&#34;http://www.flickr.com/photos/patchoulimemories&#34;&gt;Flickr&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;Until next time&amp;hellip;&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Back to the Primitive II</title>
      <link>http://7sharpnine.com/2012/04/22/2012-04-22-back-to-the-primitive-ii/</link>
      <pubDate>Sun, 22 Apr 2012 00:00:00 +0000</pubDate>
      
      <guid>http://7sharpnine.com/2012/04/22/2012-04-22-back-to-the-primitive-ii/</guid>
      <description>

&lt;p&gt;In the last post I discussed an asynchronous version of the &lt;code&gt;ManualResetEvent&lt;/code&gt; and as promised this time we will be looking at an
 asynchronous version of the &lt;code&gt;AutoResetEvent&lt;/code&gt;.  I&amp;rsquo;m using &lt;a href=&#34;http://blogs.msdn.com/b/pfxteam/archive/2012/02/11/10266923.aspx&#34;&gt;Stephen Toubs post&lt;/a&gt;
as reference and we will be building a version that is functional in style that maps straight into asynchronous work flows without and conversion
or adaptors.&lt;/p&gt;

&lt;h3 id=&#34;what-is-an-autoresetevent&#34;&gt;What is an AutoResetEvent?&lt;/h3&gt;

&lt;p&gt;An &lt;code&gt;AutoResetEvent&lt;/code&gt; can be described as a turnstile mechanism, it lets a single waiting person through before re-latching
waiting for the next signal.  This is opposed to a &lt;code&gt;ManualResetEvent&lt;/code&gt; which functions like an ordinary gate. Calling Set opens
the gate, allowing any number of threads that are waiting to be let through. Calling Reset closes the gate.&lt;/p&gt;

&lt;h3 id=&#34;asyncautoresetevent&#34;&gt;AsyncAutoResetEvent&lt;/h3&gt;

&lt;p&gt;First of all here is the shape of the type that we will be building:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;type AsyncAutoResetEvent =
    new : ?reusethread:bool -&amp;gt; AsyncAutoResetEvent
    member Set : unit -&amp;gt; unit
    member WaitAsync : unit -&amp;gt; Async&amp;lt;bool&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Fairly simple: implied constructor, &lt;code&gt;Set&lt;/code&gt; and &lt;code&gt;WaitAsync&lt;/code&gt; members.&lt;/p&gt;

&lt;h3 id=&#34;implied-constructor&#34;&gt;Implied Constructor&lt;/h3&gt;

&lt;p&gt;Thinking about this logically we may need the following items:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;A queue mechanism to store asynchronous waiters - &lt;code&gt;let mutable awaits = Queue&amp;lt;_&amp;gt;()&lt;/code&gt;.&lt;/li&gt;
&lt;li&gt;A way of knowing if a signal has been made in the absence of any waiters - &lt;code&gt;let mutable signalled = false&lt;/code&gt;.&lt;/li&gt;
&lt;li&gt;We can also declare a short-circuit asynchronous workflow for the situation that &lt;code&gt;Set()&lt;/code&gt; is called before &lt;code&gt;WaitAsync()&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;let completed = async.Return true&lt;/code&gt;.  This will save us constructing an &lt;code&gt;AsyncResultCell&amp;lt;_&amp;gt;&lt;/code&gt; and going though the
rest of the asynchronous mechanism.&lt;br /&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Also notice that an optional parameter called &lt;code&gt;reusethread&lt;/code&gt; is defined, we use the &lt;code&gt;?&lt;/code&gt; prefix when defining it to make it
optional.  We then make use of the &lt;code&gt;defaultArg&lt;/code&gt; function to give it a default value of false if a one is not passed in.  This
will be used in the &lt;code&gt;Set&lt;/code&gt; operation to determine if the code will run on the same thread or a thread in the ThreadPool.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;open System
open System.Threading
open System.Collections.Generic
 
    type AsyncAutoResetEvent(?reusethread) =
		let mutable awaits = Queue&amp;lt;_&amp;gt;()
		let mutable signalled = false
        let completed = async.Return true
        let reuseThread = defaultArg reusethread false
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;waitasync&#34;&gt;WaitAsync()&lt;/h3&gt;

&lt;p&gt;The first step is to use  a locking construct to control access to the mutable queue &lt;code&gt;awaits&lt;/code&gt;.  Inside this lock we
check to see if &lt;code&gt;signalled&lt;/code&gt; is true and if so we reset it to false and return our pre-built &lt;code&gt;completed&lt;/code&gt; asynchronous workflow.  If
signalled is false then we create a new &lt;code&gt;AsyncResultCell&amp;lt;_&amp;gt;&lt;/code&gt; and add it to the queue then return the &lt;code&gt;AsyncResult&lt;/code&gt; to the caller.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;        member x.WaitAsync() =
            lock awaits (fun () -&amp;gt;
                if signalled then
                    signalled &amp;lt;- false
                    completed
                else
                    let are = AsyncResultCell&amp;lt;_&amp;gt;()
                    awaits.Enqueue are
                    are.AsyncResult)
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;set&#34;&gt;Set()&lt;/h3&gt;

&lt;p&gt;We first declare a function called &lt;code&gt;getWaiter()&lt;/code&gt;, we use this function to return an &lt;a href=&#34;http://msdn.microsoft.com/en-us/library/dd233245.aspx&#34;&gt;option type&lt;/a&gt;
 that is either &lt;code&gt;Some AsyncResultCell&amp;lt;bool&amp;gt;&lt;/code&gt; or &lt;code&gt;None&lt;/code&gt;.  We use the lock function to control access to the mutable queue &lt;code&gt;lock awaits&lt;/code&gt;.  Once
inside the lock we use pattern matching to capture &lt;code&gt;awaits.Count&lt;/code&gt; and &lt;code&gt;signalled&lt;/code&gt;:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;The first pattern match &lt;code&gt;(x,_)&lt;/code&gt; checks if there are any waiters (&lt;code&gt;awaits.Count &amp;gt; 0&lt;/code&gt;) and then dequeues an &lt;code&gt;AsyncResultCell&amp;lt;bool&amp;gt;&lt;/code&gt; from the
queue and returns it within an option type: &lt;code&gt;Some &amp;lt;| awaits.Dequeue()&lt;/code&gt;.&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;The second pattern match &lt;code&gt;(_,y)&lt;/code&gt; checks whether &lt;code&gt;signalled&lt;/code&gt; is set to false before setting its value to true.  This causes next &lt;code&gt;WaitAsync()&lt;/code&gt;
caller to get the short-circuited value &lt;code&gt;completed&lt;/code&gt;.  This means that an &lt;code&gt;AsyncResultCell&amp;lt;bool&amp;gt;&lt;/code&gt; does not need to be created and go though the
whole async mechanism.  We then return &lt;code&gt;None&lt;/code&gt; as there is no waiter to be notified.&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;The final pattern match &lt;code&gt;(_,_)&lt;/code&gt; is used when there are no waiting callers and &lt;code&gt;signalled&lt;/code&gt; has already being set, there is simply nothing to do in
this situation so we return &lt;code&gt;None&lt;/code&gt;.&lt;br /&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;We use the &lt;code&gt;getWaiter()&lt;/code&gt; function via pattern match.  If we have a result i.e. Some AsyncResultCell&lt;bool&gt; then we call &lt;code&gt;RegisterResult&lt;/code&gt;
passing in &lt;code&gt;AsyncOK(true)&lt;/code&gt; to indicate a completion.  Notice that we also pass in the &lt;code&gt;reuseThread&lt;/code&gt; boolean that was declared as part of the
constructor.  If &lt;code&gt;reuseThread&lt;/code&gt; is true then the notification to the waiter happens &lt;strong&gt;synchronously&lt;/strong&gt; use this with care!  Personally I would stick
with the default of false to ensure that the operation is completed via the thread pool, unless you have a performance critical reason and the
waiting code that executes is &lt;strong&gt;very fast&lt;/strong&gt;.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;		member x.Set() =
		    let getWaiter()=
		        lock awaits (fun () -&amp;gt;
		            match (awaits.Count, signalled) with
		            | (x,_) when x &amp;gt; 0 -&amp;gt; Some &amp;lt;| awaits.Dequeue()
		            | (_,y) when not y -&amp;gt; signalled &amp;lt;- true;None
		            | (_,_) -&amp;gt; None)
		    match getWaiter() with
		    | Some a -&amp;gt; a.RegisterResult(AsyncOk(true), reuseThread)
		    | None _ -&amp;gt; ()
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The reason for using the &lt;code&gt;getWaiter()&lt;/code&gt; function is to separate the locking function away from the notification, if &lt;code&gt;RegisterResult&lt;/code&gt;
was called within the lock and &lt;code&gt;reuseThread&lt;/code&gt; was true then the awaiting function would be called synchronously within the lock which
would not be a very good situation to be in.&lt;/p&gt;

&lt;p&gt;So there we have it, I could take this series further and convert the other primitives that Stephen Toub describes but there should be
enough information in these two posts to set you on your way.  If anyone would like me to complete the series then let me know.  I
may well finish them off and post them on GitHub in the future, time permitting.&lt;/p&gt;

&lt;p&gt;Thanks for tuning in, until next time&amp;hellip;&lt;/p&gt;

&lt;hr style=&#34;margin: 1em 0&#34;&gt;
&lt;h1 id=&#34;essential-listening&#34;&gt;Essential listening:&lt;/h1&gt;


&lt;div class=&#34;pure-g&#34;&gt;

  
  
  
  
  &lt;div class=&#34;&#34;&gt;
    &lt;div style=&#34;width: 20%; float: left;padding: 0 .2em .2em 0&#34;&gt;
        &lt;figure style=&#34;margin: 0&#34;&gt;
            &lt;img src=&#34;http://upload.wikimedia.org/wikipedia/en/a/a8/CowboysFromHell.jpg&#34; style=&#34;margin: 0&#34;
                 alt=&#34;Pantera - Cowboys From Hell&#34; /&gt;
            &lt;figcaption&gt;
                &lt;h6&gt;Pantera - Cowboys From Hell&lt;/h4&gt;
            &lt;/figcaption&gt;
        &lt;/figure&gt;
    &lt;/div&gt;
  &lt;/div&gt;
  

  
  
  
  
  &lt;div class=&#34;&#34;&gt;
    &lt;div style=&#34;width: 20%; float: left;padding: 0 .2em .2em 0&#34;&gt;
        &lt;figure style=&#34;margin: 0&#34;&gt;
            &lt;img src=&#34;http://upload.wikimedia.org/wikipedia/en/0/09/Cacophony_-_1988_-_Go_Off%21.jpg&#34; style=&#34;margin: 0&#34;
                 alt=&#34;Cacophony - Go Off&#34; /&gt;
            &lt;figcaption&gt;
                &lt;h6&gt;Cacophony - Go Off&lt;/h4&gt;
            &lt;/figcaption&gt;
        &lt;/figure&gt;
    &lt;/div&gt;
  &lt;/div&gt;
  

&lt;/div&gt;




</description>
    </item>
    
    <item>
      <title>Black-Scholes Taste Test</title>
      <link>http://7sharpnine.com/2012/03/11/2012-03-10-black-scholes-taste-test/</link>
      <pubDate>Sun, 11 Mar 2012 00:00:00 +0000</pubDate>
      
      <guid>http://7sharpnine.com/2012/03/11/2012-03-10-black-scholes-taste-test/</guid>
      <description>

&lt;p&gt;In this edition we are going to be doing a taste test, C# vs F#.  Oh yeah, if you quickly glanced at the title you may
have thought this was a recipe for black scones, as interesting and tasty as that may be, unfortunately its going
to be finance related.&lt;/p&gt;

&lt;p&gt;I recently presented a paper on the benefits of F#, part of this was a comparison of the famous
&lt;a href=&#34;http://en.wikipedia.org/wiki/Black-Scholes&#34;&gt;Black-Scholes&lt;/a&gt; equation in both C# and F#.  I was mainly going to be
looking at code succinctness and the inherent suitability of the language for calculation based work, but there ended
up being more to it than that.&lt;/p&gt;

&lt;p&gt;First of all I quickly set up a test rig to run 50 million iterations of the algorithm to see if there were any difference
in the processing speed.  I want expecting any major differences at this point but here&amp;rsquo;s what I got:&lt;/p&gt;

&lt;p&gt;C# results for 50 million iterations

&lt;figure &gt;
    
        &lt;img src=&#34;https://lh6.googleusercontent.com/-cEzGoE_P2cE/T1vf_SxtGfI/AAAAAAAABRE/RE4ReRLAhu8/s531/csbs.png&#34; /&gt;
    
    
&lt;/figure&gt;
&lt;/p&gt;

&lt;p&gt;F# results for 50 million iterations

&lt;figure &gt;
    
        &lt;img src=&#34;https://lh3.googleusercontent.com/-PLdltL0YiIs/T1vf_Wo2ZrI/AAAAAAAABRI/WijGdNaOnK4/s531/fsbs.png&#34; /&gt;
    
    
&lt;/figure&gt;
&lt;/p&gt;

&lt;p&gt;I think you will agree that&amp;rsquo;s quite a difference, lets have a look at the code to see what&amp;rsquo;s going on.&lt;/p&gt;

&lt;h2 id=&#34;c-implementation&#34;&gt;C# Implementation&lt;/h2&gt;

&lt;pre&gt;&lt;code&gt;public class Options
{
    public enum Style
    {
        Call,
        Put
    }

    public static double BlackScholes(Style callPut, double s, double x, double t, double r, double v)
    {
        double result = 0.0;
        var d1 = (Math.Log(s / x) + (r + v * v / 2.0) * t) / (v * Math.Sqrt(t));
        var d2 = d1 - v * Math.Sqrt(t);
        switch (callPut)
        {
            case Style.Call:
                result = s * Cnd(d1) -x * Math.Exp(-r * t) * Cnd(d2);
                break;
            case Style.Put:
                result = x * Math.Exp(-r * t) * Cnd(-d2) -s * Cnd(-d1);
                break;
        }
        return result;
    }

    private static double Cnd(double x)
    {
        const double a1 = 0.31938153;
        const double a2 = -0.356563782;
        const double a3 = 1.781477937;
        const double a4 = -1.821255978;
        const double a5 = 1.330274429;
        var l = Math.Abs(x);
        var k = 1.0 / (1.0 + 0.2316419 * l);
        var w = 1.0 - 1.0 / Math.Sqrt(2 * Math.PI) * 
            Math.Exp(-l * l / 2.0) * (a1 * k + a2 * k * k + a3 * 
                Math.Pow(k, 3) + a4 * Math.Pow(k, 4) + a5 * Math.Pow(k, 5));
        if (x &amp;lt; 0)
        {
            return 1.0 - w;
        }
        return w;
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;f-implementation&#34;&gt;F# Implementation&lt;/h2&gt;

&lt;pre&gt;&lt;code class=&#34;language-fsharp&#34;&gt;module options
open System

type Style = Call | Put
  
let cnd x =
   let a1 = 0.31938153
   let a2 = -0.356563782
   let a3 = 1.781477937
   let a4 = -1.821255978
   let a5 = 1.330274429
   let l  = abs x
   let k  = 1.0 / (1.0 + 0.2316419 * l)
   let w  = (1.0 - 1.0 / sqrt(2.0 * Math.PI) * 
                exp(-l * l / 2.0) * (a1 * k + a2 * k * k + a3 * 
                    (pown k 3) + a4 * (pown k 4) + a5 * (pown k 5)))
   if x &amp;lt; 0.0 then 1.0 - w
   else w

let blackscholes style s x t r v =
    let d1 = (log(s / x) + (r + v * v / 2.0) * t) / (v * sqrt(t))
    let d2 = d1 - v * sqrt(t)
    match style with
    | Call -&amp;gt; s * cnd(d1) -x * exp(-r * t) * cnd(d2)
    | Put -&amp;gt; x * exp(-r * t) * cnd(-d2) -s * cnd(-d1)
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;differences&#34;&gt;Differences&lt;/h2&gt;

&lt;p&gt;The most significant differences when the code is compiled comes down to a few areas.&lt;/p&gt;

&lt;h3 id=&#34;the-blackscholes-function&#34;&gt;The BlackScholes function&lt;/h3&gt;

&lt;p&gt;The first thing to note is the code size and number of local variables:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;// Code size       122 (0x7a)
.maxstack  6
.locals init ([0] float64 d1,
         [1] float64 d2)
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code&gt;// Code size       164 (0xa4)
.maxstack  4
.locals init ([0] float64 d1,
         [1] float64 d2,
         [2] float64 result,
         [3] valuetype CsBs.Options/Style CS$0$0000)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The initial arguments that are loaded in the F# implementation is done in fewer IL op codes then C#.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;IL_0001:  ldarg.1
IL_0002:  ldarg.2
IL_0003:  div
IL_0004:  call       float64 [mscorlib]System.Math::Log(float64)
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code&gt;IL_0000:  ldc.r8     0.0
IL_0009:  stloc.0
IL_000a:  ldc.r8     0.0
IL_0013:  stloc.1
IL_0014:  ldc.r8     0.0
IL_001d:  stloc.2
IL_001e:  ldarg.1
IL_001f:  ldarg.2
IL_0020:  div
IL_0021:  call       float64 [mscorlib]System.Math::Log(float64)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;You can see in the C# code is intialising the local variable to 0.0 by pushing them to the stack
&lt;code&gt;ldc.r8&lt;/code&gt; then storing them &lt;code&gt;stloc.0&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;The pattern matching in the F# code results in a call to get the style &lt;code&gt;options/Style::get_Tag()&lt;/code&gt;
and then a branch if not equal opcode &lt;code&gt;bne.un.s&lt;/code&gt; which causes a jump to &lt;code&gt;IL_005d&lt;/code&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;IL_0036:  call       instance int32 options/Style::get_Tag()```
IL_003b:  ldc.i4.1
IL_003c:  bne.un.s   IL_005d
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The C# version loads the local variable for the &lt;code&gt;Style&lt;/code&gt; &lt;code&gt;IL_0053:  stloc.3&lt;/code&gt; and then uses the switch
opcode to jump table to jump to either position &lt;code&gt;IL_0064&lt;/code&gt; or &lt;code&gt;IL_0083&lt;/code&gt;.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;IL_0053:  stloc.3
IL_0054:  ldloc.3
IL_0055:  switch     ( 
                      IL_0064,
                      IL_0083)
IL_0062:  br.s       IL_00a2
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;These are negligible, I&amp;rsquo;m mealy pointing out the differences in compilation between the two languages.&lt;br /&gt;
The F# compiler is more stringent when compiling the code.&lt;/p&gt;

&lt;h3 id=&#34;the-cnd-function&#34;&gt;The Cnd function&lt;/h3&gt;

&lt;p&gt;The Cnd function or &lt;a href=&#34;http://en.wikipedia.org/wiki/Normal_distribution&#34;&gt;cumulative normal distribution&lt;/a&gt;
is where the performance differences occur.&lt;/p&gt;

&lt;p&gt;Again at initialization you can see the C# version is larger by 41.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;// Code size       213 (0xd5)
.maxstack  8
.locals init ([0] float64 l,
         [1] float64 k,
         [2] float64 w)
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code&gt;// Code size       254 (0xfe)
.maxstack  6
.locals init ([0] float64 l,
         [1] float64 k,
         [2] float64 w)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The C# version initialises all the local variables to 0.0.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;IL_0000:  ldc.r8     0.0
IL_0009:  stloc.0
IL_000a:  ldc.r8     0.0
IL_0013:  stloc.1
IL_0014:  ldc.r8     0.0
IL_001d:  stloc.2
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Interestingly the C# compiler optimises out the call to &lt;code&gt;Math.PI * 2&lt;/code&gt; but the F# compiler doesn&amp;rsquo;t.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;IL_003a:  ldc.r8     2.
IL_0043:  ldc.r8     3.1415926535897931
IL_004c:  mul
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code&gt;IL_0057:  ldc.r8     6.2831853071795862
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;From here everything is identical until we get to the power operator section (&lt;code&gt;Math.Pow&lt;/code&gt; in the C# version and &lt;code&gt;pown&lt;/code&gt; in F#).&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;IL_0089:  ldloc.1
IL_008a:  ldc.i4.3
IL_008b:  call       float64 [FSharp.Core]Microsoft.FSharp.Core.Operators/OperatorIntrinsics::PowDouble(float64, 
                                                                                                        int32)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;In the F# code we are using the &lt;code&gt;pown&lt;/code&gt; function which calculates the power to an integer.  This is shown in the
call to &lt;code&gt;OperatorIntrinsics::PowDouble&lt;/code&gt; which uses the value in &lt;code&gt;IL_0089:  ldloc.1&lt;/code&gt; and also loads the
integer 3 with &lt;code&gt;IL_008a:  ldc.i4.3&lt;/code&gt;.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;IL_009c:  ldloc.1
IL_009d:  ldc.r8     3.
IL_00a6:  call       float64 [mscorlib]System.Math::Pow(float64,
                                                        float64)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The C# code is using the standard Math.Pow operator which operates on two float64 numbers.  The value of 3 is
implicitly converted into a &lt;code&gt;float64&lt;/code&gt; during compilation &lt;code&gt;IL_009d:  ldc.r8     3.&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;The final difference is at the end of the function.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;IL_00b8:  stloc.2
IL_00b9:  ldarg.0
IL_00ba:  ldc.r8     0.0
IL_00c3:  clt
IL_00c5:  brfalse.s  IL_00d3
IL_00c7:  ldc.r8     1.
IL_00d0:  ldloc.2
IL_00d1:  sub
IL_00d2:  ret
IL_00d3:  ldloc.2
IL_00d4:  ret
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The F# version uses the &lt;code&gt;clt&lt;/code&gt; opcode.  This pushes 1 if value one on the stack is less than value two otherwise
it pushes 0.  There is then a &lt;code&gt;brfalse.s&lt;/code&gt; which jumps to location &lt;code&gt;IL_00d3&lt;/code&gt; if the first value on the stack is
less than or equal to the second value.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;IL_00b8:  stloc.2
IL_00b9:  ldarg.0
IL_00e5:  ldc.r8     0.0
IL_00ee:  bge.un.s   IL_00fc
IL_00f0:  ldc.r8     1.
IL_00f9:  ldloc.2
IL_00fa:  sub
IL_00fb:  ret
IL_00fc:  ldloc.2
IL_00fd:  ret
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The C# version uses the &lt;code&gt;bge.un.s&lt;/code&gt; to jump to location &lt;code&gt;IL_00fc&lt;/code&gt; if the first value on the stack is greater than
the second.  This is negligible in normal runtime but it is interesting to note the difference between the two.&lt;/p&gt;

&lt;h2 id=&#34;conclusion&#34;&gt;Conclusion&lt;/h2&gt;

&lt;p&gt;Wow, there was a lot of IL to get through, I hope you stayed with me!&lt;/p&gt;

&lt;p&gt;Although the difference in some areas are negligible, every little counts.  The implicit conversion of an integer
field to a &lt;code&gt;float64&lt;/code&gt; hides the fact that we were using an optimized integer power function in F#, that&amp;rsquo;s performance
increase of 168%!  Some other side effects of implicit conversion can also lead to subtle bugs due to truncation
and overflow.  The other benefits are the compiled code uses less instructions and the source code only uses 25
lines compared to 44 in C#.&lt;/p&gt;

&lt;p&gt;Until next time!&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>From C# to F#: A Developer&#39;s Perspective</title>
      <link>http://7sharpnine.com/2011/07/16/2011-07-16-from-csharp-to-fsharp-a-developers-perspective/</link>
      <pubDate>Sat, 16 Jul 2011 00:00:00 +0000</pubDate>
      
      <guid>http://7sharpnine.com/2011/07/16/2011-07-16-from-csharp-to-fsharp-a-developers-perspective/</guid>
      <description>&lt;p&gt;I recently wrote an article for &lt;a href=&#34;http://www.developerfusion.com/&#34;&gt;Developer Fusion&lt;/a&gt; on the changes in mindset required
when moving from C# to F#.&lt;/p&gt;

&lt;p&gt;The article has proved to be more more popular than I envisaged.  I think a lot of .Net developers are interested in F# but are unsure on the path to take
when trying to accomplish this.  For me it was almost a leap of faith, I saw the potential benefits and just jumped right in.&lt;!-- more --&gt;&lt;/p&gt;

&lt;p&gt;I had to overcome numerous obstacles along the way before I become comfortable within the language.  I had question like:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;How do design patterns and principles fit in.&lt;/li&gt;
&lt;li&gt;How do I structure my applications.&lt;/li&gt;
&lt;li&gt;How can I work seamlessly with other libraries in the .Net ecosphere.&lt;br /&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;I will try and answer some of these question over the coming weeks as well as
introducing some new topics.  If anyone has any comments on the article or
suggestions on future content please leave them below, and I will try to work
them into future posts.&lt;/p&gt;

&lt;p&gt;You can find the article &lt;a href=&#34;http://bit.ly/rdPEq3&#34;&gt;here&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;Until next time&amp;hellip;&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Sockets and Bockets 1</title>
      <link>http://7sharpnine.com/2011/01/13/2011-01-13-sockets-and-bockets-1/</link>
      <pubDate>Thu, 13 Jan 2011 00:00:00 +0000</pubDate>
      
      <guid>http://7sharpnine.com/2011/01/13/2011-01-13-sockets-and-bockets-1/</guid>
      <description>

&lt;h3 id=&#34;welcome-to-part-1&#34;&gt;Welcome to part 1&lt;/h3&gt;

&lt;p&gt;A while back I read an interesting article by &lt;em&gt;Brian McNamara&lt;/em&gt; &lt;a href=&#34;http://lorgonblog.wordpress.com/2010/03/28/f-async-on-the-server-side/&#34;&gt;f-async-on-the-server-side&lt;/a&gt;
which describes C# and F# versions of a simple asynchronous
socket server, one of the driving forces behind the article was how F# can
wrap the traditional asynchronous model with &lt;a href=&#34;http://msdn.microsoft.com/en-us/library/dd233250.aspx&#34;&gt;Asynchronous Workflows&lt;/a&gt;, this
produces nice clean simple code compared to the C# version which uses lambda
expressions, the code looks quite ugly in this style!  However thats not the
end of the story, a lot of memory fragmentation can occur using the APM model
when there is a high throughput, so I thought I would see if I could take this
a step further&amp;hellip;&lt;!-- more --&gt;&lt;/p&gt;

&lt;p&gt;There are some lesser known methods that were added to the &lt;a href=&#34;http://msdn.microsoft.com/en-us/library/system.net.sockets.socket.aspx&#34;&gt;Socket&lt;/a&gt;
class in .Net 2.0 SP1: ReceiveAsync, SendAsync, ConnectAsync and DisconnectAsync.
These methods use an event driven model and &lt;strong&gt;do not&lt;/strong&gt; result in the creation
of AsyncResult objects, these are created on every asynchronous call in the
traditional Socket Begin/End methods.  Once you have thousands of clients
sending and receiving thousands of messages all of the object creation can
really have an adverse effect on performance on the garbage collected, you
will regularly see the AsyncResult objects hitting Generation 1 and 2.&lt;/p&gt;

&lt;p&gt;To use the xxxAsync methods you have pass a &lt;a href=&#34;http://msdn.microsoft.com/en-us/library/system.net.sockets.socketasynceventargs.aspx&#34;&gt;SocketAsyncEventArgs&lt;/a&gt;object which is
assigned callback method and a buffer, the callback method called
asynchronously when the operation completes and is passed the corresponding
SocketAsyncEventArgs object, this allows you query the buffer in a receive
operation.&lt;/p&gt;

&lt;p&gt;The scope of this series of articles is to initially replicate Brian&amp;rsquo;s demo
using F# and a pool of SocketAsyncEventArgs and a contiguous block of memory
to hold the data being sent and received on the Socket, this again further
reduces memory fragmentation on the send and receive buffers.&lt;/p&gt;

&lt;p&gt;I have successfully developed an enterprise server for a client using this
method, it processed thousands of simultaneous connected clients and messages,
key components in the system were the High performance sockets, a pipeline
processor and a highly efficiency means of data compaction, I will only be
including the High performance sockets in this series but the other components
will be at a later date in separate articles.  Interestingly all of the code
was originally developed in c# but had a distinctly functional style, even the
Pipeline Processing is reminiscent of functional composition using the F#
pipeline operator &lt;strong&gt;|&amp;gt;&lt;/strong&gt; although an analogue of attach and detach was used
which in itself is declarative.&lt;/p&gt;

&lt;p&gt;Although there is no code in this article there is plenty in the next!&lt;/p&gt;

&lt;p&gt;Please feel free to leave comments or add any suggestions, hope to see you
next time&amp;hellip;&lt;/p&gt;
</description>
    </item>
    
  </channel>
</rss>