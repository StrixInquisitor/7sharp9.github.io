<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Games on 7sharp9</title>
    <link>http://7sharpnine.com/tags/games/</link>
    <description>Recent content in Games on 7sharp9</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <copyright>Dave Thomas</copyright>
    <lastBuildDate>Sun, 29 Sep 2013 00:00:00 +0000</lastBuildDate>
    <atom:link href="http://7sharpnine.com/tags/games/index.xml" rel="self" type="application/rss+xml" />
    
    <item>
      <title>Adding Touch To SpriteKit</title>
      <link>http://7sharpnine.com/2013/09/29/2013-09-29-adding-touch-to-spritekit/</link>
      <pubDate>Sun, 29 Sep 2013 00:00:00 +0000</pubDate>
      
      <guid>http://7sharpnine.com/2013/09/29/2013-09-29-adding-touch-to-spritekit/</guid>
      <description>&lt;p&gt;Only a quick post this week.  Last time we looked at &lt;a href=&#34;https://developer.apple.com/library/ios/documentation/GraphicsAnimation/Conceptual/SpriteKit_PG/Introduction/Introduction.html&#34;&gt;SpriteKit&lt;/a&gt; and how to add some particle emmiters to simulate a star-field and exhaust on a spaceship, this time lets look at adding some touch based input to move the spaceship around.  &lt;!-- more --&gt;&lt;/p&gt;

&lt;p&gt;The first thing we need to do is add a type of gesture recogniser, there are various built in &lt;a href=&#34;https://developer.apple.com/library/ios/documentation/uikit/reference/UIGestureRecognizer_Class/Reference/Reference.html#//apple_ref/occ/cl/UIGestureRecognizer&#34;&gt;gestures&lt;/a&gt;:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;UITapGestureRecognizer&lt;/li&gt;
&lt;li&gt;UIPinchGestureRecognizer&lt;/li&gt;
&lt;li&gt;UIRotationGestureRecognizer&lt;/li&gt;
&lt;li&gt;UISwipeGestureRecognizer&lt;/li&gt;
&lt;li&gt;UIPanGestureRecognizer&lt;/li&gt;
&lt;li&gt;UIScreenEdgePanGestureRecognizer&lt;/li&gt;
&lt;li&gt;UILongPressGestureRecognizer&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;From the names above it&amp;rsquo;s pretty easy to get a feel for how they should be used, you can create your own subclass of &lt;code&gt;UIGestureRecognizer&lt;/code&gt; if you need a custom one.&lt;/p&gt;

&lt;p&gt;Gesture recognizers come in two types continuous and discrete.  A discrete gesture is single action like tap or double tap and results in a single action been sent.  A continuous gesture is like pan, swipe, or rotate which is interpreted as a series of messages being sent.&lt;/p&gt;

&lt;p&gt;For our purposes we are going to be using the &lt;code&gt;UIPanGestureRecognizer&lt;/code&gt; which is a continuous gesture.  What we need to do is create a function that sets up the &lt;code&gt;UIPanGestureRecognizer&lt;/code&gt; ready for us to use.  We do that by creating an instance of the &lt;code&gt;UIPanGestureRecognizer&lt;/code&gt; and add it to our view:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-fsharp&#34;&gt;let setupGestures() =
    use panRecogniser = new UIPanGestureRecognizer(x, MonoTouch.ObjCRuntime.Selector(&amp;quot;PanSelector&amp;quot;))
    x.View.AddGestureRecognizer(panRecogniser)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Here we are also using a selector, which means we can use an attribute like &lt;code&gt;[&amp;lt;Export(&amp;quot;PanSelector&amp;quot;)&amp;gt;]&lt;/code&gt; to define the function that will be used as the callback.  Lets define that function now:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-fsharp&#34;&gt;let OnLabelPan( sender: UIGestureRecognizer) =
    match sender with
    | :? UIPanGestureRecognizer as pan -&amp;gt;
        match pan.State with
        | UIGestureRecognizerState.Changed -&amp;gt;
            let movement = pan.TranslationInView(x.View)
            let move = SKAction.MoveBy(movement.X * 1.75f, -movement.Y * 1.75f, 0.05)
            let ship = scene.GetChildNode(&amp;quot;Ship&amp;quot;)
            ship.RunAction(move)
            pan.SetTranslation(PointF.Empty, x.View)
        | _ -&amp;gt; ()
    | _ -&amp;gt; ()
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;First of all we use pattern matching to do a type match &lt;code&gt;| :? UIPanGestureRecognizer as pan -&amp;gt;&lt;/code&gt;.  This ensures we are dealing with the &lt;code&gt;UIPanGestureRecognizer&lt;/code&gt; type.  We might of applied multiple gesture recognisers to the view like swipe and rotate and had this function deal with all of them, we can handle this nicely with the type match.&lt;/p&gt;

&lt;p&gt;We can now use a pattern match on the state of the gesture recogniser to react to just the changed event &lt;code&gt;UIGestureRecognizerState.Changed&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;As mentioned previously the pan gesture is continuous and will send a changed action whenever the finger moves on the screen, this gives us a chance to retrieve the current translation of the pan in the current view.  We do this by calling &lt;code&gt;pan.TranslationInView(x.View)&lt;/code&gt;.  We can now apply a movement to our spaceship sprite by creating an action using &lt;code&gt;SKAction.MoveBy&lt;/code&gt;.   We multiply the translation retrieved by 1.75 to allow for the initial distance the the pan gesture moves before triggering.  We also invert the Y axis so that the spaceship sprite moves in the correct Y direction.  The final parameter is the time the action runs for, we use a really small time of 0.05 (50ms).  This stops the spaceship sprite from moving like an ordinary mouse pointer, just enough inertia to make it feel smooth.&lt;/p&gt;

&lt;p&gt;To apply the action to the spaceship all we need to do is retrieve it from the scene using &lt;code&gt;scene.GetChildNode&lt;/code&gt; and call the &lt;code&gt;RunAction&lt;/code&gt; function passing in the action we just created.&lt;/p&gt;

&lt;p&gt;Finally we set the pan translation back to zero using: &lt;code&gt;pan.SetTranslation(PointF.Empty, x.View)&lt;/code&gt;, this ensures that the spaceship only moves by last changed translation action.  Failure to reset the translation would result in the spaceship having too much inertia from the previous actions making it very difficult to control.&lt;/p&gt;

&lt;p&gt;We could also use another overload of &lt;code&gt;UIPanGestureRecognizer&lt;/code&gt; which takes an &lt;code&gt;Action&amp;lt;UIPanGestureRecognizer&amp;gt;&lt;/code&gt;, we can pass this in as a lambda function:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-fsharp&#34;&gt;let setupGestures() =
    use panRecogniser = 
        new UIPanGestureRecognizer
            (fun (pan:UIPanGestureRecognizer) -&amp;gt; 
                match pan.State with
                | UIGestureRecognizerState.Changed -&amp;gt;
                    let movement = pan.TranslationInView(x.View)
                    let move = SKAction.MoveBy(movement.X * 1.75f, -movement.Y * 1.75f, 0.05)
                    let ship = scene.GetChildNode(&amp;quot;Ship&amp;quot;)
                    ship.RunAction(move)
                    pan.SetTranslation(PointF.Empty, x.View)
                | _ -&amp;gt; ())
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;I think the attribute based version is a little cleaner as you can move the callback functionality away from the definition.  To be honest I don&amp;rsquo;t mind either way, although if the lambda definition gets too big you will definitely be better off with the former.&lt;/p&gt;

&lt;p&gt;Finally we need to plug in the &lt;code&gt;setupGestures&lt;/code&gt; function, we do that by calling it at the end of &lt;code&gt;ViewDidLoad&lt;/code&gt;:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-fsharp&#34;&gt;override x.ViewDidLoad () =
    base.ViewDidLoad()
    setupScene()
    setupGestures()
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Here&amp;rsquo;s a quick YouTube video so you can see this in action:&lt;/p&gt;


&lt;div style=&#34;position: relative; padding-bottom: 56.25%; padding-top: 30px; height: 0; overflow: hidden;&#34;&gt;
  &lt;iframe src=&#34;//www.youtube.com/embed/j5JK5zWLdK0&#34; style=&#34;position: absolute; top: 0; left: 0; width: 100%; height: 100%;&#34; allowfullscreen frameborder=&#34;0&#34;&gt;&lt;/iframe&gt;
 &lt;/div&gt;


&lt;p&gt;If you want to check out the project then you can find it in my &lt;a href=&#34;https://github.com/7sharp9/SpriteKit-Fsharp-Samples&#34;&gt;GitHub repo &lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;That&amp;rsquo;s all for now, see you next time!&lt;/p&gt;

&lt;hr style=&#34;margin: 1em 0&#34;&gt;
&lt;h1 id=&#34;essential-listening&#34;&gt;Essential listening:&lt;/h1&gt;


&lt;div class=&#34;pure-g&#34;&gt;

  
  
  
  
  &lt;div class=&#34;&#34;&gt;
    &lt;div style=&#34;width: 20%; float: left;padding: 0 .2em .2em 0&#34;&gt;
        &lt;figure style=&#34;margin: 0&#34;&gt;
            &lt;img src=&#34;http://upload.wikimedia.org/wikipedia/en/e/e5/In_Utero_%28Nirvana%29_album_cover.jpg&#34; style=&#34;margin: 0&#34;
                 alt=&#34;Nirvana - In Utero&#34; /&gt;
            &lt;figcaption&gt;
                &lt;h6&gt;Nirvana - In Utero&lt;/h4&gt;
            &lt;/figcaption&gt;
        &lt;/figure&gt;
    &lt;/div&gt;
  &lt;/div&gt;
  

  
  
  
  
  &lt;div class=&#34;&#34;&gt;
    &lt;div style=&#34;width: 20%; float: left;padding: 0 .2em .2em 0&#34;&gt;
        &lt;figure style=&#34;margin: 0&#34;&gt;
            &lt;img src=&#34;http://upload.wikimedia.org/wikipedia/en/8/85/Axiscover.jpg&#34; style=&#34;margin: 0&#34;
                 alt=&#34;Jimi Hendrix Experience - Axis: Bold as Love&#34; /&gt;
            &lt;figcaption&gt;
                &lt;h6&gt;Jimi Hendrix Experience - Axis: Bold as Love&lt;/h4&gt;
            &lt;/figcaption&gt;
        &lt;/figure&gt;
    &lt;/div&gt;
  &lt;/div&gt;
  

&lt;/div&gt;




</description>
    </item>
    
    <item>
      <title>Spritekit particle fun</title>
      <link>http://7sharpnine.com/2013/09/20/2013-09-20-sprite-kit-particle-fun/</link>
      <pubDate>Fri, 20 Sep 2013 00:00:00 +0000</pubDate>
      
      <guid>http://7sharpnine.com/2013/09/20/2013-09-20-sprite-kit-particle-fun/</guid>
      <description>

&lt;p&gt;I have been meaning to write this post for quite a while now.  Since the first announcement of the iOS7 beta I immediately saw the list of new API&amp;rsquo;s and &lt;strong&gt;SpriteKit&lt;/strong&gt; caught my eye straight away.  I only managed to get time to briefly look over the API and saw that is wasn&amp;rsquo;t the usual trashy API with a million method overloads, internal mutation sucker punch type thing.  It seems to be very declarative and intuitive, which makes for a nice change.  &lt;!-- more --&gt;&lt;/p&gt;

&lt;p&gt;First of all lots of kudos to &lt;a href=&#34;http://xamarin.com&#34;&gt;Xamarin&lt;/a&gt; for getting Xamarin iOS 7 out so swiftly, you can read about some of the new features &lt;a href=&#34;http://blog.xamarin.com/ios-7-and-xamarin-ready-when-you-are/&#34;&gt;here&lt;/a&gt;.&lt;/p&gt;

&lt;h2 id=&#34;spritekit&#34;&gt;SpriteKit&lt;/h2&gt;

&lt;p&gt;So what is SpriteKit?&lt;/p&gt;

&lt;p&gt;SpriteKit, as you might have guessed, is a games oriented API aimed at getting you quickly up and running with 2D sprites so that you can spend more time building your games rather than mucking about with the low level stuff.  Lets have a really quick tour of what&amp;rsquo;s in there, I don&amp;rsquo;t want to spend long on this as you can read the &lt;a href=&#34;https://developer.apple.com/library/ios/documentation/GraphicsAnimation/Conceptual/SpriteKit_PG/Introduction/Introduction.html&#34;&gt;programming guide&lt;/a&gt; on the Apple site for further details.&lt;/p&gt;

&lt;h3 id=&#34;scenes&#34;&gt;Scenes&lt;/h3&gt;

&lt;p&gt;SpriteKit represents the different parts of your games with a scenes.  A scene could be the title screen or the levels in the game.  A scene is really just a just a collection of nodes which represents all of the objects currently visible.  There are several different types of node that can be used in the scene.&lt;/p&gt;

&lt;h3 id=&#34;nodes&#34;&gt;Nodes&lt;/h3&gt;

&lt;p&gt;Several different type of node are available to use, here they are:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;SKVideoNode - Allows videos to be embedded into the scene.&lt;/li&gt;
&lt;li&gt;SKCropNode - A crop node allows you to mask of different areas of the viewing area.&lt;/li&gt;
&lt;li&gt;SKEffectNode - The effects node allows its children to be rendered into a private frame buffer where &lt;a href=&#34;https://developer.apple.com/library/mac/documentation/graphicsimaging/Conceptual/CoreImaging/ci_intro/ci_intro.html&#34;&gt;Core Image&lt;/a&gt; effects can be applied before being blended back into the main scene.&lt;/li&gt;
&lt;li&gt;SKEmitterNode - Allows particles to be placed into a scene.&lt;/li&gt;
&lt;li&gt;SKLabelNode - Allows for arbitrary text to be places into the scene.&lt;/li&gt;
&lt;li&gt;SKShapeNode - Allows path based shapes to be draw in the scene.&lt;/li&gt;
&lt;li&gt;SKSpriteNode - This is your standard textured image which can be colour blended, scaled, rotated etc.&lt;/li&gt;
&lt;li&gt;SKNode - This is the base node type from which all the others are derived.&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&#34;transitions&#34;&gt;Transitions&lt;/h3&gt;

&lt;p&gt;Transitions allow you to move from one scene to another, allowing for a animated effect to be applied during the transition.&lt;/p&gt;

&lt;h3 id=&#34;actions&#34;&gt;Actions&lt;/h3&gt;

&lt;p&gt;Actions allow you to declarative apply an action to a node.  For example you could write something like this:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;SKAction *moveUp =     [SKAction moveByX:0 y:100.0 duration:1.0];
SKAction *zoom =       [SKAction scaleTo:2.0 duration:0.25];
SKAction *wait =       [SKAction waitForDuration: 0.5];
SKAction *fadeAway =   [SKAction fadeOutWithDuration:0.25];
SKAction *removeNode = [SKAction removeFromParent];
 
SKAction *sequence = [SKAction sequence:@[moveUp, zoom, wait, fadeAway, removeNode]];
[node runAction: sequence];
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;This creates a sequence of actions: moveUp, zoom, wait, fadeAway, removeNode.  The actions are reusable and stateless so they can be applied to any nodes in the scene.  If we didn&amp;rsquo;t want the actions to be applied in a sequence we could use a group, which applies the actions in parallel.&lt;/p&gt;

&lt;p&gt;Don&amp;rsquo;t worry if I&amp;rsquo;ve scared you with Objective-C there will be none of that when we get into writing a little demo in a moment.&lt;/p&gt;

&lt;h3 id=&#34;physics&#34;&gt;Physics&lt;/h3&gt;

&lt;p&gt;The physics part of SpriteKit can be really fun to play with, its fairly easy to fill a screen full of cubes and bash them about watching the gravity and collision effects.  The physics engine looks like its based on &lt;a href=&#34;http://box2d.org&#34;&gt;Box2D&lt;/a&gt; and involves adding approximate shapes for your game objects and then adding a bunch of physical properties like mass, friction, linear damping, restitution etc.&lt;/p&gt;

&lt;hr /&gt;

&lt;h3 id=&#34;first-steps&#34;&gt;First Steps&lt;/h3&gt;

&lt;p&gt;That was a really quick whistle stop tour just to give you a flavour of what&amp;rsquo;s in there.  For this post we are going to look at the &lt;code&gt;SKEmitterNode&lt;/code&gt; and see what we can do.&lt;/p&gt;

&lt;p&gt;The first thing to do is set up the skeleton, not an actual skeleton mind, just the skeleton of the demo.&lt;/p&gt;

&lt;p&gt;Create a new F# iOS Single View Application.  SpriteKit uses a subclass of &lt;code&gt;UIView&lt;/code&gt; for its rendering surface and is controlled as usual by the &lt;code&gt;UIViewController&lt;/code&gt; but we need to add a few things and make a few chnages to start using SpriteKit:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;We need to open references for &lt;code&gt;MonoTouch.SpriteKit&lt;/code&gt; and &lt;code&gt;MonoTouch.CoreGraphics&lt;/code&gt;.&lt;/li&gt;
&lt;li&gt;Add a couple of virtual overloads for &lt;code&gt;ViewDidAppear&lt;/code&gt; and &lt;code&gt;ViewDidDisappear&lt;/code&gt;.&lt;/li&gt;
&lt;li&gt;Add an instance of &lt;code&gt;SKScene&lt;/code&gt; and &lt;code&gt;SKView&lt;/code&gt;.&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;We will also add a function called &lt;code&gt;setupScene&lt;/code&gt; which will initialise the scene, this will be called from &lt;code&gt;DidViewLoad&lt;/code&gt;.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;That means something like this will do the trick for an empty scene:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-fsharp&#34;&gt;namespace SpriteKitSingleView

open System
open System.Drawing
open MonoTouch.Foundation
open MonoTouch.UIKit
open MonoTouch.SpriteKit
open MonoTouch.CoreGraphics

[&amp;lt;Register (&amp;quot;SpriteKitViewController&amp;quot;)&amp;gt;]
type SpriteKitViewController () as x=
    inherit UIViewController ()
    
    let mutable scene = Unchecked.defaultof&amp;lt;SKScene&amp;gt;
    let mutable spriteView = new SKView()
    
    let setupScene() =
        spriteView.Bounds &amp;lt;- RectangleF(0.f, 0.f, x.View.Bounds.Width * UIScreen.MainScreen.Scale, 
                                                  x.View.Bounds.Height * UIScreen.MainScreen.Scale)
        spriteView.ShowsDrawCount &amp;lt;- true
        spriteView.ShowsNodeCount &amp;lt;- true
        spriteView.ShowsFPS &amp;lt;- true
            
        x.View &amp;lt;- spriteView
        scene &amp;lt;- new SKScene (spriteView.Bounds.Size, 
                              BackgroundColor = UIColor.Blue,
                              ScaleMode = SKSceneScaleMode.AspectFit)

    override x.DidReceiveMemoryWarning () =
        base.DidReceiveMemoryWarning ()

    override x.ShouldAutorotateToInterfaceOrientation (orientation) =
        orientation &amp;lt;&amp;gt; UIInterfaceOrientation.PortraitUpsideDown
        
    override x.ViewDidLoad () =
        base.ViewDidLoad()
        setupScene()        

    override x.ViewDidAppear(animated) =
        base.ViewDidDisappear (animated)
        spriteView.PresentScene(scene)
        
    override x.ViewDidDisappear(animated) =
        base.ViewDidDisappear (animated)
        scene.RemoveAllChildren()
        scene.RemoveAllActions() 
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The main interesting bit here is &lt;code&gt;setupScene&lt;/code&gt;.  The &lt;code&gt;spriteView&lt;/code&gt; instance is created at the beginning of the &lt;code&gt;SpriteKitViewController&#39;s&lt;/code&gt; &lt;a href=&#34;http://msdn.microsoft.com/en-us/library/dd233192.aspx&#34;&gt;implicit constructor&lt;/a&gt;.  We need to defer creating the &lt;code&gt;scene&lt;/code&gt; until later because in the constructor the &lt;code&gt;UIView&lt;/code&gt; has not yet been initialised by the the framework and we would get a null reference exception.&lt;/p&gt;

&lt;p&gt;The first thing we do is get the dimensions of the current view, multiply it by the current scale, then apply it to the &lt;code&gt;spriteView&lt;/code&gt; &lt;code&gt;Bounds&lt;/code&gt; property.  The scale property is used for the various DPI modes in iOS devices.  Next we add a few debug outputs to the &lt;code&gt;spriteView&lt;/code&gt; to show the current draw and node counts as well at the current frame rate.  We assign the &lt;code&gt;spriteView&lt;/code&gt; to the &lt;code&gt;View&lt;/code&gt; property of the &lt;code&gt;ViewController&lt;/code&gt;.  And finally we create a new &lt;code&gt;SKScene&lt;/code&gt;, assigning the view boundary, background colour and the scaling mode.&lt;/p&gt;

&lt;p&gt;As a side note we could create a storyboard and use an &lt;code&gt;SKView&lt;/code&gt; as the custom class instead of the default &lt;code&gt;UIView&lt;/code&gt;, doing this way means that when the &lt;code&gt;ViewDidLoad&lt;/code&gt; overload is called the &lt;code&gt;View&lt;/code&gt; property of the &lt;code&gt;SpriteKitViewControl&lt;/code&gt; would already be initialized with a &lt;code&gt;SKView&lt;/code&gt;.  This is a little more tricky in F# as we don&amp;rsquo;t currently have the fancy UI designer integration in Xamarin Studio.  You would have to do this in Xcode and copy it to your project manually.&lt;/p&gt;

&lt;h3 id=&#34;adding-the-sprite&#34;&gt;Adding the Sprite&lt;/h3&gt;

&lt;p&gt;Next we will add a spaceship sprite:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;We need to add a &lt;code&gt;.png&lt;/code&gt; file to the project.&lt;/li&gt;
&lt;li&gt;Create an instance of an &lt;code&gt;SKSprite&lt;/code&gt;.&lt;/li&gt;
&lt;li&gt;We also need to add the sprite to the scene.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Add a spaceship texture to the project and make sure that the build action is set to &lt;code&gt;BundleResource&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;Next add the following to code to the &lt;code&gt;setupScene&lt;/code&gt; function:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-fsharp&#34;&gt;use sprite = new SKSpriteNode (&amp;quot;Art/viper_mark_vii.png&amp;quot;)
sprite.Position &amp;lt;- PointF (scene.Frame.GetMidX(), scene.Frame.GetMidY())
sprite.Name &amp;lt;- &amp;quot;Ship&amp;quot;
scene.AddChild(sprite)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;I added my sprite to a sub folder in the project called Art, once you start adding lots of graphics assets you probably want to make sure they are properly organised.  Next I set the spaceship&amp;rsquo;s initial position to the center of the current scene using the &lt;code&gt;scene.Frame.GetMidX()&lt;/code&gt; and &lt;code&gt;scene.Frame.GetMidY()&lt;/code&gt; methods.  We give the sprite node a name using the &lt;code&gt;Name&lt;/code&gt; property.  This is useful if we want to refer to the spaceship via its name in the node graph rather than using its object reference  Finally we add the sprite to the scene using &lt;code&gt;scene.AddChild(sprite)&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;So this now gives us a single spaceship sitting in the middle of the screen:&lt;/p&gt;


&lt;figure &gt;
    
        &lt;img src=&#34;https://lh4.googleusercontent.com/-P_PyM1pMkNE/Uj22UP6XaOI/AAAAAAAABs4/QhrH1JVRbSA/w592-h1236-no/scene&amp;#43;with&amp;#43;spaceship.png&#34; /&gt;
    
    
&lt;/figure&gt;


&lt;h3 id=&#34;creating-particles-with-xcode-s-particle-designer&#34;&gt;Creating Particles with xCode&amp;rsquo;s Particle Designer&lt;/h3&gt;

&lt;p&gt;The great thing about SpriteKit is it also comes with a nice particle designer.  To use the particle designer you have to fire up Xcode and add a new file of type &lt;code&gt;SpriteKit Particle Designer&lt;/code&gt;.  You get a choice of a eight different preset&amp;rsquo;s particle types:  Bokeh, Fire, Fireflies, Magic, Rain, Smoke, Snow, and Spark.&lt;/p&gt;

&lt;p&gt;It certainly saves a lot of time developing the particle effects with the particle designer, there are loads of parameters to play around with.  If I quickly choose the rain preset and fiddle with the parameters a bit you get a star-field type effect like this:&lt;/p&gt;


&lt;figure &gt;
    
        &lt;img src=&#34;https://lh4.googleusercontent.com/-8vyHp_i429s/Uj3B9SeUU9I/AAAAAAAABtk/GVOuegVGVlw/w1370-h1114-no/starfield.png&#34; /&gt;
    
    
&lt;/figure&gt;


&lt;p&gt;While we&amp;rsquo;re here lets also create an exhaust plume for our spaceship, create another particle, this time using the spark preset and tweak it so it look a bit like this:&lt;/p&gt;


&lt;figure &gt;
    
        &lt;img src=&#34;https://lh3.googleusercontent.com/-3F9wo4u_uUI/Uj3B9XopZeI/AAAAAAAABtg/eIDF-kRuynQ/w1370-h1114-no/exhaust.png&#34; /&gt;
    
    
&lt;/figure&gt;


&lt;h3 id=&#34;adding-the-particles&#34;&gt;Adding The Particles&lt;/h3&gt;

&lt;p&gt;We now have all we need to plug the particles into our demo.  Find the particles you created in Xcode and copy or move them into your project, don&amp;rsquo;t forget to make sure that the build action to &lt;code&gt;BundleResource&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;While I remember lets change the background colour to black, the blue looks a bit lurid and the exhaust trail wont look its best against a blue background.  Find where &lt;code&gt;scene&lt;/code&gt; is initialised in &lt;code&gt;setupScene&lt;/code&gt; and change it so it looks like this:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-fsharp&#34;&gt;scene &amp;lt;- new SKScene (spriteView.Bounds.Size, 
                      BackgroundColor = UIColor.Black,
                      ScaleMode = SKSceneScaleMode.AspectFit)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;If you look at the &lt;code&gt;SKEmitterNode&lt;/code&gt; constructor you might be slightly befuddled by the fact that it only takes either an &lt;code&gt;NSCoder&lt;/code&gt;, &lt;code&gt;NSObjectFlag&lt;/code&gt; or a &lt;code&gt;nativeint&lt;/code&gt;.   To help us out we create a nice little function to do the dirty work for us:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-fsharp&#34;&gt;module spritekit =
    type SKEmitterNode with
        static member fromResource res =
            let emitterpath = NSBundle.MainBundle.PathForResource (res, &amp;quot;sks&amp;quot;)
            NSKeyedUnarchiver.UnarchiveFile(emitterpath) :?&amp;gt; SKEmitterNode
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The &lt;code&gt;.sks&lt;/code&gt; files produced by Xcode are archive files so we need to get them into a format that works in our project.  First we find the full path for the resource as its embedded in our app bundle - &lt;code&gt;NSBundle.MainBundle.PathForResource (res, &amp;quot;sks&amp;quot;)&lt;/code&gt;, next we use the  &lt;code&gt;UnarchiveFile&lt;/code&gt; method from the &lt;code&gt;NSKeyedUnarchiver&lt;/code&gt; type to get an &lt;code&gt;NSObject&lt;/code&gt;.  We finally cast the &lt;code&gt;NSObject&lt;/code&gt; as an &lt;code&gt;SKEmitterNode&lt;/code&gt; before it is returned.&lt;/p&gt;

&lt;p&gt;The function shown above is added as a static extension method to the &lt;code&gt;SKEmitterNode&lt;/code&gt;.  We could of also added this using a module or even just a simple function but at the moment we don&amp;rsquo;t have a clear view of any other extensions that we might need so we&amp;rsquo;ll just keep it tucked up in the &lt;code&gt;SKEmitterNode&lt;/code&gt; type for now.&lt;/p&gt;

&lt;p&gt;We can now use this function to load and add our star-field to our scene.  Add this piece of code before the spaceship code we added previously:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-fsharp&#34;&gt;use stars = SKEmitterNode.fromResource &amp;quot;Stars&amp;quot;
stars.Position &amp;lt;- PointF(scene.Frame.GetMidX(), scene.Frame.GetMaxY())
scene.AddChild(stars)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Its pretty simple now we have the helper function to load the star-field as a resource.  Notice we add the star-field as a child of the scene and position it at the middle X coordinate of the screen (&lt;code&gt;scene.Frame.GetMidX()&lt;/code&gt;) and the maximum Y coordinate (&lt;code&gt;scene.Frame.GetMaxY()&lt;/code&gt;).  This places the star-field centrally at the top of the screen.&lt;/p&gt;

&lt;p&gt;We can now go ahead and add our exhaust plume in the same way:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-fsharp&#34;&gt;use flame = SKEmitterNode.fromResource &amp;quot;Fire&amp;quot;
flame.Position &amp;lt;- PointF(0.f, -60.f)
sprite.AddChild(flame)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The only difference here is we position the exhaust at location X = 0.0, Y = -60.0 and add the exhaust as a child of the spaceship.  This means that the exhaust is offset -60.0 in the Y axis from the spaceships location, this is because child nodes inherit their parents coordinate system.  This makes groups of sprites easy to animate and manipulate as you don&amp;rsquo;t have to work out all the offsets.&lt;/p&gt;

&lt;p&gt;If we run our demo now it starts to look more interesting:&lt;/p&gt;


&lt;figure &gt;
    
        &lt;img src=&#34;https://lh6.googleusercontent.com/-cyiCu4dZOW4/Uj3QKqZINOI/AAAAAAAABuE/FAoU_bizdUk/w698-h1238-no/exhaust&amp;#43;and&amp;#43;starfield.png&#34; /&gt;
    
    
&lt;/figure&gt;


&lt;p&gt;That&amp;rsquo;s all for now, I hope you have enjoyed this little look at particles in SpriteKit.  If you want to download the demo project you can find it in my &lt;a href=&#34;https://github.com/7sharp9/SpriteKit-Fsharp-Samples&#34;&gt;GitHub repo&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;Until next time!&lt;/p&gt;

&lt;hr style=&#34;margin: 1em 0&#34;&gt;
&lt;h1 id=&#34;essential-listening&#34;&gt;Essential listening:&lt;/h1&gt;


&lt;div class=&#34;pure-g&#34;&gt;

  
  
  
  
  &lt;div class=&#34;&#34;&gt;
    &lt;div style=&#34;width: 20%; float: left;padding: 0 .2em .2em 0&#34;&gt;
        &lt;figure style=&#34;margin: 0&#34;&gt;
            &lt;img src=&#34;http://upload.wikimedia.org/wikipedia/en/0/05/Foo_Fighters_Wasting_Light_Album_Cover.jpg&#34; style=&#34;margin: 0&#34;
                 alt=&#34;Foo Fighters - Wasting Light&#34; /&gt;
            &lt;figcaption&gt;
                &lt;h6&gt;Foo Fighters - Wasting Light&lt;/h4&gt;
            &lt;/figcaption&gt;
        &lt;/figure&gt;
    &lt;/div&gt;
  &lt;/div&gt;
  

  
  
  
  
  &lt;div class=&#34;&#34;&gt;
    &lt;div style=&#34;width: 20%; float: left;padding: 0 .2em .2em 0&#34;&gt;
        &lt;figure style=&#34;margin: 0&#34;&gt;
            &lt;img src=&#34;http://upload.wikimedia.org/wikipedia/en/4/43/AIC_Unplugged.jpg&#34; style=&#34;margin: 0&#34;
                 alt=&#34;Alice In Chains - Unplugged&#34; /&gt;
            &lt;figcaption&gt;
                &lt;h6&gt;Alice In Chains - Unplugged&lt;/h4&gt;
            &lt;/figcaption&gt;
        &lt;/figure&gt;
    &lt;/div&gt;
  &lt;/div&gt;
  

  
  
  
  
  &lt;div class=&#34;&#34;&gt;
    &lt;div style=&#34;width: 20%; float: left;padding: 0 .2em .2em 0&#34;&gt;
        &lt;figure style=&#34;margin: 0&#34;&gt;
            &lt;img src=&#34;http://upload.wikimedia.org/wikipedia/en/2/2d/PearlJam-Ten2.jpg&#34; style=&#34;margin: 0&#34;
                 alt=&#34;Pearl Jam - Ten&#34; /&gt;
            &lt;figcaption&gt;
                &lt;h6&gt;Pearl Jam - Ten&lt;/h4&gt;
            &lt;/figcaption&gt;
        &lt;/figure&gt;
    &lt;/div&gt;
  &lt;/div&gt;
  

&lt;/div&gt;




</description>
    </item>
    
  </channel>
</rss>