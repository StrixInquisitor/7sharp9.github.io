<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Mac on 7sharp9</title>
    <link>http://7sharpnine.com/tags/mac/</link>
    <description>Recent content in Mac on 7sharp9</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <copyright>Dave Thomas</copyright>
    <lastBuildDate>Fri, 04 Jan 2013 00:00:00 +0000</lastBuildDate>
    <atom:link href="http://7sharpnine.com/tags/mac/index.xml" rel="self" type="application/rss+xml" />
    
    <item>
      <title>MonoGame subdivision and platonics</title>
      <link>http://7sharpnine.com/2013/01/04/2013-01-04-monogame-subdivision-and-platonics/</link>
      <pubDate>Fri, 04 Jan 2013 00:00:00 +0000</pubDate>
      
      <guid>http://7sharpnine.com/2013/01/04/2013-01-04-monogame-subdivision-and-platonics/</guid>
      <description>

&lt;p&gt;I&amp;rsquo;ve been on a bit of a break from my normal jovial self due to a shit storm of bad stuff happening that I wont go into here, but hopefully this years going to be awesome.  Anyway, here&amp;rsquo;s the next exciting installment in my series on MonoGame.   &lt;em&gt;(Well I find it exciting anyway :-) )&lt;/em&gt;&lt;br /&gt;
&lt;!-- more --&gt;
If you remember back to the &lt;a href=&#34;https://github.com/7sharp9/PlatonicSolids&#34;&gt;last post&lt;/a&gt; I mentioned the &lt;a href=&#34;http://en.wikipedia.org/wiki/Platonic_solid&#34;&gt;platonic solids&lt;/a&gt;, and we created and rendered the tetrahedron, lets recap on what the five solids are:&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;Tetrahedron (four faces)&lt;/li&gt;
&lt;li&gt;Cube or hexahedron (six faces)&lt;/li&gt;
&lt;li&gt;Octahedron (eight faces)&lt;/li&gt;
&lt;li&gt;Dodecahedron (twelve faces)&lt;/li&gt;
&lt;li&gt;Icosahedron (twenty faces)&lt;br /&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;We covered the tetrahedron in the &lt;a href=&#34;https://github.com/7sharp9/PlatonicSolids&#34;&gt;previous post&lt;/a&gt; and the hexahedron is pretty humdrum so I&amp;rsquo;m not going to cover that here so lets move onto the next one the octahedron.&lt;/p&gt;

&lt;h2 id=&#34;creating-the-octahedron&#34;&gt;Creating the Octahedron&lt;/h2&gt;

&lt;p&gt;Here&amp;rsquo;s a function that we will use to generate an octahedron:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-fsharp&#34;&gt;module Platonic
  let createOctahedron()=    
      let top = Vector3.Up
      let midOne =   top |&amp;gt; Vector3.transform (Matrix.CreateRotationX(toRad 90.0f) * Matrix.CreateRotationY(toRad 45.f))
      let midTwo =   top |&amp;gt; Vector3.transform (Matrix.CreateRotationX(toRad 90.0f) * Matrix.CreateRotationY(toRad 135.f))
      let midThree = top |&amp;gt; Vector3.transform (Matrix.CreateRotationX(toRad 90.0f) * Matrix.CreateRotationY(toRad 225.f))
      let midFour =  top |&amp;gt; Vector3.transform (Matrix.CreateRotationX(toRad 90.0f) * Matrix.CreateRotationY(toRad 315.f))
      let bottom =   top |&amp;gt; Vector3.transform (Matrix.CreateRotationX(toRad 180.f))
      
      [| midOne; top;  midTwo
         midTwo; top; midThree
         midThree; top; midFour
         midFour;  top; midOne 
         midOne; midTwo; bottom
         midTwo; midThree; bottom
         midThree; midFour; bottom
         midFour; midOne; bottom |]
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;You can see that the bulk of the code is centred around rotating a Y axis &lt;a href=&#34;http://en.wikipedia.org/wiki/Unit_vector&#34;&gt;unit vector&lt;/a&gt; &lt;code&gt;top&lt;/code&gt; around the X and Y axis.  All the vertices around the centre od the octahedron lie on the same plain and are simply rotated by 90 degrees in the X axis and then rotated by multiples of 90 degrees in the Y axis starting at 45 degrees (45, 135, 225, 315).  Finally the the &lt;code&gt;top&lt;/code&gt; unit vector is flipped to the bottom by rotating around 180 degrees in the X axis, this forms the bottom point.  The final step consists of combining the vertices into an array with the array syntax &lt;code&gt;[| ... |]&lt;/code&gt; specifing each triangle of the octahedron in turn.&lt;/p&gt;

&lt;p&gt;If you were looking carefully you might have noticed that the &lt;code&gt;Vector3.transform&lt;/code&gt; function is not part of the MonoGame library.  I wrapped MonoGames&amp;rsquo;s &lt;code&gt;Vector3.Transform&lt;/code&gt; function so that the &lt;code&gt;Vector3&lt;/code&gt; is the last parameter so we can use the forward pipeline operator &lt;code&gt;|&amp;gt;&lt;/code&gt;:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-fsharp&#34;&gt;module Vector3 =
    let transform (m:Matrix) v = 
        Vector3.Transform(v, m)
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;drawing-the-octahedron&#34;&gt;Drawing the Octahedron&lt;/h2&gt;

&lt;p&gt;What now?  Well, with this code we have just been working with the raw vertices, we now need to get this into a form that &lt;a href=&#34;http://monogame.codeplex.com&#34;&gt;MonoGame&lt;/a&gt; can render, namely an array of the &lt;code&gt;VertexPositionColor&lt;/code&gt; structure.  It&amp;rsquo;s a bit of a mouthful so lets alias this so we can simply refer to it as &lt;code&gt;vpc&lt;/code&gt;:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-fsharp&#34;&gt;let vpc v c = VertexPositionColor(v, c)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;To render the octahedron we can now modify the draw method of the tetrahedron code from the &lt;a href=&#34;https://github.com/7sharp9/PlatonicSolids&#34;&gt;last post&lt;/a&gt; maybe something like this should illustrate:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-fsharp&#34;&gt;override x.Draw (gameTime) =
  // Clear the backbuffer
  x.GraphicsDevice.Clear (Color.CornflowerBlue)
  for pass in basicEffect.CurrentTechnique.Passes do
      pass.Apply()
      let octahedron = 
          Platonic.createOctahedron() 
          |&amp;gt; Array.mapi (fun i -&amp;gt; Platonic.vpc (if i % 2 = 0 then Color.BlueViolet
                                                else Color.Orange) )
      x.GraphicsDevice.DrawUserPrimitives(PrimitiveType.TriangleList, octahedron, 0, octahedron.Length / 3)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Bear in mind we are not looking at optimisation at all at this stage purely visualising what we have.  We are using the &lt;code&gt;mapi&lt;/code&gt; function to alternate between defining blue violet and orange vertex colours.  At the moment because we haven&amp;rsquo;t set up any lights the octahedron would just appear as diamond chunk of colour with no shading, with these two simple vertex colours we can see the separate facets and see the 3D form.&lt;/p&gt;


&lt;figure &gt;
    
        &lt;img src=&#34;https://lh6.googleusercontent.com/-v5uELxAJljU/UOS6FEGjzYI/AAAAAAAABkY/WIxT8AYFUpY/s640/octahedron.png&#34; /&gt;
    
    
&lt;/figure&gt;


&lt;h2 id=&#34;subdivision-surfaces&#34;&gt;Subdivision Surfaces&lt;/h2&gt;

&lt;p&gt;According to &lt;a href=&#34;http://en.wikipedia.org/wiki/Subdivision_surface&#34;&gt;Wikipedia&lt;/a&gt;:&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;A subdivision surface, in the field of 3D computer graphics, is a method of representing a smooth surface via the specification of a coarser piecewise linear polygon mesh. The smooth surface can be calculated from the coarse mesh as the limit of a recursive process of subdividing each polygonal face into smaller faces that better approximate the smooth surface.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;They are also known as scalable geometry.  I&amp;rsquo;m not going to get into the realm of true sub-divisional modelling such as providing a visible control surface with editing and crease support, I just wouldn&amp;rsquo;t be able to do it justice within the scope of this introductory series.  Applications like &lt;a href=&#34;http://usa.autodesk.com/adsk/servlet/pc/index?id=13571168&amp;amp;siteID=123112&#34;&gt;Softimage&lt;/a&gt; or &lt;a href=&#34;http://usa.autodesk.com/maya/&#34;&gt;Maya&lt;/a&gt; are masters of sub-divisional modelling, you might want to check those out if you are interested in what can be done in that area.  Subdivision surfaces have been quite popular in the computer graphics industry as it allows modellers and animators to work with simple mesh surfaces with far less control points that can be rendered with super smooth detail but without the constraints of having to work with millions of points on the screen at once which can be computationally very expensive and distracting.  Nowadays that kind of processing is done by a &lt;a href=&#34;http://en.wikipedia.org/wiki/Graphics_processing_unit&#34;&gt;GPU&amp;rsquo;s&lt;/a&gt; &lt;a href=&#34;http://en.wikipedia.org/wiki/Shader#Vertex_shaders&#34;&gt;vertex shader&amp;rsquo;s&lt;/a&gt; or more recently the &lt;a href=&#34;http://en.wikipedia.org/wiki/Shader#Geometry_shaders&#34;&gt;geometry shader&amp;rsquo;s&lt;/a&gt; which can take a simple triangle as an input and produce zero or more triangles as its output.&lt;/p&gt;

&lt;p&gt;One of the properties of platonic solids is that all of the defining vertices lie on a sphere.  If we were to take each of the defining faces or triangles and recursively divide them into four smaller triangles, and project each of the containing vertices onto the sphere then eventually we would get an approximation of a sphere.  This was the basis of Charles Loop&amp;rsquo;s thesis &lt;a href=&#34;http://research.microsoft.com/~cloop/thesis.pdf&#34;&gt;Smooth Subdivision Surfaces Based on Triangles&lt;/a&gt;.  What I am going to present here will not go into that level of detail and we will not be generating any control surfaces to act on the subdivision mesh.  We could call this a poor man&amp;rsquo;s subdivision surface or sphere approximation :-).&lt;/p&gt;

&lt;p&gt;Lets create a quick and dirty function to try this out anyway:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-fsharp&#34;&gt;let rec subdivide(v1, v2, v3, depth) =
  seq{match depth with
      | 0 -&amp;gt; yield vpc Color.LightBlue (v1 |&amp;gt; Vector3.Normalize) 
             yield vpc Color.AliceBlue (v2 |&amp;gt; Vector3.Normalize) 
             yield vpc Color.SlateGray (v3 |&amp;gt; Vector3.Normalize) 
             
      | _ -&amp;gt; let u12 = ((v1 + v2) / 2.0f) |&amp;gt; Vector3.Normalize
             let u23 = ((v2 + v3) / 2.0f) |&amp;gt; Vector3.Normalize
             let u31 = ((v3 + v1) / 2.0f) |&amp;gt; Vector3.Normalize

             yield! subdivide(v1, u12, u31, depth-1)
             yield! subdivide(v2, u23, u12, depth-1)
             yield! subdivide(v3, u31, u23, depth-1)
             yield! subdivide(u12, u23, u31, depth-1) }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Here we have a recursive function that takes three vertices &lt;code&gt;v1, v2, v3&lt;/code&gt; and a depth parameter.   When the depth parameter is zero we are at our subdivision maximum and we return a normalized triangle.  Incidentally for the same lighting issues mentioned above we use three different colours for the vertices: light blue, alice blue, and slate grey.  The three vertices &lt;code&gt;u12, u23, u31&lt;/code&gt; define the points in-between the input triangle, we calculate them by adding the vertices together and dividing them by two &lt;code&gt;((v1 + v2) / 2.0f)&lt;/code&gt; then pipe-lining the result to the normalize function (&lt;code&gt;|&amp;gt; Vector3.Normalize&lt;/code&gt;).  We do this for each of the points.  The final step is the &lt;code&gt;yield!&lt;/code&gt; section which creates the next level of subdivision for each of the resulting four triangles.  Remember our input triangle is divided into four.  If fact in the previous article there are several images of this:&lt;/p&gt;

&lt;p&gt;
&lt;figure class=&#34;third&#34;&gt;
    
        &lt;img src=&#34;https://lh4.googleusercontent.com/-NpV1nz3K-kI/ULKY-KY6emI/AAAAAAAABio/565nXCNC9xY/s425/texture&amp;#43;coords.png&#34; alt=&#34;Tetrahedron-coordinates&#34; /&gt;
    
    
    &lt;figcaption&gt;
        &lt;p&gt;
        Tetrahedron-coordinates
        
            
        
        &lt;/p&gt; 
    &lt;/figcaption&gt;
    
&lt;/figure&gt;


&lt;figure class=&#34;third&#34;&gt;
    
        &lt;img src=&#34;https://lh4.googleusercontent.com/-hLyy6qGXjWc/ULKn_4p-CUI/AAAAAAAABjA/azvh8cUNrAY/s310/Tetrahedron.png&#34; alt=&#34;Tetrahedron&#34; /&gt;
    
    
    &lt;figcaption&gt;
        &lt;p&gt;
        Tetrahedron
        
            
        
        &lt;/p&gt; 
    &lt;/figcaption&gt;
    
&lt;/figure&gt;
&lt;/p&gt;

&lt;p&gt;The &lt;a href=&#34;http://en.wikipedia.org/wiki/Sierpinski_triangle&#34;&gt;Sierpinski triangle&lt;/a&gt; (&lt;em&gt;without the holes&lt;/em&gt;) is actually our subdivision method, except the we subdivide every triangle produced.&lt;/p&gt;

&lt;p&gt;To try this out lets change the &lt;code&gt;Draw&lt;/code&gt; method so that it looks like this:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-fsharp&#34;&gt;override x.Draw (gameTime) =
    x.GraphicsDevice.Clear (Color.CornflowerBlue)
    for pass in basicEffect.CurrentTechnique.Passes do
        pass.Apply()
        let subdiv = Platonic.createOctahedron() 
                     |&amp;gt; Seq.windowed 3
                     |&amp;gt; Seq.map (function 
                                 | [|a;b;c|] -&amp;gt; subdivide(a,b,c, 3)         
                                 | _ -&amp;gt; failwith &amp;quot;Unsupported array size.&amp;quot; )                 
                     |&amp;gt; Seq.concat 
                     |&amp;gt; Seq.toArray                                                                         
        x.GraphicsDevice.DrawUserPrimitives(PrimitiveType.TriangleList, subdiv, 0, subdiv.Length / 3)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Here we are using some of the functions from the sequence module to group and process the vertices.&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;First the result of &lt;code&gt;Platonic.createOctahedron()&lt;/code&gt; is grouped into triangles using &lt;code&gt;Seq.windowed 3&lt;/code&gt;.&lt;/li&gt;
&lt;li&gt;Now we map each the triangle using the using the &lt;code&gt;subdivide&lt;/code&gt; function.&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;Next we merge the sequence back together using &lt;code&gt;Seq.concat&lt;/code&gt;.&lt;/li&gt;
&lt;li&gt;Finally we convert the sequence back into an array with &lt;code&gt;Seq.toArray&lt;/code&gt;.&lt;br /&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;The image below shows the octahedron at various levels of subdivision from one through to four:

&lt;figure &gt;
    
        &lt;img src=&#34;https://lh3.googleusercontent.com/-oHWbg56xaXA/UOYSZVvgsZI/AAAAAAAABks/mCbZMz8Fy38/s739/subdivisions.png&#34; /&gt;
    
    
&lt;/figure&gt;
&lt;/p&gt;

&lt;p&gt;Well I hope you enjoyed this brief sojourn into subdivision, if you want to investigate further I recommend looking at the following papers.&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;http://www.cs.berkeley.edu/~sequin/CS284/PAPERS/CatmullClark_SDSurf.pdf&#34;&gt;Recursively generated B-spline surfaces on arbitrary topological meshes&lt;/a&gt;&lt;br /&gt;
&lt;a href=&#34;http://research.microsoft.com/~cloop/thesis.pdf&#34;&gt;Smooth Subdivision Surfaces Based on Triangles&lt;/a&gt;&lt;br /&gt;
&lt;a href=&#34;http://www.dgp.toronto.edu/people/stam/reality/Research/pdf/loop.pdf&#34;&gt;Evaluation of Loop Subdivision Surfaces&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;It&amp;rsquo;s a very interesting area and I dont think will be able to resist doing another article delving deaper later on.&lt;/p&gt;

&lt;p&gt;Until next time&amp;hellip;&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>MonoGame 3D basics</title>
      <link>http://7sharpnine.com/2012/11/25/2012-11-25-monogame-3d-basics/</link>
      <pubDate>Sun, 25 Nov 2012 00:00:00 +0000</pubDate>
      
      <guid>http://7sharpnine.com/2012/11/25/2012-11-25-monogame-3d-basics/</guid>
      <description>

&lt;p&gt;This time we are going to get into a little bit of code and produce the simplest of all 3d solids, the
tetrahedron.  I know its not the most exciting of things but we have to start somewhere.  The scope of 3D
graphics in computers is so vast that its very easy to get lost in the vast piles of research papers.&lt;!-- more --&gt;&lt;/p&gt;

&lt;p&gt;First lets do some basic setup, if you followed my last post then you will will have a project template to use, this
makes this a little easier.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;For those of you that are running on Windows and want to use Visual Studio please leave a comment if you would like
a project template for F#&lt;/strong&gt;.  The beauty of MonoGame is that it is cross platform and there is only a small amount of code
that differers between the different platforms, and that is localised to the main entry point rather than the &lt;code&gt;Game&lt;/code&gt; type.&lt;/p&gt;

&lt;p&gt;First create a new &lt;code&gt;MonoGame Mac Application project&lt;/code&gt;, you should end up with a Game1 type that looks like this:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-fsharp&#34;&gt;type MonoGame3DBasics() as x =
    inherit Game()
    let graphics = new GraphicsDeviceManager(x)
    let mutable spriteBatch = Unchecked.defaultof&amp;lt;_&amp;gt;
    let mutable logoTexture = Unchecked.defaultof&amp;lt;_&amp;gt;
    do x.Content.RootDirectory &amp;lt;- &amp;quot;Content&amp;quot;
       graphics.IsFullScreen &amp;lt;- false
 
    /// Overridden from the base Game.Initialize. Once the GraphicsDevice is setup,
    /// we&#39;ll use the viewport to initialize some values.
    override x.Initialize() = base.Initialize()

    /// Load your graphics content.
    override x.LoadContent() =
        // Create a new SpriteBatch, which can be use to draw textures.
        spriteBatch &amp;lt;- new SpriteBatch (graphics.GraphicsDevice)
        
        // TODO: use this.Content to load your game content here eg.
        logoTexture &amp;lt;- x.Content.Load&amp;lt;_&amp;gt;(&amp;quot;logo&amp;quot;)

    /// Allows the game to run logic such as updating the world,
    /// checking for collisions, gathering input, and playing audio.
    override x.Update ( gameTime:GameTime) =
        // TODO: Add your update logic here                 
        base.Update (gameTime)

    /// This is called when the game should draw itself. 
    override x.Draw (gameTime:GameTime) =
        // Clear the backbuffer
        graphics.GraphicsDevice.Clear (Color.CornflowerBlue)

        spriteBatch.Begin()

        // draw the logo
        spriteBatch.Draw (logoTexture, Vector2 (130.f, 200.f), Color.White);
        spriteBatch.End()

        //TODO: Add your drawing code here
        base.Draw (gameTime)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;We are going to need a few extra field for this sample and we wont be using and 2d so remove the &lt;code&gt;spriteBatch&lt;/code&gt; and the
&lt;code&gt;logoTexture&lt;/code&gt; as we wont be needing those.  The following fields need to be added in their place:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-fsharp&#34;&gt;let mutable basicEffect = Unchecked.defaultof&amp;lt;_&amp;gt;
let mutable texture = Unchecked.defaultof&amp;lt;_&amp;gt;
let mutable vertexBuffer = Unchecked.defaultof&amp;lt;_&amp;gt;
let mutable view = Unchecked.defaultof&amp;lt;_&amp;gt;
let mutable world = Unchecked.defaultof&amp;lt;_&amp;gt;
let mutable projection = Unchecked.defaultof&amp;lt;_&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;What&amp;rsquo;s this!  &lt;strong&gt;mutable&lt;/strong&gt; fields! I know, but this simplifies things until I can put together a friendly functional
scaffolding around &lt;a href=&#34;http://monogame.codeplex.com&#34;&gt;MonoGame&lt;/a&gt;.  We are creating a &lt;code&gt;basicEffect&lt;/code&gt;, this is used to draw the 3D objects, its actually
just a basic shader implementation with simple lighting.  We also have &lt;code&gt;texture&lt;/code&gt; which will be used as our texture
map.  We have a &lt;code&gt;vertexBuffer&lt;/code&gt; which is used to store the vertices for out primitive.  &lt;code&gt;view&lt;/code&gt;, &lt;code&gt;world&lt;/code&gt;, and &lt;code&gt;projection&lt;/code&gt;
are our matrices which are used to look into our 3D scene.  For more information on the theory behind 3D projection have
a look &lt;a href=&#34;http://en.wikipedia.org/wiki/3D_projection&#34;&gt;here&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;Lets more to the &lt;code&gt;LoadContent&lt;/code&gt; override:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-fsharp&#34;&gt;override x.LoadContent() =
    //load texture
    texture &amp;lt;- x.Content.Load&amp;lt;Texture2D&amp;gt;(&amp;quot;Tetrahedron&amp;quot;)
    
    //world, view, projection
    world &amp;lt;- Matrix.Identity
    view &amp;lt;- Matrix.CreateLookAt(Vector3(0.f, 0.f, 10.f), Vector3.Zero, Vector3.Up)
    projection &amp;lt;- Matrix.CreatePerspectiveFieldOfView(MathHelper.PiOver4,
                                                      x.GraphicsDevice.Viewport.AspectRatio,
                                                      1.f,
                                                      1000.f)
        
    basicEffect &amp;lt;- new BasicEffect(x.GraphicsDevice,
                                   World = world,
                                   View = view,
                                   Projection = projection,
                                   Texture = texture,
                                   TextureEnabled = true)
                                     
    let tetrahedronData = generateTetrahedron 3.5f
    vertexBuffer &amp;lt;- new VertexBuffer(x.GraphicsDevice, 
                                     VertexPositionTexture.VertexDeclaration, 
                                     tetrahedronData.Length, 
                                     BufferUsage.WriteOnly)
    vertexBuffer.SetData(tetrahedronData)
    x.GraphicsDevice.SetVertexBuffer(vertexBuffer)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The first thing that we do is load the texture map:&lt;br /&gt;
&lt;code&gt;texture &amp;lt;- x.Content.Load&amp;lt;Texture2D&amp;gt;(&amp;quot;Tetrahedron&amp;quot;)&lt;/code&gt;&lt;br /&gt;
This simply loads in the texture named &lt;code&gt;Tetrahedron&lt;/code&gt; using the content loader.&lt;/p&gt;

&lt;p&gt;Next we set up the default values for the world matrix, view and projection matrices.  The &lt;code&gt;world&lt;/code&gt; is simply initialised using
&lt;code&gt;Matrix.Identity&lt;/code&gt; which is a matrix defined as:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;[1,0,0,0]
[0,1,0,0]
[0,0,1,0]
[0,0,0,1]
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The &lt;code&gt;view&lt;/code&gt; is initialised using the &lt;code&gt;CreateLookAt&lt;/code&gt; method of the Matrix type.  This sets up a transformation that points from
0,0,10 to the centre of the world using &lt;code&gt;Vector3.Zero&lt;/code&gt;.  It also uses the &lt;code&gt;Vector3.Up&lt;/code&gt; as the orientation direction &lt;em&gt;(Positive Y is up)&lt;/em&gt;.&lt;/p&gt;

&lt;p&gt;The &lt;code&gt;projection&lt;/code&gt; is also initialised using the helper method &lt;code&gt;CreatePerspectiveFieldOfView&lt;/code&gt; which as you might guess, creates
a perspective with a field of view.  In this instance our field of view uses the constant &lt;code&gt;PiOver4&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;The basic effect is now initialised with the matrices we just initialised.&lt;/p&gt;

&lt;p&gt;For now I want you to ignore the line &lt;code&gt;let tetrahedronData = generateTetrahedron 3.5f&lt;/code&gt;.  I need to explain how to generate a
tetrahedron before that will make sense, just assume that is returns the vertices that we need for the tetrahedron.&lt;/p&gt;

&lt;p&gt;The &lt;code&gt;vertexBuffer&lt;/code&gt; is now created which will hold all the vertices for the tetrahedron.  We need to tell the &lt;code&gt;vertexBuufer&lt;/code&gt;
what format we want to use to hold the vertices, here, we are going to use vertices with Position, Colour, and Texture
coordinates so we we use the predefined format of &lt;code&gt;VertexPositionTexture.VertexDeclaration&lt;/code&gt;.  There are various different
predefined formats and its also possible to create custom user defined formats, for more information have a look
&lt;a href=&#34;http://devblog.phillipspiess.com/2010/03/21/xnas-vertex-structs-and-custom-vertex-formats/&#34;&gt;here&lt;/a&gt;.  I realise I&amp;rsquo;m glossing over a lot of information, this is because the field of 3D graphics is huge even an API
such as XNA/MonoGame which tries to simplify things, there is still a vast array of different concepts and I don&amp;rsquo;t want to
get too bogged down with all the specifics.&lt;/p&gt;

&lt;p&gt;Finally the &lt;code&gt;vertexBuffer&lt;/code&gt; is assigned to the graphics device: &lt;code&gt;x.GraphicsDevice.SetVertexBuffer(vertexBuffer)&lt;/code&gt;, this
loads the vertex buffer into the graphics card ready to be draw later.&lt;/p&gt;

&lt;p&gt;Next we move on to the &lt;code&gt;Update&lt;/code&gt; override:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-fsharp&#34;&gt;        override x.Update(gameTime) = 
            if Keyboard.GetState().IsKeyDown(Keys.Escape) then x.Exit()
            
            let time = float32 gameTime.ElapsedGameTime.TotalSeconds

            // Compute camera matrices.
            let rotationz = Matrix.CreateRotationY(time * 1.2f)
            basicEffect.View &amp;lt;- rotationz * Matrix.CreateLookAt(Vector3(0.f, 0.f, 10.f), Vector3.Zero, Vector3.Up)
                    
            base.Update (gameTime)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The &lt;a href=&#34;http://msdn.microsoft.com/en-us/library/microsoft.xna.framework.game.update.aspx&#34;&gt;&lt;code&gt;Update&lt;/code&gt;&lt;/a&gt; method is called every time the game decides that game logic needs to be processed. This includes the
management of game state, the processing of user input, and also the updating of simulation data or AI.&lt;/p&gt;

&lt;p&gt;First of all we check the Escape key has been pressed so that the application can exit: &lt;code&gt;if Keyboard.GetState().IsKeyDown(Keys.Escape) then x.Exit()&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;Next we capture the amount of elapsed time since the last update so that we can calculate distance moved over time etc.&lt;/p&gt;

&lt;p&gt;To make our view of the world less static we create a rotation around the z axis of the world so that we see the tetrahedron
from different angles.   We multiply the rotation matrix by our initial &lt;code&gt;Matrix.CreateLookAt...&lt;/code&gt; that we used earlier on, and
assign it back to the &lt;code&gt;View&lt;/code&gt; property of the &lt;code&gt;basicEffect&lt;/code&gt;.   I want to stress that the aim of this is not super optimal code
it&amp;rsquo;s merely to show the easiest possible method of achieving a result.  In a future post we will be looking at some functional
scaffolding to allow us to apply functional thinking to this domain.  Perhaps introducing a small &lt;a href=&#34;http://en.wikipedia.org/wiki/Domain-specific_language&#34;&gt;Domain Specific Languagee&lt;/a&gt; to help.&lt;/p&gt;

&lt;p&gt;Finally we have the &lt;code&gt;Draw&lt;/code&gt; override:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-fsharp&#34;&gt;        /// This is called when the game should draw itself. 
        override x.Draw (gameTime) =
            // Clear the backbuffer
            x.GraphicsDevice.Clear (Color.CornflowerBlue)

            for pass in basicEffect.CurrentTechnique.Passes do
                pass.Apply()
                x.GraphicsDevice.DrawPrimitives(PrimitiveType.TriangleList, 0, 4)
                 
            base.Draw (gameTime)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The &lt;a href=&#34;http://msdn.microsoft.com/en-us/library/microsoft.xna.framework.game.draw.aspx&#34;&gt;&lt;code&gt;Draw&lt;/code&gt;&lt;/a&gt; override is called every time the game needs to draw a frame, we put all out rendering code in here.&lt;/p&gt;

&lt;p&gt;The first step is to clear the screen to a nice blue colour:&lt;/p&gt;

&lt;p&gt;&lt;code&gt;x.GraphicsDevice.Clear (Color.CornflowerBlue)&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;To draw our tetrahedron we need to loop through the different techniques in out shader (In this instance our basicEffect only has 1), apply the technique, then draw out triangles.  You might remember earlier to created a the &lt;code&gt;vertexBuffer&lt;/code&gt; and assigned it to the graphics device.  All we have to do is tell MonoGame that we want to draw 4 triangles and they are in a &lt;code&gt;TriangleList&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;That&amp;rsquo;s it all done!  Well almost, now lets backtrack slightly and look at how we build the vertices for that tetrahedron.&lt;/p&gt;

&lt;h2 id=&#34;building-a-tetrahedron&#34;&gt;Building a tetrahedron&lt;/h2&gt;

&lt;p&gt;What is a tetrahedron?  Well if you look on &lt;a href=&#34;http://en.wikipedia.org/wiki/Tetrahedron&#34;&gt;wikipedia&lt;/a&gt;&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;A tetrahedron is a polyhedron composed of four triangular faces, three of which meet at each vertex. It has six edges and four vertices. The tetrahedron is the only convex polyhedron that has four faces.
&amp;hellip;&lt;/p&gt;

&lt;p&gt;In the case of a tetrahedron the base is a triangle(any of the four faces can be considered the base), so a tetrahedron is also known as a &amp;ldquo;triangular pyramid&amp;rdquo;.
&amp;hellip;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;For any tetrahedron there exists a sphere (the circumsphere) such that the tetrahedron&amp;rsquo;s vertices lie on the sphere&amp;rsquo;s surface.&lt;/p&gt;

&lt;p&gt;The tetrahedron is also the simplest of the five &lt;a href=&#34;http://en.wikipedia.org/wiki/Platonic_solid&#34;&gt;platonic solids&lt;/a&gt;.  There are lots of interesting properties of these
but I don&amp;rsquo;t really want to go into that here we just want to draw and texture one for now.&lt;/p&gt;

&lt;p&gt;So how do we construct a tetrahedron?&lt;/p&gt;

&lt;p&gt;There are various methods that can be used to construct a tetrahedron ranging from formula such as:&lt;/p&gt;

&lt;p&gt;Cartesian coordinate based
(±1, 0, -1/sqrt2)
(0, ±1, 1/sqrt2)&lt;/p&gt;

&lt;p&gt;V0 =(0,0,1)
V1=(2sqrt2 /3, 0, −1/3)&lt;br /&gt;
V2 =(− sqrt2 /3, sqrt6 /3, −1/3)&lt;br /&gt;
V3=(− sqrt2 /3,− sqrt6 /3,−1/3)&lt;/p&gt;

&lt;p&gt;Yes I know I need to get latex maths expression working in my blog!  Ill have to work on that.&lt;/p&gt;

&lt;p&gt;I don&amp;rsquo;t know about you, but I always feel uneasy unless I can clearly see exactly what&amp;rsquo;s been done, I also don&amp;rsquo;t
want to turn this into a 3D geometry lesson because that&amp;rsquo;s not what I intend this post to be about.&lt;/p&gt;

&lt;p&gt;Here&amp;rsquo;s what works for me anyway.&lt;/p&gt;

&lt;p&gt;Calculate the radius of the circumsphere, this is the sphere in which all of the vertices of the tetrahedron sit,
this is calculated by sqrt &lt;sup&gt;3&lt;/sup&gt;&amp;frasl;&lt;sub&gt;8&lt;/sub&gt;.&lt;/p&gt;

&lt;p&gt;The angle between each vertex and its centre point is acos -&lt;sup&gt;1&lt;/sup&gt;&amp;frasl;&lt;sub&gt;3&lt;/sub&gt; or ~ 109.471 degrees.&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;The first vertex is (0, sqrt (&lt;sup&gt;3&lt;/sup&gt;&amp;frasl;&lt;sub&gt;8&lt;/sub&gt;) * length, 0)&lt;/li&gt;
&lt;li&gt;To get our second vertex we need to rotate the first vertex by acos -&lt;sup&gt;1&lt;/sup&gt;&amp;frasl;&lt;sub&gt;3&lt;/sub&gt; in the X axis&lt;/li&gt;
&lt;li&gt;To get the third vertex we rotate second vertex by 120 degrees in the Y axis&lt;/li&gt;
&lt;li&gt;For the last vertex we rotate the second vertex by -120 degrees in the Y axis&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;A picture can often be a worth a thousand words, I think this is one of those times, I will refer you to
&lt;a href=&#34;http://www.f-lohmueller.de/pov_tut/x_sam/sam_440e.htm&#34;&gt;Friedrich A. Lohmüllers site&lt;/a&gt; for an excellent pictorial and description.  The code for this process is below.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-fsharp&#34;&gt;let generateTetrahedron size = 
    let circumSphereRadius = sqrt (3.f/8.f) * size
    let centerVertexAngle = acos (-1.f/3.f)
    let v1 = Vector3(0.f, circumSphereRadius, 0.f)
    let v2 = v1 |&amp;gt; Vector3.rotateX centerVertexAngle
    let v3 = v2 |&amp;gt; Vector3.rotateY (radians 120.f)
    let v4 = v2 |&amp;gt; Vector3.rotateY (-radians 120.f)
    
    let uv1 = Vector2(0.5f, 1.f - sqrt 0.75f)
    let uv2 = Vector2(0.75f, 1.f - (sqrt 0.75f)/2.f)
    let uv3 = Vector2(0.25f, 1.f - (sqrt 0.75f)/2.f)
    let uv4 = Vector2(0.5f, 1.f)
    let uv5 = Vector2.UnitY
    let uv6 = Vector2.One

    [| VertexPositionTexture(v1, uv1)
       VertexPositionTexture(v3, uv2)
       VertexPositionTexture(v2, uv3)  
       
       VertexPositionTexture(v1, uv2)
       VertexPositionTexture(v4, uv6)
       VertexPositionTexture(v3, uv4)

       VertexPositionTexture(v1, uv3)
       VertexPositionTexture(v2, uv4)
       VertexPositionTexture(v4, uv5)

       VertexPositionTexture(v2, uv3)
       VertexPositionTexture(v3, uv2)
       VertexPositionTexture(v4, uv4) |] 
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The last piece of the puzzle is the texture coordinates.  There is some amazing software available to help model both texture
and 3d geometry, projecting the vertices onto a 2d plane can be an art-form in itself.  Luckily the tetrahedron is one
of the simplest models, if you imagine the tetrahedron unfolded it would look like this from the top:&lt;/p&gt;


&lt;figure class=&#34;third&#34;&gt;
    
        &lt;img src=&#34;http://upload.wikimedia.org/wikipedia/commons/thumb/8/88/Tetrahedron_flat.svg/240px-Tetrahedron_flat.svg.png&#34; /&gt;
    
    
&lt;/figure&gt;


&lt;p&gt;To map a texture to the tetrahedron we have to include a texture coordinate with every vertex.  These coordinates are &lt;code&gt;uv1-uv6&lt;/code&gt;
in the code above.  We use some ratios to select the correct coordinates within the texture.  The texture coordinates are always
between 0 and 1.  Here&amp;rsquo;s the location of the above points so you can see the locations clearly.&lt;/p&gt;


&lt;figure class=&#34;third&#34;&gt;
    
        &lt;img src=&#34;https://lh4.googleusercontent.com/-NpV1nz3K-kI/ULKY-KY6emI/AAAAAAAABio/565nXCNC9xY/s425/texture&amp;#43;coords.png&#34; /&gt;
    
    
&lt;/figure&gt;


&lt;p&gt;To make sure that the texture is in the right place we are going to use a type of fractal called the
&lt;a href=&#34;http://en.wikipedia.org/wiki/Sierpinski_triangle&#34;&gt;Sierpinski triangle&lt;/a&gt;.  The Sierpinski triangle had exactly the same net, or unfolded shape as the texture we need to use.  Each
of the first iterations of the fractal is coloured separately as this will make it easy to see if the mapping is  correct.  Here
is what the texture looks like:&lt;/p&gt;


&lt;figure class=&#34;third&#34;&gt;
    
        &lt;img src=&#34;https://lh4.googleusercontent.com/-hLyy6qGXjWc/ULKn_4p-CUI/AAAAAAAABjA/azvh8cUNrAY/s310/Tetrahedron.png&#34; /&gt;
    
    
&lt;/figure&gt;


&lt;p&gt;This is how everything will look, I know its not incredibly impressive but its &lt;a href=&#34;http://monogame.codeplex.com&#34;&gt;MonoGame&lt;/a&gt; in 3d, F#, and all running on a
Mac, what more could you want! ;)&lt;/p&gt;


&lt;figure &gt;
    
        &lt;img src=&#34;https://lh5.googleusercontent.com/-P_7wHvJbdY0/ULO2xNStVwI/AAAAAAAABjQ/SGA5DT4ChgU/s800/Screen&amp;#43;Shot&amp;#43;2012-11-26&amp;#43;at&amp;#43;18.33.57.png&#34; /&gt;
    
    
&lt;/figure&gt;


&lt;p&gt;Its feels like we covered a lot of ground here but all we have is a spinning tetrahedron, its tricky to know what level of
detail to go down to.  I don&amp;rsquo;t want to teach anyone how to suck eggs, and I want to alienate people who are new
to this area and want to learn, I hope I got the balance about right.&lt;/p&gt;

&lt;p&gt;If you want to just get the code and have a look then here&amp;rsquo;s my &lt;a href=&#34;https://github.com/7sharp9/PlatonicSolids&#34;&gt;GitHub repo&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;As usual I appreciate any comments and feedback.&lt;/p&gt;

&lt;p&gt;Until next time!&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>F# and MonoGame on the Mac</title>
      <link>http://7sharpnine.com/2012/11/11/2012-11-11-fsharp-and-monogame-on-the-mac/</link>
      <pubDate>Sun, 11 Nov 2012 00:00:00 +0000</pubDate>
      
      <guid>http://7sharpnine.com/2012/11/11/2012-11-11-fsharp-and-monogame-on-the-mac/</guid>
      <description>

&lt;p&gt;What we are going to do in this post is take a whistle stop tour of getting &lt;a href=&#34;http://monogame.codeplex.com&#34;&gt;MonoGame&lt;/a&gt; up and running along with a
simple demo in F#.  Over the last few days I have been building an F# project template for MonoDevelop, this post will
also how to get that installed too.  &lt;!-- more --&gt;&lt;/p&gt;

&lt;p&gt;First of all I&amp;rsquo;m going to assume that you have the following installed:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Mono 3.0 beta&lt;/li&gt;
&lt;li&gt;MonoDevelop&lt;/li&gt;
&lt;li&gt;MonoDevelop F# language binding&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;If you don&amp;rsquo;t have a look at my &lt;a href=&#34;http://7sharpnine.com/posts/Fsharp-3-in-the-Mac-and-Mono-World/&#34;&gt;previous post&lt;/a&gt; that explains all that, if you don&amp;rsquo;t want to build the F# binding from source
then you can use the &lt;code&gt;Add-in Manager&lt;/code&gt;.  If you look in &lt;code&gt;Gallery&lt;/code&gt; the language binding section contains the F# language
binding.  I prefer using the source at the moment as I like to tweak a few things here and there and nosy around in the code.&lt;/p&gt;

&lt;h2 id=&#34;cloning-and-building&#34;&gt;Cloning and building&lt;/h2&gt;

&lt;p&gt;First clone my &lt;a href=&#34;https://github.com/7sharp9/MonoGame&#34;&gt;MonoGame repo&lt;/a&gt;, why my repo?  Well, I have been doing F# specific work and I have been submitting my
pull requests but there will always be a lag while I&amp;rsquo;m waiting for one of the maintainers to merge in my code, an I might
fix a bug in between writing this blog and you reading it.  The main repo is located &lt;a href=&#34;https://github.com/mono/MonoGame&#34;&gt;here&lt;/a&gt; if you are interested in
looking at that too.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;git clone git@github.com:7sharp9/MonoGame.git
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;OK, now we need to initialise and get the submodules:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;git submodule init
git subbmodule update
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Now go and make a cup of tea or coffee or something because this will take a little while! :-)&lt;/p&gt;

&lt;p&gt;if you get any serious errors from the submodules you cold try this:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;git submodule sync
git submodule update
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Check that the main framework builds, this will test if all the submodules updated correctly as well.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;cd MonoGame
xbuild MonoGame.Framework.MacOS.sln
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;building-the-project-templates&#34;&gt;Building the Project templates&lt;/h2&gt;

&lt;p&gt;I was going to go through the manual steps required to get things up and running but I figured I may as well go through
getting the project templates installed too.  Now the project templates are not 100% by any means and there is currently
work under way to produce a cross platform installer that will take care of everything.&lt;/p&gt;

&lt;p&gt;There are currently the following C# based templates:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;MonoGame for Android&lt;/li&gt;
&lt;li&gt;MonoGame for iOS&lt;/li&gt;
&lt;li&gt;MonoGame for Windows Application&lt;/li&gt;
&lt;li&gt;MonoGame for Linux&lt;/li&gt;
&lt;li&gt;MonoGame for Mac Application&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;And the following brand new shiny F# templates that I added a few days ago:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;MonoGame for Mac Application&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Yeah I know there&amp;rsquo;s only one for now but Ill get there&amp;hellip;&lt;/p&gt;

&lt;p&gt;Right, we&amp;rsquo;re going to rattle through some commands to build the project templates:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;#Change directory to the project templates
cd ProjectTemplates/MonoDevelop/MonoDevelop.MonoGame/

#Build the Project templates solution:

xbuild MonoDevelop.MonoGame.sln 
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Now we&amp;rsquo;re going to create the add-in structure and install it in MonoDevelop&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;#create a folder for the add-in:
mkdir /Applications/MonoDevelop.app/Contents/MacOS/lib/monodevelop/AddIns/MonoDevelop.MonoGame

#Copy the templates and icons into that folder:
cp -R MonoDevelop.MonoGame/templates /Applications/MonoDevelop.app/Contents/MacOS/lib/monodevelop/AddIns/MonoDevelop.MonoGame
cp -R MonoDevelop.MonoGame/icons /Applications/MonoDevelop.app/Contents/MacOS/lib/monodevelop/AddIns/MonoDevelop.MonoGame
cp -R MonoDevelop.MonoGame/bin/Release/MonoDevelop.MonoGame.dll /Applications/MonoDevelop.app/Contents/MacOS/lib/monodevelop/AddIns/MonoDevelop.MonoGame
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;If you fire up MonoDevelop and create a new solution now you should see a new project type:&lt;/p&gt;


&lt;figure &gt;
    
        &lt;img src=&#34;https://lh5.googleusercontent.com/-5_khSpX_ong/UJ-MeJOyTpI/AAAAAAAABh4/oftw3zWSMqo/s1062/MonoGame&amp;#43;Mac&amp;#43;Application.png&#34; /&gt;
    
    
&lt;/figure&gt;


&lt;p&gt;I know this is a bit long winded but it will get you started until a proper installer finished.&lt;/p&gt;

&lt;p&gt;Oh yeah there are currently a couple of caveats, once you have created a new project from the template you &lt;strong&gt;must&lt;/strong&gt; do
the following:&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;Open the project references and re-add the &lt;strong&gt;Lidgren.Network.dll&lt;/strong&gt; and the &lt;strong&gt;MonoGame.FrameWork.MacOS.dll&lt;/strong&gt; references.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;I know I know that&amp;rsquo;s a &lt;strong&gt;major pain&lt;/strong&gt; but let me tell you the reason for this.&lt;/p&gt;

&lt;h3 id=&#34;package-references-in-monodevelop&#34;&gt;Package references in MonoDevelop&lt;/h3&gt;

&lt;p&gt;You might of noticed that the aforementioned references were shown in red when the new project was opened, this was
because there was no way for MonoDevelop to know where they were currently located.  We could of added a
&lt;a href=&#34;http://en.wikipedia.org/wiki/Pkg-config&#34;&gt;package config file&lt;/a&gt; to the &lt;code&gt;/Library/Frameworks/Mono.framework/Versions/3.0.0/lib/pkgconfig&lt;/code&gt; folder which would
allow MonoDevelop to know how to resolve the references but this then leads to a further problem:&lt;/p&gt;

&lt;p&gt;Package references in MonoDevelop are expected to be located in the GAC, and because of this assumption the copy local property has no
effect.  There is an &lt;a href=&#34;https://bugzilla.xamarin.com/show_bug.cgi?id=4030&#34;&gt;oustanding bug&lt;/a&gt; logged for this issue.  There are workarounds for these issues as mentioned in
the &lt;a href=&#34;https://bugzilla.xamarin.com/show_bug.cgi?id=4030&#34;&gt;bug report&lt;/a&gt; but it is still currently an issue in MonoGame.  Hopefully it will be addressed in the near future.&lt;/p&gt;

&lt;p&gt;You might be asking why cant we put the assemblies it in the GAC?&lt;/p&gt;

&lt;p&gt;Well we could do although you would have then have to sign the assembly as it is currently not strongly named and then
install it in the GAC with &lt;code&gt;gacutil&lt;/code&gt;, and as this is still an early beta so I&amp;rsquo;m happy to keep the assembly out of the GAC for now.&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;You should be ready to put MonoGame to use now.  If you run the template project you will get a MonoGame logo drawn to
the screen.  I suggest looking at some of the demo&amp;rsquo;s in the Samples folder and maybe try porting a couple of them over
to F#.  In future posts Ill try to address some of the functional aspect of using F# with MonoGame.&lt;/p&gt;

&lt;h2 id=&#34;what-s-next&#34;&gt;What&amp;rsquo;s next?&lt;/h2&gt;

&lt;p&gt;I&amp;rsquo;m currently starting work on a post which shows F# using some of the 3D aspects of MonoGame.  Exciting!&lt;/p&gt;

&lt;p&gt;Until next time&amp;hellip;&lt;/p&gt;
</description>
    </item>
    
  </channel>
</rss>