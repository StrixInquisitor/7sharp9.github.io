<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Await on 7sharp9</title>
    <link>http://7sharpnine.com/tags/await/</link>
    <description>Recent content in Await on 7sharp9</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <copyright>Dave Thomas</copyright>
    <lastBuildDate>Thu, 18 Apr 2013 00:00:00 +0000</lastBuildDate>
    <atom:link href="http://7sharpnine.com/tags/await/index.xml" rel="self" type="application/rss+xml" />
    
    <item>
      <title>iOS async revisited</title>
      <link>http://7sharpnine.com/2013/04/18/2013-04-18-ios-async-revisited/</link>
      <pubDate>Thu, 18 Apr 2013 00:00:00 +0000</pubDate>
      
      <guid>http://7sharpnine.com/2013/04/18/2013-04-18-ios-async-revisited/</guid>
      <description>

&lt;p&gt;In this post weare going to look as async again, but from the perspective of F#.&lt;/p&gt;

&lt;h3 id=&#34;xamarin-evolve-2013&#34;&gt;Xamarin Evolve 2013&lt;/h3&gt;

&lt;p&gt;
&lt;figure &gt;
    
        &lt;img src=&#34;http://blog.xamarin.com/wp-content/uploads/2013/04/Screen-Shot-2013-04-03-at-11.07.21-AM.png&#34; /&gt;
    
    
&lt;/figure&gt;
&lt;br /&gt;
I have been watching the Xamarin Evolve conference this week and it was good to see Miguel announce full support for F#.  Those that follow me on twitter etc, will know that I have been doing F# for quite a while in MonoDevelop and Xamarin Studio.  The new support currently entails some new project templates so that you can easily create epic new F# Apps without having to refer to my blog.  While its sad that my content now falls into the archives its nice to get official support announced in such a grand fashion.  &lt;!-- more --&gt;&lt;/p&gt;

&lt;h3 id=&#34;f-async&#34;&gt;F# Async&lt;/h3&gt;

&lt;p&gt;Kudos to Miguel for covering some history of C#&amp;rsquo;s async feature right back down to its F# heritage too, which appeared in 2007, thanks to the work of Don Syme and the F# team.  You can read more about that on &lt;a href=&#34;http://blogs.msdn.com/b/dsyme/archive/2013/03/24/asynchronous-programming-from-f-to-python.aspx&#34;&gt;Don Syme&amp;rsquo;s blog&lt;/a&gt; or have a look at the research paper &lt;a href=&#34;http://research.microsoft.com/apps/pubs/default.aspx?id=147194&#34;&gt;here&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;So the highly anticipated async await model in C# that&amp;rsquo;s just gone beta in Xamarin addin channel?  We&amp;rsquo;ve had it for ages in F#!  In fact, I suspect you will have been able to use it for quite some time, even before I started hacking together support for F# in iOS!  Anyway, that&amp;rsquo;s enough of the smugness :-) lets get on and see what it looks like using some of the code from the previous post as a reference.&lt;/p&gt;

&lt;p&gt;Ill include the C# version first so that you can see the difference rather than having to open my last post.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-csharp&#34;&gt;// Asynchronous HTTP request
public async void HttpSample ()
{
    Application.Busy ();
    var request = WebRequest.Create (Application.WisdomUrl);

    //async await version
    try{
        var response = await request.GetResponseAsync();
        Application.Done ();
        ad.RenderRssStream(response.GetResponseStream());
    } catch {
        // Error
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;One of the advantages of the F# Async model is it&amp;rsquo;s composable nature and controllability.  The key to F# async is that its defined with F#&amp;rsquo;s &lt;a href=&#34;http://msdn.microsoft.com/en-gb/library/dd233182.aspx&#34;&gt;computation expression&lt;/a&gt; syntax:&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;Computation expressions in F# provide a convenient syntax for writing computations that can be sequenced and combined using control flow constructs and bindings.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;There are several built in workflows: &lt;a href=&#34;http://msdn.microsoft.com/en-gb/library/dd233209.aspx&#34;&gt;Sequences&lt;/a&gt;, &lt;a href=&#34;http://msdn.microsoft.com/en-gb/library/dd233250.aspx&#34;&gt;Asynchronous Workflows&lt;/a&gt;, and &lt;a href=&#34;http://msdn.microsoft.com/en-gb/library/hh225374.aspx&#34;&gt;Query Expressions&lt;/a&gt;.  Whenever you use a computation expression it is as follows:- &lt;code&gt;builder-name { expression }&lt;/code&gt;.  With that tiny bit of background, lets look at the corresponding F# async code:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-fsharp&#34;&gt;member x.HttpSample() =
    Application.Busy() 
    let request = WebRequest.Create(Application.WisdomUrl )
    
    //F# async version
    async {try let! response = request.AsyncGetResponse()
               Application.Done()
               ad(response.GetResponseStream())
           with ex -&amp;gt; () } |&amp;gt; Async.Start
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;You can see there is quite a similarity between this snippet and the C# one and you should be able to figure out what&amp;rsquo;s happening given the knowledge from the previous post.&lt;/p&gt;

&lt;p&gt;One of the first things you will notice the builder - &lt;code&gt;async { ...&lt;/code&gt;, followed by the &lt;code&gt;let!&lt;/code&gt; statement.  You can think of the &lt;code&gt;let!&lt;/code&gt; as the C# equivalent of await.  &lt;code&gt;let!&lt;/code&gt; starts the computation &lt;code&gt;request.AsyncGetResponse()&lt;/code&gt;, and then the thread is suspended until the result is available, at this point execution continues to the next statment, which in this case is &lt;code&gt;Application.Done()&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;Those of you comparing the difference will notice that in the C# version after &lt;code&gt;Application.Done();&lt;/code&gt; we call &lt;code&gt;ad.RenderRssStream(response.GetResponseStream())&lt;/code&gt; but in the F# version we simply call &lt;code&gt;ad(response.GetResponseStream())&lt;/code&gt;.  If we take a quick look at the constructors for the types that hold these methods I can show you the difference a bit better:&lt;/p&gt;

&lt;p&gt;The C# version looks like this:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-csharp&#34;&gt;public class DotNet 
{
	AppDelegate ad;

	public DotNet (AppDelegate ad)
	{
		this.ad = ad;
	}
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The F# one I can show on a single line:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-fsharp&#34;&gt;type DotNet(ad: Stream -&amp;gt; unit) =
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The main difference is that The C# version has the entire &lt;code&gt;AppDelegate&lt;/code&gt; class is passed in, whereas the F# version just takes a function with the signature &lt;code&gt;Stream -&amp;gt; unit&lt;/code&gt;.  In fact the F# version doesn&amp;rsquo;t even need to be placed inside a type like the C# version, we can use a &lt;a href=&#34;http://msdn.microsoft.com/en-gb/library/dd233221.aspx&#34;&gt;module&lt;/a&gt;, again Ill quote from MSDN:&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;In the context of the F# language, a module is a grouping of F# code, such as values, types, and function values, in an F# program. Grouping code in modules helps keep related code together and helps avoid name conflicts in your program.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h3 id=&#34;f-modules&#34;&gt;F# Modules&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&#34;language-fsharp&#34;&gt;module DotNet&#39; =
    let HttpSample(ad) =
            Application.Busy() 
            let request = WebRequest.Create(Application.WisdomUrl )
            
            //F# async version
            async {try let! response = request.AsyncGetResponse()
                       Application.Done()
                       ad(response.GetResponseStream())
                   with ex -&amp;gt; () } |&amp;gt; Async.Start
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;When we want to call this code we can open the module like you would a namespace:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-fsharp&#34;&gt;open DotNet
HttpSample(ad)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Or access it fully qualified by including the &lt;code&gt;module&lt;/code&gt; name:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-fsharp&#34;&gt;DotNet.HttpSample(ad)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;How would this code look from the context of this sample application?&lt;/p&gt;

&lt;p&gt;Here is a snipped from the AppDelegate code which makes use of this module&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-fsharp&#34;&gt;// This method is invoked when the application has loaded its UI and its ready to run
override x.FinishedLaunching (app:UIApplication, options:NSDictionary) =
    x.window.AddSubview (x.navigationController.View)
    x.button1.TouchDown.Add 
        (fun _ -&amp;gt;  if not UIApplication.SharedApplication.NetworkActivityIndicatorVisible then           
                       match x.stack.SelectedRow() with
                       | 0 -&amp;gt; DotNet.HttpSample x.RenderRssStream
                       | 1 -&amp;gt; DotNet.HttpSecureSample x.RenderStream
                       | _ -&amp;gt; (new Cocoa(x.RenderRssStream)).HttpSample() |&amp;gt; ignore )    
    TableViewSelector.Configure (x.stack, [|&amp;quot;http  - WebRequest&amp;quot;
                                            &amp;quot;https - WebRequest&amp;quot;
                                            &amp;quot;http  - NSUrlConnection&amp;quot; |] )                    
    x.window.MakeKeyAndVisible()
    true
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;There are a few departures from the C# sample code which Ill include below now:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;// This method is invoked when the application has loaded its UI and its ready to run
public override bool FinishedLaunching (UIApplication app, NSDictionary options)
{
  window.AddSubview (navigationController.View);

  button1.TouchDown += Button1TouchDown;
  TableViewSelector.Configure (this.stack, new string [] {
    &amp;quot;http  - WebRequest&amp;quot;,
    &amp;quot;https - WebRequest&amp;quot;,
    &amp;quot;http  - NSUrlConnection&amp;quot;
  });

  window.MakeKeyAndVisible ();

  return true;
}

void Button1TouchDown (object sender, EventArgs e)
{
  // Do not queue more than one request
  if (UIApplication.SharedApplication.NetworkActivityIndicatorVisible)
    return;

  switch (stack.SelectedRow ()){
  case 0:
    new DotNet (this).HttpSample ();
    break;

  case 1:
    new DotNet (this).HttpSecureSample ();
    break;

  case 2:
    new Cocoa (this).HttpSample ();
    break;
  }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Firstly we are using an lambda expression for the event handler via the Add method rather than the += handler which we use in C#.  We are also using F#&amp;rsquo;s awesome &lt;a href=&#34;http://msdn.microsoft.com/en-gb/library/dd547125.aspx&#34;&gt;pattern matching&lt;/a&gt; feature on the results of &lt;code&gt;x.stack.SelectedRow()&lt;/code&gt;.  This allows you to encode complex logic and also have the compiler assist you by catching non covered cases.&lt;/p&gt;

&lt;p&gt;I&amp;rsquo;m going to leave it there for now as I don&amp;rsquo;t want to bombard any newcomers with tons of new F# features, and I also don&amp;rsquo;t want to teach any of my regular F# followers how to suck eggs.  If anyone has a preference for more in depth comparisons to the C# version then let me know then I can tailor that into further posts on the subject.&lt;/p&gt;

&lt;p&gt;Until next time!&lt;/p&gt;

&lt;hr style=&#34;margin: 1em 0&#34;&gt;
&lt;h1 id=&#34;essential-listening&#34;&gt;Essential listening:&lt;/h1&gt;


&lt;div class=&#34;pure-g&#34;&gt;

  
  
  
  
  &lt;div class=&#34;&#34;&gt;
    &lt;div style=&#34;width: 20%; float: left;padding: 0 .2em .2em 0&#34;&gt;
        &lt;figure style=&#34;margin: 0&#34;&gt;
            &lt;img src=&#34;http://upload.wikimedia.org/wikipedia/en/b/b4/PerpetualBurn.jpg&#34; style=&#34;margin: 0&#34;
                 alt=&#34;Jason Becker - Perpetual Burn&#34; /&gt;
            &lt;figcaption&gt;
                &lt;h6&gt;Jason Becker - Perpetual Burn&lt;/h4&gt;
            &lt;/figcaption&gt;
        &lt;/figure&gt;
    &lt;/div&gt;
  &lt;/div&gt;
  

  
  
  
  
  &lt;div class=&#34;&#34;&gt;
    &lt;div style=&#34;width: 20%; float: left;padding: 0 .2em .2em 0&#34;&gt;
        &lt;figure style=&#34;margin: 0&#34;&gt;
            &lt;img src=&#34;http://upload.wikimedia.org/wikipedia/en/d/dc/Megadeth-RustInPeace.jpg&#34; style=&#34;margin: 0&#34;
                 alt=&#34;Megadeth - Rust In Peace&#34; /&gt;
            &lt;figcaption&gt;
                &lt;h6&gt;Megadeth - Rust In Peace&lt;/h4&gt;
            &lt;/figcaption&gt;
        &lt;/figure&gt;
    &lt;/div&gt;
  &lt;/div&gt;
  

  
  
  
  
  &lt;div class=&#34;&#34;&gt;
    &lt;div style=&#34;width: 20%; float: left;padding: 0 .2em .2em 0&#34;&gt;
        &lt;figure style=&#34;margin: 0&#34;&gt;
            &lt;img src=&#34;http://www.metal-archives.com/images/4/6/3/9/4639.jpg?3304&#34; style=&#34;margin: 0&#34;
                 alt=&#34;&#34; /&gt;
            &lt;figcaption&gt;
                &lt;h6&gt;&lt;/h4&gt;
            &lt;/figcaption&gt;
        &lt;/figure&gt;
    &lt;/div&gt;
  &lt;/div&gt;
  

&lt;/div&gt;




</description>
    </item>
    
    <item>
      <title>A little bit of iOS async</title>
      <link>http://7sharpnine.com/2013/04/16/2013-04-16-a-little-bit-of-ios-async/</link>
      <pubDate>Tue, 16 Apr 2013 00:00:00 +0000</pubDate>
      
      <guid>http://7sharpnine.com/2013/04/16/2013-04-16-a-little-bit-of-ios-async/</guid>
      <description>&lt;p&gt;I was going to title this post as &amp;lsquo;Now for something completely different&amp;rsquo; but felt that a little bit too &lt;a href=&#34;http://en.wiktionary.org/wiki/Pythonesque&#34;&gt;Pythonesque&lt;/a&gt;, and when I thought about it a bit it isn&amp;rsquo;t really completely just slightly different, namely C# rather than my usual F# posts.  &lt;!-- more --&gt;&lt;/p&gt;

&lt;p&gt;Right, enough of the waffling, this post is a little tour into the relatively unknown area of async on iOS.  Xamarin announced the alpha preview of async await on March 11th this year (2013).  There are a couple of blog post floating around on the net if you look around, Rodrigo Kumpera posted a small example &lt;a href=&#34;http://blog.xamarin.com/brave-new-async-mobile-world/&#34;&gt;here&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;I&amp;rsquo;m no stranger to async, I have spent a great deal of time over the years debugging and refining &lt;a href=&#34;http://msdn.microsoft.com/en-GB/library/system.iasyncresult.aspx&#34;&gt;IAsyncResult&lt;/a&gt; style procedures and found Jeffrey Richter and Joe Duffy&amp;rsquo;s books below to be an excellent reference for those interested.&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;http://www.amazon.com/gp/product/0735667454/ref=as_li_ss_il?ie=UTF8&amp;camp=1789&amp;creative=390957&amp;creativeASIN=0735667454&amp;linkCode=as2&amp;tag=blacguitandge-20&#34;&gt;&lt;img border=&#34;0&#34; src=&#34;http://ws.assoc-amazon.com/widgets/q?_encoding=UTF8&amp;ASIN=0735667454&amp;Format=_SL160_&amp;ID=AsinImage&amp;MarketPlace=US&amp;ServiceVersion=20070822&amp;WS=1&amp;tag=blacguitandge-20&#34; &gt;&lt;/a&gt;&lt;img src=&#34;http://www.assoc-amazon.com/e/ir?t=blacguitandge-20&amp;l=as2&amp;o=1&amp;a=0735667454&#34; width=&#34;1&#34; height=&#34;1&#34; border=&#34;0&#34; alt=&#34;&#34; style=&#34;border:none !important; margin:0px !important;&#34; /&gt;&lt;a href=&#34;http://www.amazon.com/gp/product/032143482X/ref=as_li_ss_il?ie=UTF8&amp;camp=1789&amp;creative=390957&amp;creativeASIN=032143482X&amp;linkCode=as2&amp;tag=blacguitandge-20&#34;&gt;&lt;img border=&#34;0&#34; src=&#34;http://ws.assoc-amazon.com/widgets/q?_encoding=UTF8&amp;ASIN=032143482X&amp;Format=_SL160_&amp;ID=AsinImage&amp;MarketPlace=US&amp;ServiceVersion=20070822&amp;WS=1&amp;tag=blacguitandge-20&#34; &gt;&lt;/a&gt;&lt;img src=&#34;http://www.assoc-amazon.com/e/ir?t=blacguitandge-20&amp;l=as2&amp;o=1&amp;a=032143482X&#34; width=&#34;1&#34; height=&#34;1&#34; border=&#34;0&#34; alt=&#34;&#34; style=&#34;border:none !important; margin:0px !important;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;If you looking for a book on TPL/parallel programming then Parallel Programming with Microsoft .NET by Stephen Toub et al. is also a good read.&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;http://www.amazon.com/gp/product/0735651590/ref=as_li_ss_il?ie=UTF8&amp;camp=1789&amp;creative=390957&amp;creativeASIN=0735651590&amp;linkCode=as2&amp;tag=blacguitandge-20&#34;&gt;&lt;img border=&#34;0&#34; src=&#34;http://ws.assoc-amazon.com/widgets/q?_encoding=UTF8&amp;ASIN=0735651590&amp;Format=_SL160_&amp;ID=AsinImage&amp;MarketPlace=US&amp;ServiceVersion=20070822&amp;WS=1&amp;tag=blacguitandge-20&#34; &gt;&lt;/a&gt;&lt;img src=&#34;http://www.assoc-amazon.com/e/ir?t=blacguitandge-20&amp;l=as2&amp;o=1&amp;a=0735651590&#34; width=&#34;1&#34; height=&#34;1&#34; border=&#34;0&#34; alt=&#34;&#34; style=&#34;border:none !important; margin:0px !important;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;Anyway, enough of the book references lets look at an iOS example of async using the &lt;a href=&#34;https://github.com/xamarin/monotouch-samples&#34;&gt;MonoTouch samples&lt;/a&gt; from Xamarin as a reference.&lt;/p&gt;

&lt;p&gt;We are going to use the &lt;a href=&#34;https://github.com/xamarin/monotouch-samples/tree/master/HttpClient&#34;&gt;HttpSample&lt;/a&gt;.  Its a relatively simple example that has several buttons which trigger an asynchronous request for data, when the data is returned it&amp;rsquo;s simply rendered onto the screen.&lt;/p&gt;

&lt;p&gt;Lets look at the first asynchronous call in the &lt;a href=&#34;https://github.com/xamarin/monotouch-samples/blob/master/HttpClient/DotNet.cs&#34;&gt;DotNet.cs&lt;/a&gt; file, the &lt;code&gt;HttpSample&lt;/code&gt;  method:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-csharp&#34;&gt;// Asynchronous HTTP request
public void HttpSample ()
{
	Application.Busy ();
	var request = WebRequest.Create (Application.WisdomUrl);
	request.BeginGetResponse (FeedDownloaded, request);
}

// Invoked when we get the stream back from the twitter feed
// We parse the RSS feed and push the data into a table.
void FeedDownloaded (IAsyncResult result)
{
	Application.Done ();
	var request = result.AsyncState as HttpWebRequest;
	
	try {
    		var response = request.EndGetResponse (result);
		    ad.RenderRssStream (response.GetResponseStream ());
	} catch {
		// Error				
	}
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;To convert this to the async await style all we have to do is use the async and await keywords (surprise surprise!), and in this instance use the new &lt;strong&gt;Async&lt;/strong&gt; suffixed methods on the &lt;code&gt;WebRequest&lt;/code&gt; class.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-csharp&#34;&gt;// Asynchronous HTTP request
public async void HttpSample ()
{
	Application.Busy ();
	var request = WebRequest.Create (Application.WisdomUrl);

	//async await version
	try{
		var response = await request.GetResponseAsync();
		Application.Done ();
	    ad.RenderRssStream(response.GetResponseStream());
	} catch {
		// Error
	}
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;As you can see the &lt;code&gt;request.BeginGetResponse&lt;/code&gt; method has been changed to &lt;code&gt;await request.GetResponseAsync()&lt;/code&gt; and the callback method &lt;code&gt;FeedDownloaded&lt;/code&gt; which was passed into the &lt;code&gt;BeginGetRespose&lt;/code&gt; method has now been assimilated into the &lt;code&gt;HttpSample&lt;/code&gt; method.  The await keyword is acting as a wait point or suspension while the asynchronous method completes.  As soon the asynchronous call completes then processing continues to the line below, much in the same way that the callback code is executed in the IAsyncResult version.  For an in depth description then you can take a look at the &lt;a href=&#34;http://msdn.microsoft.com/en-gb/library/vstudio/hh191443.aspx&#34;&gt;MSDN documentation&lt;/a&gt; on the subject.&lt;/p&gt;

&lt;p&gt;You could add a WebException to the catch block here, you would expect on situations like network outage which would result in DNS lookup failures from the async call.&lt;/p&gt;

&lt;p&gt;We can look at the next asynchronous method too the &amp;lsquo;HttpSecureSample&amp;rsquo; method&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-csharp&#34;&gt;// Asynchornous HTTPS request
public void HttpSecureSample ()
{
	var https = (HttpWebRequest) WebRequest.Create (&amp;quot;https://gmail.com&amp;quot;);

	// To not depend on the root certficates, we will accept any certificates:
	ServicePointManager.ServerCertificateValidationCallback = (sender, cert, chain, ssl) =&amp;gt;  true;

	https.BeginGetResponse (GmailDownloaded, https);
}

// This sample just gets the result from calling https://gmail.com, an HTTPS secure 
// connection, we do not attempt to parse the output, but merely dump it as text
void GmailDownloaded (IAsyncResult result)
{
	Application.Done ();
	var request = result.AsyncState as HttpWebRequest;

	try {
    		var response = request.EndGetResponse (result);
		    ad.RenderStream (response.GetResponseStream ());
	} catch {
		// Error
	}
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Lets have a look at the async await version of that:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-csharp&#34;&gt;// Asynchornous HTTPS request
public async void HttpSecureSample ()
{
	var https = (HttpWebRequest) WebRequest.Create (&amp;quot;https://gmail.com&amp;quot;);

	// To not depend on the root certficates, we will accept any certificates:
	ServicePointManager.ServerCertificateValidationCallback = (sender, cert, chain, ssl) =&amp;gt;  true;

    try {
			var response = await https.GetResponseAsync();
			Application.Done ();
			ad.RenderRssStream (response.GetResponseStream ());
	} catch {
		// Error
	}
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;In this situation there was also a version of the IAsyncResult Begin/End pattern that had been converted to async - &lt;code&gt;https.GetResponseAsync()&lt;/code&gt; and we also had to add the &lt;code&gt;async&lt;/code&gt; keyword to the &lt;code&gt;HttpSecureSample&lt;/code&gt; method.&lt;/p&gt;

&lt;p&gt;For the situations where there is no &lt;strong&gt;Async&lt;/strong&gt; suffixed method available you can build your own using the &lt;a href=&#34;http://msdn.microsoft.com/en-us/library/system.threading.tasks.taskfactory.fromasync.aspx&#34;&gt;Task.Factory.FromAsync&lt;/a&gt; methods.  I wont go into the details of that here but if anyone wants any information on that then just give me a shout and I can revisit in in a future post.&lt;/p&gt;

&lt;p&gt;Ah yes, I almost forgot, there are some common pitfalls of using async await and Tomas Petricek posted a good compilation of them the other day: &lt;a href=&#34;http://tomasp.net/blog/csharp-async-gotchas.aspx&#34;&gt;C# async gotchas&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;Until next time!&lt;/p&gt;

&lt;hr style=&#34;margin: 1em 0&#34;&gt;
&lt;h1 id=&#34;essential-listening&#34;&gt;Essential listening:&lt;/h1&gt;


&lt;div class=&#34;pure-g&#34;&gt;

  
  
  
  
  &lt;div class=&#34;&#34;&gt;
    &lt;div style=&#34;width: 20%; float: left;padding: 0 .2em .2em 0&#34;&gt;
        &lt;figure style=&#34;margin: 0&#34;&gt;
            &lt;img src=&#34;http://upload.wikimedia.org/wikipedia/en/6/69/Silence_Followed_By_a_Deafening_Roar_album.jpg&#34; style=&#34;margin: 0&#34;
                 alt=&#34;Paul Gilbert - Silence Followed By A Deafening Roar&#34; /&gt;
            &lt;figcaption&gt;
                &lt;h6&gt;Paul Gilbert - Silence Followed By A Deafening Roar&lt;/h4&gt;
            &lt;/figcaption&gt;
        &lt;/figure&gt;
    &lt;/div&gt;
  &lt;/div&gt;
  

  
  
  
  
  &lt;div class=&#34;&#34;&gt;
    &lt;div style=&#34;width: 20%; float: left;padding: 0 .2em .2em 0&#34;&gt;
        &lt;figure style=&#34;margin: 0&#34;&gt;
            &lt;img src=&#34;http://upload.wikimedia.org/wikipedia/en/0/0d/FooFighters-TheColourAndTheShape.jpg&#34; style=&#34;margin: 0&#34;
                 alt=&#34;FooFighters - The Colour And The Shape&#34; /&gt;
            &lt;figcaption&gt;
                &lt;h6&gt;FooFighters - The Colour And The Shape&lt;/h4&gt;
            &lt;/figcaption&gt;
        &lt;/figure&gt;
    &lt;/div&gt;
  &lt;/div&gt;
  

&lt;/div&gt;




</description>
    </item>
    
  </channel>
</rss>