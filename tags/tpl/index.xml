<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Tpl on 7sharp9</title>
    <link>http://7sharpnine.com/tags/tpl/</link>
    <description>Recent content in Tpl on 7sharp9</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <copyright>Dave Thomas</copyright>
    <lastBuildDate>Wed, 05 Jun 2013 00:00:00 +0000</lastBuildDate>
    <atom:link href="http://7sharpnine.com/tags/tpl/index.xml" rel="self" type="application/rss+xml" />
    
    <item>
      <title>Monster Zero - Revisited</title>
      <link>http://7sharpnine.com/2013/06/05/2013-06-05-monster-zero-revisited/</link>
      <pubDate>Wed, 05 Jun 2013 00:00:00 +0000</pubDate>
      
      <guid>http://7sharpnine.com/2013/06/05/2013-06-05-monster-zero-revisited/</guid>
      <description>

&lt;p&gt;
&lt;figure class=&#34;img-left&#34;&gt;
    
        &lt;img src=&#34;http://upload.wikimedia.org/wikipedia/en/c/ce/KingGhidorah.jpg&#34; /&gt;
    
    
&lt;/figure&gt;
&lt;br /&gt;
This creature is capable of tremendous destruction due to it&amp;rsquo;s size, flight &lt;em&gt;(with the creature&amp;rsquo;s wings also generating hurricane strength winds)&lt;/em&gt; and possesses several breath weapons &lt;em&gt;(e.g., heat and energy)&lt;/em&gt;.&lt;/p&gt;

&lt;p&gt;What am I talking about here?  Maybe it&amp;rsquo;s &lt;a href=&#34;http://en.wikipedia.org/wiki/King_Ghidorah&#34;&gt;Monster Zero&lt;/a&gt; or &lt;a href=&#34;http://en.wikipedia.org/wiki/King_Ghidorah&#34;&gt;King Ghidorah&lt;/a&gt; as it&amp;rsquo;s sometimes known.  No it&amp;rsquo;s &lt;a href=&#34;http://msdn.microsoft.com/en-us/library/hh228603.aspx&#34;&gt;TPL Dataflow&lt;/a&gt;!  &lt;!-- more --&gt;&lt;/p&gt;

&lt;p&gt;Yeah, yeah, I have a penchant for being over dramatic and writing quirky intros.  This post is about &lt;a href=&#34;http://msdn.microsoft.com/en-us/library/hh228603.aspx&#34;&gt;TPL Dataflow&lt;/a&gt; otherwise known as TDF.  I have blogged about this before in my &lt;a href=&#34;http://7sharpnine.com/2012/01/22/2012-01-22-fsharp-dataflow-agents-i/&#34;&gt;TDF agent series&lt;/a&gt; but I thought it might be worth while returning to it while on the subject of monsters.&lt;/p&gt;

&lt;p&gt;The purpose of these posts is not to put you of using these libraries but to give you feel of how they might be used from an F# viewpoint.  Its not always easy to use these libraries even from C#, so jumping to another paradigm can sometimes leave you feeling bewildered, frustrated and lost.&lt;/p&gt;

&lt;h3 id=&#34;what-is-tpl-dataflow&#34;&gt;What is TPL Dataflow&lt;/h3&gt;

&lt;p&gt;According to MSDN here&amp;rsquo;s the description of TPL dataflow:&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;The Task Parallel Library (TPL) provides dataflow components to help increase the robustness of concurrency-enabled applications. These dataflow components are collectively referred to as the TPL Dataflow Library. This dataflow model promotes actor-based programming by providing in-process message passing for coarse-grained dataflow and pipelining tasks.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;Checkout the &lt;a href=&#34;http://msdn.microsoft.com/en-us/library/hh228603.aspx&#34;&gt;MSDN&lt;/a&gt; if you want to read a more in depth outline on TDF, or you could also refer to my &lt;a href=&#34;http://7sharpnine.com/2012/01/22/2012-01-22-fsharp-dataflow-agents-i/&#34;&gt;earlier posts&lt;/a&gt; too.&lt;/p&gt;

&lt;h3 id=&#34;sample-problem&#34;&gt;Sample problem&lt;/h3&gt;

&lt;p&gt;Here&amp;rsquo;s a sample problem:  We have two documents that we want to use to collate a list of word occurrences, we then want to collect the results from both documents and print out the combined results.&lt;/p&gt;

&lt;p&gt;Although we&amp;rsquo;re using TDF to solve this problem, we could of also used F# agents, Reactive Extensions, Linq, TPL, or a mix of all of those.&lt;/p&gt;

&lt;p&gt;We will stick to using the &lt;a href=&#34;http://msdn.microsoft.com/en-us/library/dd233175.aspx&#34;&gt;F# REPL&lt;/a&gt; for this post as it&amp;rsquo;s fairly simple example and allows for a bit of interactivity.  Lets start by adding a reference, open up a few namespace&amp;rsquo;s and read a couple of text files in.  In this instance we&amp;rsquo;re going to use &lt;a href=&#34;http://en.wikipedia.org/wiki/Jane_Eyre&#34;&gt;Jane Eyre&lt;/a&gt; by Charlotte Bronte, and &lt;a href=&#34;http://en.wikipedia.org/wiki/Algernon_Blackwood#Novels&#34;&gt;The Wendigo&lt;/a&gt; by Algernon Blackwood, for no reason other than they were free to download and use as samples.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-fsharp&#34;&gt;#r &amp;quot;System.Threading.Tasks.Dataflow&amp;quot;
open System
open System.IO
open System.Threading.Tasks.Dataflow

let janeEyre = File.ReadAllText(@&amp;quot;Jane Eyre [Charlotte Bronte].txt&amp;quot;)
let theWendigo = File.ReadAllText(@&amp;quot;The Wendigo [Algernon Blackwood].txt&amp;quot;)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The next thing we need to think about is how to count the words.  Let&amp;rsquo;s create a recursive function that counts each occurrence of a passed in word against the full text.  The &lt;code&gt;wordCount&lt;/code&gt; function recurses until &lt;code&gt;-1&lt;/code&gt; is returned from the &lt;code&gt;IndexOf&lt;/code&gt; function.  Before you argue about memory allocation, laziness etc, we&amp;rsquo;re not interested in that at the moment, we just want to solve the problem at hand.  It would be fairly easy to split the input into a lazy sequence and iterate over it so we only keep a single line in memory.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-fsharp&#34;&gt;let wordCount (text: String) word =
   let rec loop position count =
      match text.IndexOf(word, position, StringComparison.InvariantCultureIgnoreCase) with
      | -1 -&amp;gt; count
      | i -&amp;gt;  loop (i + word.Length) (count + 1)
   loop 0 0
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Now we can start to create some TDF blocks, we shall create a &lt;a href=&#34;http://msdn.microsoft.com/en-us/library/hh160447.aspx&#34;&gt;BroadcastBlock&lt;/a&gt; first.&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;A BroadcastBlock provides a buffer for storing at most one element at time, overwriting each message with the next as it arrives.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;Messages are broadcast to all linked targets, all of which may consume a clone of the message.&lt;/p&gt;

&lt;p&gt;The lambda expression passed into the &lt;code&gt;BroadcastBlock&lt;/code&gt; is it&amp;rsquo;s clone function, in this case we will just use the string that is passed in: &lt;code&gt;fun s -&amp;gt; s&lt;/code&gt;.  We will be using the &lt;code&gt;BroadcastBlock&lt;/code&gt; to send the same message to multiple destinations later on.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-fsharp&#34;&gt;let broadcast = BroadcastBlock(fun s -&amp;gt; s)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Now we will create a couple of &lt;a href=&#34;http://msdn.microsoft.com/en-us/library/hh194782.aspx&#34;&gt;TransformBlocks&lt;/a&gt;.&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;A TransformBlock provides a dataflow block that invokes a provided Func(T, TResult) delegate for every data element received.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;The &lt;code&gt;TransformBlock&lt;/code&gt; will accept a data element and transform it by invoking it&amp;rsquo;s transform function.  Here we will &lt;a href=&#34;http://msdn.microsoft.com/en-us/library/dd233229.aspx&#34;&gt;partially apply&lt;/a&gt; the &lt;code&gt;wordCount&lt;/code&gt; function by passing in the first parameter &lt;code&gt;text&lt;/code&gt;.  This means that whenever the &lt;code&gt;TransformBlock&lt;/code&gt; is passed data the &lt;code&gt;wordCount&lt;/code&gt; function will already have the &lt;code&gt;text&lt;/code&gt; parameter applied and will return the number of matches from the document.  The context of passed data here will be the word that we want to find.  We&amp;rsquo;ll create one for Jane Eyre and one for The Wendigo:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-fsharp&#34;&gt;let transformJaneEyre = TransformBlock(wordCount janeEyre)
let transformTheWendigo  = TransformBlock(wordCount theWendigo)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Now that we have created three blocks we need to think about linking them together.  You can do this with the &lt;code&gt;LinkTo&lt;/code&gt; method that every dataflow block has.  We could do that by calling the &lt;code&gt;LinkTo&lt;/code&gt; methods as usual like this:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-fsharp&#34;&gt;broadcast.LinkTo(transformJaneEyre) |&amp;gt; ignore
broadcast.LinkTo(transformTheWendigo) |&amp;gt; ignore
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;That seems a little awkward, especially as we&amp;rsquo;re not interested in the return parameter in this example, so instead we&amp;rsquo;re going to create a little function to make this a little bit easier for ourselves:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-fsharp&#34;&gt;let (--&amp;gt;) source target = DataflowBlock.LinkTo(source, target) |&amp;gt; ignore
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The &lt;code&gt;LinkTo&lt;/code&gt; method returns an &lt;code&gt;IDisposable&lt;/code&gt; that can be use to sever the link between the blocks that have just been joined.  There are also overloads of &lt;code&gt;LinkTo&lt;/code&gt; that allow you to specify a predicate.  There is also an overload that takes a &lt;code&gt;DataflowLinkOptions&lt;/code&gt; type which allows you to specify whether the new link is appended (&lt;code&gt;Append&lt;/code&gt;), the maximum message that can be passed before the block is unlinked (&lt;code&gt;MaxMessages&lt;/code&gt;), and finally and whether or not the completion of the former block is propagated to the latter (&lt;code&gt;PropagateCompletion&lt;/code&gt;).&lt;/p&gt;

&lt;p&gt;We can now use the &lt;code&gt;--&amp;gt;&lt;/code&gt; symbolic operator and use &lt;a href=&#34;http://msdn.microsoft.com/en-us/library/dd233204.aspx&#34;&gt;infix notation&lt;/a&gt; to link the blocks together.  Infix operators are expected to be placed between the two operands, which means we can define the links between the block like this:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-fsharp&#34;&gt;broadcast --&amp;gt; transformJaneEyre
broadcast --&amp;gt; transformTheWendigo
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Next we create a &lt;a href=&#34;http://msdn.microsoft.com/en-us/library/hh160286.aspx&#34;&gt;JoinBlock&lt;/a&gt;.&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;A JoinBlock provides a dataflow block that joins across multiple dataflow sources, which are not necessarily of the same type, waiting for one item to arrive for each type before they’re all released together as a tuple that contains one item per type.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;pre&gt;&lt;code class=&#34;language-fsharp&#34;&gt;let join = JoinBlock&amp;lt;_,_,_&amp;gt;()

broadcast           --&amp;gt; join.Target1
transformJaneEyre   --&amp;gt; join.Target2
transformTheWendigo --&amp;gt; join.Target3
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;We create the &lt;code&gt;JoinBlock&lt;/code&gt; then link the &lt;code&gt;broadcast&lt;/code&gt;, &lt;code&gt;transformJaneEyre&lt;/code&gt;, and &lt;code&gt;transformTheWendigo&lt;/code&gt; to it.  This means that the &lt;code&gt;JoinBlock&lt;/code&gt; will wait for data from &lt;strong&gt;all&lt;/strong&gt; three blocks before sending the data on as a tuple of the three values.&lt;/p&gt;

&lt;p&gt;Finally we create the last block which is an &lt;a href=&#34;http://msdn.microsoft.com/en-us/library/hh194684.aspx&#34;&gt;ActionBlock&lt;/a&gt;&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;An ActionBlock provides a dataflow block that invokes a provided Action(T) delegate for every data element received.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;pre&gt;&lt;code class=&#34;language-fsharp&#34;&gt;let writeOutput = 
    ActionBlock(fun(word:String, count1, count2) -&amp;gt; 
       Console.WriteLine(&amp;quot;Word: {0}, Jane Eyre: {1}, The Wendigo: {2}&amp;quot;, 
                         word.PadRight(10),
                         (string count1).PadLeft(3), 
                         (string count2).PadLeft(3) ) )
    
join --&amp;gt; writeOutput
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Right, that completes the hook up, now all that&amp;rsquo;s left is to test it.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-fsharp&#34;&gt;let words = [|&amp;quot;cat&amp;quot;;&amp;quot;cake&amp;quot;;&amp;quot;anything&amp;quot;;&amp;quot;laugh&amp;quot;;&amp;quot;breeze&amp;quot;;&amp;quot;hysterical&amp;quot;;&amp;quot;ball&amp;quot;;&amp;quot;them&amp;quot;;&amp;quot;home&amp;quot;;&amp;quot;bird&amp;quot;|]
for word in words do 
  broadcast.Post(word) |&amp;gt; ignore
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;If we execute this then we we get the following output:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;Word: cat       , Jane Eyre: 212, The Wendigo:  73
Word: cake      , Jane Eyre:  15, The Wendigo:   0
Word: anything  , Jane Eyre:  60, The Wendigo:  19
Word: laugh     , Jane Eyre:  68, The Wendigo:  17
Word: breeze    , Jane Eyre:  11, The Wendigo:   0
Word: hysterical, Jane Eyre:   1, The Wendigo:   1
Word: ball      , Jane Eyre:  11, The Wendigo:   1
Word: them      , Jane Eyre: 432, The Wendigo:  72
Word: home      , Jane Eyre:  90, The Wendigo:  11
Word: bird      , Jane Eyre:  35, The Wendigo:   0
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;summary&#34;&gt;Summary&lt;/h3&gt;

&lt;p&gt;From a conceptual viewpoint of view we&amp;rsquo;re creating a BroadcastBlock which connects to two TransformBlocks.  The two TransformBlocks are then connected to the JoinBlock along with the BroadcastBlock.  Finally, the JoinBlock is connected to the ActionBlock.&lt;/p&gt;

&lt;p&gt;This creates a mini network where you can simply post a message to the input of the dataflow network and it will propagate through the network.  As with Reactive Extensions marble diagrams and pipeline diagrams are a great way to visualise the process flow.&lt;/p&gt;


&lt;figure &gt;
    
        &lt;img src=&#34;https://lh5.googleusercontent.com/-r5TZAl6VERo/UbCwd4MXGTI/AAAAAAAABpg/MmQIb_0nwb8/w769-h218-no/Screen&amp;#43;Shot&amp;#43;2013-06-06&amp;#43;at&amp;#43;16.50.31.png&#34; /&gt;
    
    
&lt;/figure&gt;


&lt;p&gt;I hope that sheds a little bit of light on how a dataflow network can be created with TDF.  Extremely complex behaviour&amp;rsquo;s can be created by connecting up the simple dataflow building blocks, especially as the different block&amp;rsquo;s can run with multiple degrees of parallelism an also run asynchronously using &lt;code&gt;Task&amp;lt;T&amp;gt;&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;Until next time!&lt;/p&gt;

&lt;hr style=&#34;margin: 1em 0&#34;&gt;
&lt;h1 id=&#34;essential-listening&#34;&gt;Essential listening:&lt;/h1&gt;


&lt;div class=&#34;pure-g&#34;&gt;

  
  
  
  
  &lt;div class=&#34;&#34;&gt;
    &lt;div style=&#34;width: 20%; float: left;padding: 0 .2em .2em 0&#34;&gt;
        &lt;figure style=&#34;margin: 0&#34;&gt;
            &lt;img src=&#34;http://upload.wikimedia.org/wikipedia/en/4/43/AIC_Unplugged.jpg&#34; style=&#34;margin: 0&#34;
                 alt=&#34;Alice In Chains - Unplugged&#34; /&gt;
            &lt;figcaption&gt;
                &lt;h6&gt;Alice In Chains - Unplugged&lt;/h4&gt;
            &lt;/figcaption&gt;
        &lt;/figure&gt;
    &lt;/div&gt;
  &lt;/div&gt;
  

  
  
  
  
  &lt;div class=&#34;&#34;&gt;
    &lt;div style=&#34;width: 20%; float: left;padding: 0 .2em .2em 0&#34;&gt;
        &lt;figure style=&#34;margin: 0&#34;&gt;
            &lt;img src=&#34;http://upload.wikimedia.org/wikipedia/en/6/64/MeteoraLP.jpg&#34; style=&#34;margin: 0&#34;
                 alt=&#34;Linkin Park - Meteora&#34; /&gt;
            &lt;figcaption&gt;
                &lt;h6&gt;Linkin Park - Meteora&lt;/h4&gt;
            &lt;/figcaption&gt;
        &lt;/figure&gt;
    &lt;/div&gt;
  &lt;/div&gt;
  

  
  
  
  
  &lt;div class=&#34;&#34;&gt;
    &lt;div style=&#34;width: 20%; float: left;padding: 0 .2em .2em 0&#34;&gt;
        &lt;figure style=&#34;margin: 0&#34;&gt;
            &lt;img src=&#34;http://upload.wikimedia.org/wikipedia/en/4/44/Soilscars.jpg&#34; style=&#34;margin: 0&#34;
                 alt=&#34;Soil - Scars&#34; /&gt;
            &lt;figcaption&gt;
                &lt;h6&gt;Soil - Scars&lt;/h4&gt;
            &lt;/figcaption&gt;
        &lt;/figure&gt;
    &lt;/div&gt;
  &lt;/div&gt;
  

&lt;/div&gt;




</description>
    </item>
    
    <item>
      <title>Back to the Primitive II</title>
      <link>http://7sharpnine.com/2012/04/22/2012-04-22-back-to-the-primitive-ii/</link>
      <pubDate>Sun, 22 Apr 2012 00:00:00 +0000</pubDate>
      
      <guid>http://7sharpnine.com/2012/04/22/2012-04-22-back-to-the-primitive-ii/</guid>
      <description>

&lt;p&gt;In the last post I discussed an asynchronous version of the &lt;code&gt;ManualResetEvent&lt;/code&gt; and as promised this time we will be looking at an
 asynchronous version of the &lt;code&gt;AutoResetEvent&lt;/code&gt;.  I&amp;rsquo;m using &lt;a href=&#34;http://blogs.msdn.com/b/pfxteam/archive/2012/02/11/10266923.aspx&#34;&gt;Stephen Toubs post&lt;/a&gt;
as reference and we will be building a version that is functional in style that maps straight into asynchronous work flows without and conversion
or adaptors.&lt;/p&gt;

&lt;h3 id=&#34;what-is-an-autoresetevent&#34;&gt;What is an AutoResetEvent?&lt;/h3&gt;

&lt;p&gt;An &lt;code&gt;AutoResetEvent&lt;/code&gt; can be described as a turnstile mechanism, it lets a single waiting person through before re-latching
waiting for the next signal.  This is opposed to a &lt;code&gt;ManualResetEvent&lt;/code&gt; which functions like an ordinary gate. Calling Set opens
the gate, allowing any number of threads that are waiting to be let through. Calling Reset closes the gate.&lt;/p&gt;

&lt;h3 id=&#34;asyncautoresetevent&#34;&gt;AsyncAutoResetEvent&lt;/h3&gt;

&lt;p&gt;First of all here is the shape of the type that we will be building:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;type AsyncAutoResetEvent =
    new : ?reusethread:bool -&amp;gt; AsyncAutoResetEvent
    member Set : unit -&amp;gt; unit
    member WaitAsync : unit -&amp;gt; Async&amp;lt;bool&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Fairly simple: implied constructor, &lt;code&gt;Set&lt;/code&gt; and &lt;code&gt;WaitAsync&lt;/code&gt; members.&lt;/p&gt;

&lt;h3 id=&#34;implied-constructor&#34;&gt;Implied Constructor&lt;/h3&gt;

&lt;p&gt;Thinking about this logically we may need the following items:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;A queue mechanism to store asynchronous waiters - &lt;code&gt;let mutable awaits = Queue&amp;lt;_&amp;gt;()&lt;/code&gt;.&lt;/li&gt;
&lt;li&gt;A way of knowing if a signal has been made in the absence of any waiters - &lt;code&gt;let mutable signalled = false&lt;/code&gt;.&lt;/li&gt;
&lt;li&gt;We can also declare a short-circuit asynchronous workflow for the situation that &lt;code&gt;Set()&lt;/code&gt; is called before &lt;code&gt;WaitAsync()&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;let completed = async.Return true&lt;/code&gt;.  This will save us constructing an &lt;code&gt;AsyncResultCell&amp;lt;_&amp;gt;&lt;/code&gt; and going though the
rest of the asynchronous mechanism.&lt;br /&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Also notice that an optional parameter called &lt;code&gt;reusethread&lt;/code&gt; is defined, we use the &lt;code&gt;?&lt;/code&gt; prefix when defining it to make it
optional.  We then make use of the &lt;code&gt;defaultArg&lt;/code&gt; function to give it a default value of false if a one is not passed in.  This
will be used in the &lt;code&gt;Set&lt;/code&gt; operation to determine if the code will run on the same thread or a thread in the ThreadPool.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;open System
open System.Threading
open System.Collections.Generic
 
    type AsyncAutoResetEvent(?reusethread) =
		let mutable awaits = Queue&amp;lt;_&amp;gt;()
		let mutable signalled = false
        let completed = async.Return true
        let reuseThread = defaultArg reusethread false
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;waitasync&#34;&gt;WaitAsync()&lt;/h3&gt;

&lt;p&gt;The first step is to use  a locking construct to control access to the mutable queue &lt;code&gt;awaits&lt;/code&gt;.  Inside this lock we
check to see if &lt;code&gt;signalled&lt;/code&gt; is true and if so we reset it to false and return our pre-built &lt;code&gt;completed&lt;/code&gt; asynchronous workflow.  If
signalled is false then we create a new &lt;code&gt;AsyncResultCell&amp;lt;_&amp;gt;&lt;/code&gt; and add it to the queue then return the &lt;code&gt;AsyncResult&lt;/code&gt; to the caller.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;        member x.WaitAsync() =
            lock awaits (fun () -&amp;gt;
                if signalled then
                    signalled &amp;lt;- false
                    completed
                else
                    let are = AsyncResultCell&amp;lt;_&amp;gt;()
                    awaits.Enqueue are
                    are.AsyncResult)
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;set&#34;&gt;Set()&lt;/h3&gt;

&lt;p&gt;We first declare a function called &lt;code&gt;getWaiter()&lt;/code&gt;, we use this function to return an &lt;a href=&#34;http://msdn.microsoft.com/en-us/library/dd233245.aspx&#34;&gt;option type&lt;/a&gt;
 that is either &lt;code&gt;Some AsyncResultCell&amp;lt;bool&amp;gt;&lt;/code&gt; or &lt;code&gt;None&lt;/code&gt;.  We use the lock function to control access to the mutable queue &lt;code&gt;lock awaits&lt;/code&gt;.  Once
inside the lock we use pattern matching to capture &lt;code&gt;awaits.Count&lt;/code&gt; and &lt;code&gt;signalled&lt;/code&gt;:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;The first pattern match &lt;code&gt;(x,_)&lt;/code&gt; checks if there are any waiters (&lt;code&gt;awaits.Count &amp;gt; 0&lt;/code&gt;) and then dequeues an &lt;code&gt;AsyncResultCell&amp;lt;bool&amp;gt;&lt;/code&gt; from the
queue and returns it within an option type: &lt;code&gt;Some &amp;lt;| awaits.Dequeue()&lt;/code&gt;.&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;The second pattern match &lt;code&gt;(_,y)&lt;/code&gt; checks whether &lt;code&gt;signalled&lt;/code&gt; is set to false before setting its value to true.  This causes next &lt;code&gt;WaitAsync()&lt;/code&gt;
caller to get the short-circuited value &lt;code&gt;completed&lt;/code&gt;.  This means that an &lt;code&gt;AsyncResultCell&amp;lt;bool&amp;gt;&lt;/code&gt; does not need to be created and go though the
whole async mechanism.  We then return &lt;code&gt;None&lt;/code&gt; as there is no waiter to be notified.&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;The final pattern match &lt;code&gt;(_,_)&lt;/code&gt; is used when there are no waiting callers and &lt;code&gt;signalled&lt;/code&gt; has already being set, there is simply nothing to do in
this situation so we return &lt;code&gt;None&lt;/code&gt;.&lt;br /&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;We use the &lt;code&gt;getWaiter()&lt;/code&gt; function via pattern match.  If we have a result i.e. Some AsyncResultCell&lt;bool&gt; then we call &lt;code&gt;RegisterResult&lt;/code&gt;
passing in &lt;code&gt;AsyncOK(true)&lt;/code&gt; to indicate a completion.  Notice that we also pass in the &lt;code&gt;reuseThread&lt;/code&gt; boolean that was declared as part of the
constructor.  If &lt;code&gt;reuseThread&lt;/code&gt; is true then the notification to the waiter happens &lt;strong&gt;synchronously&lt;/strong&gt; use this with care!  Personally I would stick
with the default of false to ensure that the operation is completed via the thread pool, unless you have a performance critical reason and the
waiting code that executes is &lt;strong&gt;very fast&lt;/strong&gt;.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;		member x.Set() =
		    let getWaiter()=
		        lock awaits (fun () -&amp;gt;
		            match (awaits.Count, signalled) with
		            | (x,_) when x &amp;gt; 0 -&amp;gt; Some &amp;lt;| awaits.Dequeue()
		            | (_,y) when not y -&amp;gt; signalled &amp;lt;- true;None
		            | (_,_) -&amp;gt; None)
		    match getWaiter() with
		    | Some a -&amp;gt; a.RegisterResult(AsyncOk(true), reuseThread)
		    | None _ -&amp;gt; ()
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The reason for using the &lt;code&gt;getWaiter()&lt;/code&gt; function is to separate the locking function away from the notification, if &lt;code&gt;RegisterResult&lt;/code&gt;
was called within the lock and &lt;code&gt;reuseThread&lt;/code&gt; was true then the awaiting function would be called synchronously within the lock which
would not be a very good situation to be in.&lt;/p&gt;

&lt;p&gt;So there we have it, I could take this series further and convert the other primitives that Stephen Toub describes but there should be
enough information in these two posts to set you on your way.  If anyone would like me to complete the series then let me know.  I
may well finish them off and post them on GitHub in the future, time permitting.&lt;/p&gt;

&lt;p&gt;Thanks for tuning in, until next time&amp;hellip;&lt;/p&gt;

&lt;hr style=&#34;margin: 1em 0&#34;&gt;
&lt;h1 id=&#34;essential-listening&#34;&gt;Essential listening:&lt;/h1&gt;


&lt;div class=&#34;pure-g&#34;&gt;

  
  
  
  
  &lt;div class=&#34;&#34;&gt;
    &lt;div style=&#34;width: 20%; float: left;padding: 0 .2em .2em 0&#34;&gt;
        &lt;figure style=&#34;margin: 0&#34;&gt;
            &lt;img src=&#34;http://upload.wikimedia.org/wikipedia/en/a/a8/CowboysFromHell.jpg&#34; style=&#34;margin: 0&#34;
                 alt=&#34;Pantera - Cowboys From Hell&#34; /&gt;
            &lt;figcaption&gt;
                &lt;h6&gt;Pantera - Cowboys From Hell&lt;/h4&gt;
            &lt;/figcaption&gt;
        &lt;/figure&gt;
    &lt;/div&gt;
  &lt;/div&gt;
  

  
  
  
  
  &lt;div class=&#34;&#34;&gt;
    &lt;div style=&#34;width: 20%; float: left;padding: 0 .2em .2em 0&#34;&gt;
        &lt;figure style=&#34;margin: 0&#34;&gt;
            &lt;img src=&#34;http://upload.wikimedia.org/wikipedia/en/0/09/Cacophony_-_1988_-_Go_Off%21.jpg&#34; style=&#34;margin: 0&#34;
                 alt=&#34;Cacophony - Go Off&#34; /&gt;
            &lt;figcaption&gt;
                &lt;h6&gt;Cacophony - Go Off&lt;/h4&gt;
            &lt;/figcaption&gt;
        &lt;/figure&gt;
    &lt;/div&gt;
  &lt;/div&gt;
  

&lt;/div&gt;




</description>
    </item>
    
    <item>
      <title>Back to the Primitive</title>
      <link>http://7sharpnine.com/2012/04/12/2012-04-12-back-to-the-primitive/</link>
      <pubDate>Thu, 12 Apr 2012 00:00:00 +0000</pubDate>
      
      <guid>http://7sharpnine.com/2012/04/12/2012-04-12-back-to-the-primitive/</guid>
      <description>&lt;p&gt;In this post we are going &lt;strong&gt;back to the primitive&lt;/strong&gt;.  No it&amp;rsquo;s not about the same named song by Soulfly, &lt;em&gt;(which incidentally does contains F# notes)&lt;/em&gt; but a return to thread synchronisation primitives and their asynchronous counterparts.&lt;/p&gt;

&lt;p&gt;We are going to be looking at an asynchronous version of the &lt;a href=&#34;http://msdn.microsoft.com/en-us/library/system.threading.manualresetevent.aspx&#34;&gt;ManualResetEvent&lt;/a&gt;.  This was
recently covered by Stephen Toub on the &lt;a href=&#34;http://blogs.msdn.com/b/pfxteam/archive/2012/02/11/10266920.aspx&#34;&gt;pfx team blog&lt;/a&gt;.  We will be taking a slightly different view on
this as we will be using asynchronous workflows which will give us nice idiomatic usage within F#.&lt;/p&gt;

&lt;p&gt;First lets look of the shape of the type that Stephen defined:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;public class AsyncManualResetEvent 
{ 
    public Task WaitAsync(); 
    public void Set(); 
    public void Reset(); 
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Now this can be used from within F# by using the &lt;code&gt;Async.AwaitTask&lt;/code&gt; function from the Async module but this is like wrapping one asynchronous paradigm with another, and
although this does work, what if you want to avoid the overhead of wrappers and stay strictly within async workflows.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-fsharp&#34;&gt;type asyncManualResetEvent() =
    member x.WaitAsync() : unit -&amp;gt; Async&amp;lt;bool&amp;gt;
    member x.Set() : unit -&amp;gt; unit
    member x.Reset() : unit -&amp;gt; unit
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;That&amp;rsquo;s what we want to see!  I don&amp;rsquo;t want to get into the details of the description of how the C# version works as Stephen does a very good job of that already.  What I will explain though is how we essentially do the same thing while staying with the realm of functional programming.  As we are getting into the lower lever details no doubt we will have to start relying on some low level locking primitives like Monitors, Semaphores, and Interlocked operations, even the F# core libraries have a
cornucopia of those.&lt;/p&gt;

&lt;p&gt;Lets look at the first member &lt;code&gt;WaitAsync()&lt;/code&gt;.  The first step is to create a something to store the result of the operation, all we will just be storing and returning
asynchronously is a boolean to indicate that the wait handle has been set.  To do this we use one of the types from the
&lt;a href=&#34;http://fsharppowerpack.codeplex.com/&#34;&gt;F# power pack&lt;/a&gt; &lt;code&gt;AsyncResultCell&amp;lt;&#39;T&amp;gt;&lt;/code&gt;.  I think that such a type should of been exposed from the F# core libraries but it was
omitted for some reason.  There is a type called &lt;code&gt;ResultCell&amp;lt;&#39;T&amp;gt;&lt;/code&gt; with much the same functionality in the FSharp.Core.Control namespace but it is marked internal so
it&amp;rsquo;s not available for our use.&lt;/p&gt;

&lt;p&gt;We declare a &lt;a href=&#34;http://msdn.microsoft.com/en-us/library/dd233186.aspx&#34;&gt;reference cell&lt;/a&gt; of type &lt;code&gt;AsyncResultCell&amp;lt;&#39;T&amp;gt;&lt;/code&gt; and then create the &lt;code&gt;WaitAsync()&lt;/code&gt; member, all we have
to do is dereference the value of the reference cell with &lt;code&gt;!&lt;/code&gt; and call its &lt;code&gt;AsyncResult&lt;/code&gt; member, this gives us an &lt;code&gt;Async&amp;lt;bool&amp;gt;&lt;/code&gt; which we can easily use in an asynchronous workflow.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-fsharp&#34;&gt;type asyncManualResetEvent() =
    let aResCell = ref &amp;lt;| AsyncResultCell&amp;lt;_&amp;gt;()

    member x.WaitAsync() = (!aResCell).AsyncResult
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The next bit is fairly simple too.  All we need to do is dereference the value of the reference cell, and invoke the &lt;code&gt;RegisterResult&lt;/code&gt; member by passing in a value of
 &lt;code&gt;AsyncOk(true)&lt;/code&gt;.  The boolean value of true will be used by the type inference system to constrain the value of the &lt;code&gt;Async&amp;lt;_&amp;gt;&lt;/code&gt; returned from &lt;code&gt;WaitAsync&lt;/code&gt;.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-fsharp&#34;&gt;    member x.Set() = (!aResCell).RegisterResult(AsyncOk(true))
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The last part is the most complex &lt;em&gt;(as usual)&lt;/em&gt;.  Here we create a recursive function called &lt;code&gt;swap&lt;/code&gt; that will try to exchange the &lt;code&gt;AsyncResultCell&amp;lt;&#39;T&amp;gt;&lt;/code&gt; for a new
one.  We dereference the reference cell to &lt;code&gt;currentValue&lt;/code&gt;, then we use a CAS (Compare And Swap) operation to compare the &lt;code&gt;aResCell&lt;/code&gt; with &lt;code&gt;currentValue&lt;/code&gt; and if they
are equal &lt;code&gt;newVal&lt;/code&gt; will replace &lt;code&gt;aResCell&lt;/code&gt;.  On the next line if the result of the CAS operation means that &lt;code&gt;result&lt;/code&gt; and &lt;code&gt;currentValue&lt;/code&gt; are equal then we are finished,
otherwise we spin the current thread for 20 cycles using &lt;code&gt;Thread.SpinWait 20&lt;/code&gt; before retrying the operation via recursion &lt;code&gt;swap newVal&lt;/code&gt;.  This will be a lot less
expensive than switching to user or kernel mode locking, and the period of contention between threads should be very small.  Finally the swap operation is started
by passing in a new &lt;code&gt;AsyncResultCell&amp;lt;&#39;T&amp;gt;&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;There are various other methods we could of used, for instance we could of wrapped a &lt;code&gt;ManualResetEvent&lt;/code&gt; with a call to &lt;code&gt;Async.AwaitWaitHandle&lt;/code&gt;, although this
would of meant using the kernel mode locking of the &lt;code&gt;ManualResetEvent&lt;/code&gt; which is a bit more expensive.&lt;/p&gt;

&lt;p&gt;In Stephen Toub&amp;rsquo;s post he mentions Task&amp;rsquo;s being orphaned due to the &lt;code&gt;Reset()&lt;/code&gt; method being called before the &lt;code&gt;Task&amp;lt;&#39;T&amp;gt;&lt;/code&gt; has been completed, that shouldn&amp;rsquo;t happen in our
implementation due the the closures being stored internally for completion by the async infrastructure.  Heres a quick test harness to make sure everything works as expected anyway.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-fsharp&#34;&gt;    member x.Reset() =
        let rec swap newVal = 
            let currentValue = !aResCell
            let result = Interlocked.CompareExchange&amp;lt;_&amp;gt;(aResCell, newVal, currentValue)
            if obj.ReferenceEquals(result, currentValue) then ()
            else Thread.SpinWait 20
                 swap newVal
        swap &amp;lt;| AsyncResultCell&amp;lt;_&amp;gt;()
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&#34;language-fsharp&#34;&gt;let amre = asyncManualResetEvent()
let x = async{let! x = amre.WaitAsync()
              Console.WriteLine(&amp;quot;First signalled&amp;quot;)}

let y = async{let! x = amre.WaitAsync()
             Console.WriteLine(&amp;quot;Second signalled&amp;quot;)}

let z = async{let! x = amre.WaitAsync()
              Console.WriteLine(&amp;quot;Third signalled&amp;quot;)}
//start async workflows x and y
Async.Start x
Async.Start y

//reset the asyncManualResetEvent, this will test whether the async workflows x and y 
// are orphaned due to the AsyncResultCell being recycled.
amre.Reset()

//now start the async z
Async.Start z

//we set a single time, this should result in the three async workflows completing
amre.Set()

Console.ReadLine() |&amp;gt; ignore
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Here we can see everything works out as we expected:&lt;/p&gt;


&lt;figure &gt;
    
        &lt;img src=&#34;https://lh6.googleusercontent.com/-NYIKC5Gaahs/T4YAQGtP9RI/AAAAAAAABR8/_cTOriC1_Fw/amre.png&#34; /&gt;
    
    
&lt;/figure&gt;


&lt;p&gt;Thats all there is too it, next time I will be exploring an asyncAutoResetEvent in much the same vein.&lt;/p&gt;

&lt;p&gt;Until next time&amp;hellip;&lt;/p&gt;

&lt;hr style=&#34;margin: 1em 0&#34;&gt;
&lt;h1 id=&#34;essential-listening&#34;&gt;Essential listening:&lt;/h1&gt;


&lt;div class=&#34;pure-g&#34;&gt;

  
  
  
  
  &lt;div class=&#34;&#34;&gt;
    &lt;div style=&#34;width: 20%; float: left;padding: 0 .2em .2em 0&#34;&gt;
        &lt;figure style=&#34;margin: 0&#34;&gt;
            &lt;img src=&#34;http://upload.wikimedia.org/wikipedia/en/f/fb/Zeitgeist_cover.png&#34; style=&#34;margin: 0&#34;
                 alt=&#34;Smashing Pumpkins Zeitgeist&#34; /&gt;
            &lt;figcaption&gt;
                &lt;h6&gt;Smashing Pumpkins Zeitgeist&lt;/h4&gt;
            &lt;/figcaption&gt;
        &lt;/figure&gt;
    &lt;/div&gt;
  &lt;/div&gt;
  

  
  
  
  
  &lt;div class=&#34;&#34;&gt;
    &lt;div style=&#34;width: 20%; float: left;padding: 0 .2em .2em 0&#34;&gt;
        &lt;figure style=&#34;margin: 0&#34;&gt;
            &lt;img src=&#34;http://upload.wikimedia.org/wikipedia/en/3/34/Primitive.png&#34; style=&#34;margin: 0&#34;
                 alt=&#34;Soulfly Primitive&#34; /&gt;
            &lt;figcaption&gt;
                &lt;h6&gt;Soulfly Primitive&lt;/h4&gt;
            &lt;/figcaption&gt;
        &lt;/figure&gt;
    &lt;/div&gt;
  &lt;/div&gt;
  

  
  
  
  
  &lt;div class=&#34;&#34;&gt;
    &lt;div style=&#34;width: 20%; float: left;padding: 0 .2em .2em 0&#34;&gt;
        &lt;figure style=&#34;margin: 0&#34;&gt;
            &lt;img src=&#34;http://upload.wikimedia.org/wikipedia/en/0/0d/FooFighters-FooFighters.jpg&#34; style=&#34;margin: 0&#34;
                 alt=&#34;FooFighters&#34; /&gt;
            &lt;figcaption&gt;
                &lt;h6&gt;FooFighters&lt;/h4&gt;
            &lt;/figcaption&gt;
        &lt;/figure&gt;
    &lt;/div&gt;
  &lt;/div&gt;
  

&lt;/div&gt;




</description>
    </item>
    
    <item>
      <title>Pipeline processing 3</title>
      <link>http://7sharpnine.com/2011/04/04/2011-04-04-pipeline-processing-3/</link>
      <pubDate>Mon, 04 Apr 2011 00:00:00 +0000</pubDate>
      
      <guid>http://7sharpnine.com/2011/04/04/2011-04-04-pipeline-processing-3/</guid>
      <description>

&lt;p&gt;Ok so I have been offline for a while now, what with starting a new financial contract in London and not having any broadband access for a while.  I have
been working on something, honest!&lt;/p&gt;

&lt;p&gt;Since the last post I have been reflecting on the pipeline design and it had a distinct object orientated feel to it that I wasnt happy with, so I have
amended the structure of the code and come up with the following which simplifies in some areas and expands in others&amp;hellip;&lt;!-- more --&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-fsharp&#34;&gt;module Pipeline
  open System.Collections.Concurrent

  [&amp;lt;Interface&amp;gt;]
  type IPipelineInput&amp;lt;&#39;a&amp;gt; =
    abstract Insert: &#39;a -&amp;gt; unit
 
  [&amp;lt;Interface&amp;gt;]
  type IPipelineConnection&amp;lt;&#39;a&amp;gt; =
    abstract Attach: IPipelineInput&amp;lt;&#39;a&amp;gt; -&amp;gt; unit
    abstract Detach: IPipelineInput&amp;lt;&#39;a&amp;gt; -&amp;gt; unit
 
  [&amp;lt;Interface&amp;gt;]
  type IPipeline&amp;lt;&#39;a,&#39;b&amp;gt; =
    inherit IPipelineConnection&amp;lt;&#39;b&amp;gt;
    inherit IPipelineInput&amp;lt;&#39;a&amp;gt;

  type PipelineStage&amp;lt;&#39;a,&#39;b&amp;gt;(processor, router: seq&amp;lt;IPipelineInput&amp;lt;&#39;b&amp;gt;&amp;gt; * &#39;b -&amp;gt; seq&amp;lt;IPipelineInput&amp;lt;&#39;b&amp;gt;&amp;gt;, ?overflow, ?capacity, ?blockingTime) =
    let processor = processor
    let router = router  
    let createBlockingCollection x =
        match x with
        | Some c -&amp;gt; new BlockingCollection&amp;lt;&#39;a&amp;gt;(c:int)
        | None -&amp;gt; new BlockingCollection&amp;lt;&#39;a&amp;gt;()  
    let buffer = createBlockingCollection capacity
    let routes = ref List.empty&amp;lt;IPipelineInput&amp;lt;&#39;b&amp;gt;&amp;gt;
    let queuedOrRunning = ref false  
    let blocktime =
      match blockingTime with
      | Some b -&amp;gt; b
      | None -&amp;gt; 250  
    let consumerLoop = async {
      try
        let rec loop()=
          let item = ref Unchecked.defaultof&amp;lt;_&amp;gt;
          let taken = buffer.TryTake(item, blocktime)
          if taken then
              do !item
              |&amp;gt; processor
              |&amp;gt; Seq.iter (fun z -&amp;gt;
              (match !routes with
               | [] -&amp;gt; ()(*we cant route with no routes*)
               | _ -&amp;gt; do router (!routes, z) |&amp;gt; Seq.iter (fun r -&amp;gt; (r.Insert z ))) )
              loop()
          else ()(*exit nothing to consume in time limit*)
        loop()
      with e -&amp;gt; raise e
      }  
    member this.ClearRoutes = routes := []  
    interface IPipelineInput&amp;lt;&#39;a&amp;gt; with
      member this.Insert payload =
        let added = buffer.TryAdd(payload, blocktime)
        if added then
          //begin consumer loop
          if not !queuedOrRunning then
            lock consumerLoop (fun() -&amp;gt;
            Async.Start(async {do! consumerLoop })
            queuedOrRunning := true)
          else()
        else
          //overflow here if function passed
          match overflow with
          | Some t -&amp;gt;  payload |&amp;gt; overflow.Value
          | None -&amp;gt; ()  
    interface IPipelineConnection&amp;lt;&#39;b&amp;gt; with
      member this.Attach (stage) =
        let current = !routes
        routes := stage :: current  
      member this.Detach (stage) =
        let current = !routes
        routes := List.filter (fun el -&amp;gt; el &amp;lt;&amp;gt; stage) current  
    static member Attach (a:IPipelineConnection&amp;lt;_&amp;gt;) (b) =
      a.Attach b ;b  
    static member Detach (a: IPipelineConnection&amp;lt;_&amp;gt;) (b) =
      a.Detach b ;a  
    static member (++&amp;gt;) (a:IPipelineConnection&amp;lt;_&amp;gt;, b) =
      a.Attach (b) ;b  
    static member (--&amp;gt;) (a:IPipelineConnection&amp;lt;_&amp;gt;, b) =
      a.Detach b ;a  
    static member (&amp;lt;&amp;lt;--) (a:IPipelineInput&amp;lt;_&amp;gt;, b:&#39;b) =
      a.Insert b  
    static member (--&amp;gt;&amp;gt;) (b,a:IPipelineInput&amp;lt;_&amp;gt;) =
      a.Insert b
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;summary&#34;&gt;Summary.&lt;/h3&gt;

&lt;p&gt;I only want to summarise the code as I think its fairly straight forward to
see whats going on.&lt;/p&gt;

&lt;h3 id=&#34;interfaces&#34;&gt;Interfaces&lt;/h3&gt;

&lt;p&gt;We have two main interfaces defined &lt;strong&gt;IPipelineInput&amp;lt;&amp;lsquo;a&amp;gt;&lt;/strong&gt; and
**IPipelineConnection&amp;lt;&amp;lsquo;a&amp;gt;, **as you can tell by the names they are involved
with connecting the pipeline together and getting information into the
pipeline.  Those two interfaces are merged together in the IPipeline&amp;lt;&amp;lsquo;a, &amp;lsquo;b&amp;gt;
interface, this keeps a nice separation between connecting and inserting into
the pipeline, it also makes implementation easier and allows the interfaces to
be implemented in other areas of code that need to talk to or connect to a
pipeline.&lt;/p&gt;

&lt;h3 id=&#34;internals&#34;&gt;Internals&lt;/h3&gt;

&lt;p&gt;Inside the pipeline we have the bounded blocking queue which is implemented by
the BlockingCollection from TPL. This is used to store the pipeline payloads
that are waiting to be processed.&lt;/p&gt;

&lt;p&gt;The consumerLoop function is recursive and continually tries to take items
from the blocking collection processing and routing each one to the next
pipeline stage.&lt;/p&gt;

&lt;p&gt;The processor is a function that transforms from type &amp;lsquo;a to type &amp;lsquo;b.&lt;/p&gt;

&lt;p&gt;The router is a function that takes a sequence of IPipelineInput&amp;lt;&amp;lsquo;b&amp;gt; and also
the payload &amp;lsquo;b it returns a sequence of IPipelineInput&amp;lt;&amp;lsquo;b&amp;gt;.  What this
effectively means is that we can route by the connected stages (i.e. round
robin routing, multi-cast routing.)   Or we could route by payload contents
(i.e. if the payload contains a certain bytes sequence we could choose a
certain IPipelineInput&amp;lt;&amp;lsquo;b&amp;gt;.)&lt;/p&gt;

&lt;p&gt;Each item taken is passed to the processor and router via pipeline (&lt;strong&gt;|&amp;gt;&lt;/strong&gt;) and
Seq operations, recursively calling itself until an item can no longer be
retrieved from the buffer.&lt;/p&gt;

&lt;p&gt;The implementation of IPipelineInput&amp;lt;&amp;lsquo;a&amp;gt;.Insert is the counterpart to the
previous function. It first tries to inset the item into the bounded blocking
queue, if this cannot be done then the overflow function is called if one is
present. Next the async consumer loop is started if it is not already running.
The idea behind this is that by keeping the payload processing running on the
thread pool while there is work to do it will cut down on the number of
context switches between threads.  Once an item cannot be taken from the
bounding blocking queue the loop will exit.&lt;/p&gt;

&lt;p&gt;The rest of the code is pretty standard stuff and should be pretty easy to
follow.&lt;/p&gt;

&lt;p&gt;I also define some symbolic operations to simply constructing and using the
pipeline:&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;++&amp;gt;&lt;/strong&gt; Attaches the pipeline stage on the right hand side to the one on the left. &lt;strong&gt;&amp;ndash;&amp;gt;&lt;/strong&gt; Detaches the pipelinestage on the right from the one on the left. &lt;strong&gt;&amp;lt;&amp;lt;&amp;ndash;&lt;/strong&gt; Inserts a payload on the right into the pipeline stage on the left. &lt;strong&gt;&amp;ndash;&amp;gt;&amp;gt;&lt;/strong&gt; Inserts a payload on the left hand side into the pipeline stage on the right.&lt;br /&gt;
These help to keep a nice terse description of the pipeline, once things get a little more complex other operators may be required, the now discontinued
&lt;a href=&#34;http://msdn.microsoft.com/en-us/devlabs/dd795202.aspx&#34;&gt;Axiom&lt;/a&gt; had a whole host of these, its a pity Microsoft dropped the language.&lt;/p&gt;

&lt;h3 id=&#34;example&#34;&gt;Example&lt;/h3&gt;

&lt;p&gt;Heres a quick sample pipeline showing the pipeline in use:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Stage 1 takes a string and splits it based on the &amp;lsquo;,&amp;rsquo;.&lt;/li&gt;
&lt;li&gt;Stage 2 reverses each string.&lt;/li&gt;
&lt;li&gt;Stage 3 reverses the string back to the original.&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code class=&#34;language-fsharp&#34;&gt;module program
  open System
  open Pipeline  
  let consoleLock = new obj()  
  let split del n (s:string) =
    lock consoleLock (fun() -&amp;gt;
    do printfn &amp;quot;%A:before split %A&amp;quot; n s
    let split = s.Split([|del|])
    do printfn &amp;quot;%A:after: split into: %A&amp;quot; n split
    split |&amp;gt; Array.toSeq)  
  let reverse (s:string) =
    new string(s |&amp;gt; Seq.toArray |&amp;gt; Array.rev)  
  let oneToSingleton a b f=
    lock consoleLock (fun() -&amp;gt;
      printfn &amp;quot;%A:before reverse %A&amp;quot; a b
      let result = b |&amp;gt; f
      printfn &amp;quot;%A:after reverse %A&amp;quot; a result
      result|&amp;gt; Seq.singleton)  
  let OneToSeqRev a b = oneToSingleton a b reverse   
  ///Simply picks the first route
  let basicRouter( r, i) =
    let head = Seq.head r
    Seq.singleton head  
  let p1 = PipelineStage( split &#39;,&#39; &amp;quot;1&amp;quot;, basicRouter)
  let p2 = PipelineStage( OneToSeqRev &amp;quot;2&amp;quot;, basicRouter)
  let p3 = PipelineStage( OneToSeqRev &amp;quot;3&amp;quot;, basicRouter)  
  p1 ++&amp;gt; p2 ++&amp;gt; p3 |&amp;gt; ignore  
  let generateCircularSeq (lst:&#39;a list) =
    let rec next () =
      seq {
        for element in lst do
          yield element
        yield! next()
      }
    next()  
  for str in [&amp;quot;John,Paul,George,Ringo&amp;quot;]
  |&amp;gt; generateCircularSeq
  |&amp;gt; Seq.take 10
    do  str --&amp;gt;&amp;gt; p1  
  let x = Console.ReadKey()
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;As you can see the assignment of the pipeline stages is pretty simple as is the composition of multiple stages.  This was often one of the most difficult
areas while developing a similar pipelines in C# you could often find yourself with a few hundred lines of setup code which was a often a nightmare to debug
a few weeks later.&lt;/p&gt;

&lt;p&gt;Hopefully I have whet your appetite with pipelines, in a future article I will be combining socket operations with pipeline stages to produce a flexible
framework to deal with high throughput network applications.&lt;/p&gt;

&lt;p&gt;As always I appreciate any comments, until next time&amp;hellip;&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Pipeline processing 1</title>
      <link>http://7sharpnine.com/2011/02/01/2011-02-01-pipeline-processing-1/</link>
      <pubDate>Tue, 01 Feb 2011 00:00:00 +0000</pubDate>
      
      <guid>http://7sharpnine.com/2011/02/01/2011-02-01-pipeline-processing-1/</guid>
      <description>

&lt;h3 id=&#34;welcome-to-new-series-of-articles-on-pipeline-processing&#34;&gt;Welcome to new series of articles on pipeline processing.&lt;/h3&gt;

&lt;p&gt;First up, what&amp;rsquo;s a pipeline?  Well according to &lt;a href=&#34;http://en.wikipedia.org/wiki/Pipeline_(computing)&#34;&gt;Wikipedia&lt;/a&gt;:&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;A pipeline is a set of data processing elements connected in series, so that
the output of one element is the input of the next one. The elements of a
pipeline are often executed in parallel or in time-sliced fashion; in that
case, some amount of buffer storage is often inserted between elements.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;In essence its a way of dealing with complexity and its also a way of breaking
down a process into separate tasks of a similar size.  If they are used
correctly then pipelines can be used to increase the overall throughput of a
system.&lt;!-- more --&gt;&lt;/p&gt;

&lt;p&gt;In enterprise systems or in fact in most large systems, a simple idea or
program can rapidly become overwhelmingly complex.  The management all of the
disparate parts of the system can become a nightmare and the code can quickly
becomes a labyrinth, navigating it becomes a skill of only the most
accomplished code _ninja, _and even then your playing Russian roulette with
any bug fixes.In an effort to keep things manageable and simple one approach
that we can use is a pipeline. The idea is that each stage is connected to one
or more other stages and each that each stage deals with a single task before
passing the work onto the next stage.  There are many primitive types in the
&lt;a href=&#34;http://msdn.microsoft.com/en-us/library/dd460717.aspx&#34;&gt;Task Parallel Library&lt;/a&gt;
(TPL) that you could use to compose a working pipeline, we will be using a
lightweight subset taking only a few core ideas and making sure we get a nice
slick design that is both powerful and flexible.&lt;/p&gt;

&lt;p&gt;Here&amp;rsquo;s a quick flow diagram of the sort of thing that we will be looking at:&lt;/p&gt;


&lt;figure &gt;
    
        &lt;img src=&#34;https://lh5.googleusercontent.com/-55hM6Bez26w/TwTtHHXc-ZI/AAAAAAAABPo/LOgX1UywK0I/pipeline-tuv.png&#34; /&gt;
    
    
&lt;/figure&gt;


&lt;p&gt;This is a generic asynchronous payload based pipeline.  Each stage is
asynchronous and self contained and is connected to one or more other stages.
As a payload enters the pipeline it is initially added to a bounding blocking
queue.  If the queue is full then the payload is said to have overflowed and
is passed to the failure processor where the payload can be processed or
transformed in some way before being passed to a failure router which would in
turn pass the payload to one or more of the next failure stages.  The same is
also true for a successfully queued payload except that the payload is first
dequeued, processed, then passed to a router which then passes the payload to
one or more stages.  If an exception occurs during processing then the payload
is passed to the failure processor and processed like an overflow.  I am
purposely missing out any details of asynchronous operation as they will be
described in more detail next time.&lt;/p&gt;

&lt;p&gt;We will be using a little bit of &lt;a href=&#34;http://tomasp.net/blog/fsharp-iv-lang.aspx&#34;&gt;Language Oriented Programming&lt;/a&gt;
to construct the pipeline stages, maybe using a little bit of operator overloading too.  
I will describe all of this in more detail next time as we dig into the code.  
I want this to be just a brief introduction to what we are going to be doing.&lt;/p&gt;

&lt;p&gt;Here&amp;rsquo;s a more detailed description of the components that are involved in each
stage:&lt;/p&gt;

&lt;h2 id=&#34;bounded-blocking-queue&#34;&gt;Bounded Blocking Queue&lt;/h2&gt;

&lt;p&gt;This is a standard bounded blocking queue from the TPL, its purpose here is to
limit the amount of payloads that are waiting to be processed, each queue will
have an associated time-out period, if the time-out period passes the payload
is passed to the failure processor for processing and then finally to the the
failure router to be passed to one or more failure stages.&lt;/p&gt;

&lt;h2 id=&#34;processors&#34;&gt;Processors&lt;/h2&gt;

&lt;p&gt;Each pipeline processor has a primary Processor&lt;T,U&gt; and a failure processor&lt;T,V&gt;.&lt;/p&gt;

&lt;p&gt;The primary processors job is to convert type T to type U, both types can be
the same if you wish, you may well be thinking why would I want a processing
stage that essentially leaves the type unchanged?  In this case the processor
acts as a simple a pass through but using this you to do some custom routing.
This can be very be useful in some scenarios and I will describing this in
more detail in a further post.&lt;/p&gt;

&lt;p&gt;Each pipeline stage also has a failure processor&lt;T,V&gt;.  The failure processor
acts on the payload to produce the desired type and passes it onto the failure
router.  The reasoning behind this scheme rather than a simplistic exception
logger is simply flexibility.  Having spent a lot of time with this kind of
API in a more locked down format I have found that you can end up wanting a
bit more flexibility especially when some developers try to get a bit creative
with the API or start state to the payload.  A good example of having some
flexibility is during overflow:  If the bounded blocking queue fills up and
blocks for the time-out period then the payload could be passed to a failure
failure processor in which types T and V are the same.  This would allow us to
pass the payload to another stage and retry later on by attaching some sort of
delayed forwarding pipeline stage.&lt;/p&gt;

&lt;h2 id=&#34;routers&#34;&gt;Routers&lt;/h2&gt;

&lt;p&gt;The router is responsible for getting the payload to the next pipeline stage,
it can be implemented as a simple predicate function operating on the type
directly or even some outside influence if you wish.   An example of this
might be a simple duplicating stage where the payload is passed to multiple
output stages rather than just one, or a time based router where one stage is
passed the payload during the day and another at night.   When you start to
think about the possibilities the Processor / Router combination can be really
really flexible.&lt;/p&gt;

&lt;p&gt;Each pipeline stage also has a corresponding has a failure router, this can be
used for all sorts of purposes like routing the failed payload to a logging
component, routing to a delayed retry mechanism, or saved to a database etc.&lt;/p&gt;

&lt;p&gt;Thats all for now, we will be digging into some code and more detail next
time, and I will be describing a few different types of pipelines so you can
get a feel of how to use them and the overall structure.&lt;/p&gt;

&lt;p&gt;Another interesting aspect of these pipelines is that once constructed they
can be composed into single reusable blocks that as a whole, represent a
single pipeline stage.  These composite stages can then be connected together
to form a super pipeline stage, complexity is only visible when you start to
drill down and becomes almost fractal like&amp;hellip;&lt;/p&gt;

&lt;p&gt;As always please leave any comments or suggestions.&lt;/p&gt;
</description>
    </item>
    
  </channel>
</rss>