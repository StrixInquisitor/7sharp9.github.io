<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Async Workflows on 7sharp9</title>
    <link>http://7sharpnine.com/tags/async-workflows/</link>
    <description>Recent content in Async Workflows on 7sharp9</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <copyright>Dave Thomas</copyright>
    <lastBuildDate>Sun, 15 Jul 2012 00:00:00 +0000</lastBuildDate>
    <atom:link href="http://7sharpnine.com/tags/async-workflows/index.xml" rel="self" type="application/rss+xml" />
    
    <item>
      <title>The Lurking Horror</title>
      <link>http://7sharpnine.com/2012/07/15/2012-07-15-the-lurking-horror/</link>
      <pubDate>Sun, 15 Jul 2012 00:00:00 +0000</pubDate>
      
      <guid>http://7sharpnine.com/2012/07/15/2012-07-15-the-lurking-horror/</guid>
      <description>

&lt;blockquote&gt;
&lt;p&gt;Deep in the darkest depths lurks an ancient horror, when the time is right it will rise forth and leave you screaming for mercy and begging for forgiveness&amp;hellip;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;OK, I have a penchant for being over dramatic but in this post I am going to reveal some little known caveats in a well known and much revelled area of F#, agents aka the &lt;a href=&#34;http://msdn.microsoft.com/en-us/library/ee370357&#34; title=&#34;Control.MailboxProcessor&amp;lt;&#39;Msg&amp;gt;&#34;&gt;&lt;code&gt;MailboxProcessor&lt;/code&gt;&lt;/a&gt;. Gasp!&lt;/p&gt;

&lt;p&gt;First let me give you a demonstration:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-fsharp&#34;&gt;open System
open System.Diagnostics
type internal BadAgentMessage =
  | Message of string * int
  | Lock
  | Unlock
   
type BadAgent() =
  
  let agent = MailboxProcessor.Start(fun agent -&amp;gt;
    let sw = Stopwatch()
    let rec waiting () =
      agent.Scan(function
        | Unlock -&amp;gt; Some(working ())
        | _ -&amp;gt; None)
 
    and working() = async {
      let! msg = agent.Receive()
      match msg with
      | Lock -&amp;gt;   return! waiting()
      | Unlock -&amp;gt; return! working()
      | Message (msg, iter) -&amp;gt;
          if iter = 0 then sw.Start()
          if iter % 10000 = 0
            then sw.Stop()
                 printfn &amp;quot;%s : %i in: %fms&amp;quot; msg iter sw.Elapsed.TotalMilliseconds
                 sw.Restart()
          return! working() }
    working())      
 
  member x.Msg(msg) = agent.Post(Message msg)
  member x.Lock() = agent.Post(Lock)
  member x.Unlock() = agent.Post(Unlock)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The &lt;code&gt;BadAgentMessage&lt;/code&gt; type defines a discriminated union that we are going to use for the agents message interface.  This is comprised of three elements:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;Message:&lt;/strong&gt;  This will just be a simple &lt;code&gt;string&lt;/code&gt;-based message and an &lt;code&gt;int&lt;/code&gt; used as a counter.&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Lock:&lt;/strong&gt;  This is used to stop message processing within the agent by causing it to wait for an &lt;code&gt;Unlock&lt;/code&gt; message to arrive.&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Unlock:&lt;/strong&gt;  This message is used to resume the processing within the agent, effectively exiting the locked state.&lt;br /&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;We have two main sections to the agents body which I will describe below.&lt;/p&gt;

&lt;h3 id=&#34;working&#34;&gt;working&lt;/h3&gt;

&lt;p&gt;The purpose of the &lt;code&gt;working&lt;/code&gt; function is to dequeue the messages from the agent and process them with pattern matching; &lt;code&gt;let! msg = agent.Receive()&lt;/code&gt; is used to get the next message which is then pattern matched to be one of the three messages types of the &lt;code&gt;BadAgentMessage&lt;/code&gt;.  When the &lt;code&gt;Lock&lt;/code&gt; message is encountered &lt;code&gt;return! waiting()&lt;/code&gt; is used to place the agent in a state where it is waiting for an &lt;code&gt;Unlock&lt;/code&gt; message to arrive.  An &lt;code&gt;Unlock&lt;/code&gt; message simply resumes processing by calling &lt;code&gt;return! working()&lt;/code&gt;.  The only real purpose of the &lt;code&gt;Unlock&lt;/code&gt; message is to exit from the locked state that is introduced by the &lt;code&gt;Lock&lt;/code&gt; message.  The &lt;code&gt;Message&lt;/code&gt; message simply starts a &lt;a href=&#34;http://msdn.microsoft.com/en-us/library/system.diagnostics.stopwatch.aspx&#34; title=&#34;StopWatch&#34;&gt;&lt;code&gt;StopWatch&lt;/code&gt;&lt;/a&gt; on the first operation by using the Messages counter, and then stops it again on the 10,000th operation.  At this point the time taken is also printed to the console and the &lt;code&gt;StopWatch&lt;/code&gt; is restarted before resuming the main processing loop by calling &lt;code&gt;return! working()&lt;/code&gt;&lt;/p&gt;

&lt;h3 id=&#34;waiting&#34;&gt;waiting&lt;/h3&gt;

&lt;p&gt;This function is using the agents &lt;a href=&#34;http://msdn.microsoft.com/en-us/library/ee370554.aspx&#34; title=&#34;MailboxProcessor.Scan&#34;&gt;&lt;code&gt;Scan&lt;/code&gt;&lt;/a&gt; function to wait for an &lt;code&gt;Unlock&lt;/code&gt; message to arrive, once it does it puts the agent back into normal operation by calling returning &lt;code&gt;Some(working())&lt;/code&gt; from the &lt;code&gt;Scan&lt;/code&gt;function.  If the message does not match an &lt;code&gt;Unlock&lt;/code&gt; message then &lt;code&gt;None&lt;/code&gt; is returned and the agent simply waits for the next message before trying again.&lt;/p&gt;

&lt;p&gt;The rest of the agent is just ancillary member functions to allow easy sending of the three message types.&lt;/p&gt;

&lt;h3 id=&#34;test-harness&#34;&gt;Test Harness&lt;/h3&gt;

&lt;p&gt;And here&amp;rsquo;s a very simple test harness:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-fsharp&#34;&gt;let ba = BadAgent()
 
printfn &amp;quot;Press and key to start&amp;quot;
Console.ReadLine() |&amp;gt; ignore
let dump number =
    for i in 0 .. number do
        ba.Msg(&amp;quot;A message&amp;quot;, i)
 
ta.Lock()
dump 200000
ta.Unlock()
 
Console.ReadLine() |&amp;gt; ignore
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;OK, so this is a very synthetic test but I just wanted to highlight some of the internal behaviour.  If I run this code I get the following console output:&lt;/p&gt;


&lt;figure &gt;
    
        &lt;img src=&#34;https://lh5.googleusercontent.com/-chMoEOya7CE/T_tRraiW_eI/AAAAAAAABbY/wsQkWbm4DJM/s677/ConsoleTimes.png&#34; /&gt;
    
    
&lt;/figure&gt;


&lt;p&gt;You can see that the time to process the first 10,000 messages is 3083ms then it steadily decreases until the last 10,000 messages are processed in 94ms.  The processing time for 10,000 messages is about 33 times slower at the beginning than as it is at the end.  Why?&lt;/p&gt;

&lt;h2 id=&#34;opening-it-up&#34;&gt;Opening it up&lt;/h2&gt;

&lt;p&gt;Let&amp;rsquo;s take a look at some of the internals of the &lt;code&gt;MailboxProcessor&lt;/code&gt; to understand what&amp;rsquo;s going on.  First of all the core functionality is actually contained within the &lt;code&gt;Mailbox&lt;/code&gt; type with the &lt;code&gt;MailboxProcessor&lt;/code&gt; acting as an augmenter.  &lt;code&gt;TryPostAndReply&lt;/code&gt;, &lt;code&gt;PostAndReply&lt;/code&gt;, &lt;code&gt;PostAndTryAsyncReply&lt;/code&gt;, and &lt;code&gt;PostAndAsyncReply&lt;/code&gt; all add a single functionality to the &lt;code&gt;Mailbox&lt;/code&gt; type; the ability to synchronously or asynchronously reply to a message once it arrives.  &lt;code&gt;TryPostAndReply&lt;/code&gt; and &lt;code&gt;PostAndReply&lt;/code&gt; both wait synchronously for a message to arrive before replying, whereas &lt;code&gt;PostAndTryAsyncReply&lt;/code&gt; and &lt;code&gt;PostAndAsyncReply&lt;/code&gt; both reply asynchronously.  This functionality is achieved with the use of the &lt;code&gt;ResultCell&lt;/code&gt; and &lt;code&gt;AsyncReplyChannel&lt;/code&gt; types.  For an in-depth discussion on this you might want to refer to my earlier series which describes implementing the &lt;code&gt;MailboxProcessor&lt;/code&gt; with &lt;a href=&#34;http://msdn.microsoft.com/en-us/devlabs/gg585582.aspx&#34; title=&#34;TPL Dataflow&#34;&gt;TPL Dataflow&lt;/a&gt; (see &lt;a href=&#34;http://7sharpnine.com/2012/01/22/2012-01-22-fsharp-dataflow-agents-i/&#34; title=&#34;FSharp Dataflow agents - Part 1&#34;&gt;Part 1&lt;/a&gt;, &lt;a href=&#34;http://7sharpnine.com/2012/01/30/2012-01-24-fsharp-dataflow-agents-ii/&#34; title=&#34;FSharp Dataflow agents - Part 2&#34;&gt;Part 2&lt;/a&gt; and &lt;a href=&#34;http://7sharpnine.com/2012/02/20/2012-02-19-fsharp-dataflow-agents-iii/&#34; title=&#34;FSharp Dataflow agents - Part 3&#34;&gt;Part 3&lt;/a&gt;).&lt;/p&gt;

&lt;p&gt;Below are some snippets of code from the &lt;code&gt;Mailbox&lt;/code&gt; type you might want to take a peek yourself at the &lt;a href=&#34;https://github.com/fsharp/fsharp/blob/master/src/fsharp/FSharp.Core/control.fs#L1854&#34; title=&#34;Mailbox code&#34;&gt;FSharp repository&lt;/a&gt; over at &lt;a href=&#34;https://github.com/&#34;&gt;Github&lt;/a&gt; for a closer inspection, be warned thought there is a lot of code in there!&lt;/p&gt;

&lt;p&gt;Here&amp;rsquo;s the initial type definition for the &lt;code&gt;Mailbox&lt;/code&gt;, you can see that  there are two mutable fields:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-fsharp&#34;&gt;type Mailbox&amp;lt;&#39;Msg&amp;gt;() = 
    let mutable inboxStore  = null
    let mutable arrivals = new Queue&amp;lt;&#39;Msg&amp;gt;()
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;inboxStore&lt;/code&gt; is a generic List type &lt;code&gt;System.Collection.Generic.List&amp;lt;T&amp;gt;&lt;/code&gt; and &lt;code&gt;arrivals&lt;/code&gt; is a &lt;code&gt;System.Collections.Generic.Queue&amp;lt;T&amp;gt;&lt;/code&gt; type.&lt;/p&gt;

&lt;p&gt;For now the &lt;code&gt;inboxStore&lt;/code&gt; is null and is only ever assigned via &lt;code&gt;Scan&lt;/code&gt; or &lt;code&gt;TryScan&lt;/code&gt; and this is done indirectly via the &lt;code&gt;inbox&lt;/code&gt; member shown here:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-fsharp&#34;&gt;member x.inbox =
    match inboxStore with
    | null -&amp;gt; inboxStore &amp;lt;- new System.Collections.Generic.List&amp;lt;&#39;Msg&amp;gt;(1) // ResizeArray
    | _ -&amp;gt; ()
    inboxStore
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Understanding the code in the &lt;code&gt;Mailbox&lt;/code&gt; can be difficult given the amount of code, so I&amp;rsquo;ll highlight the key functions in the sections below to make it a little easier.&lt;/p&gt;

&lt;h3 id=&#34;scan-tryscan&#34;&gt;Scan / TryScan&lt;/h3&gt;

&lt;p&gt;&lt;code&gt;Scan&lt;/code&gt; is just an async wrapper around &lt;code&gt;TryScan&lt;/code&gt;. If &lt;code&gt;TryScan&lt;/code&gt; returns None an exception is raised, if not then the result from &lt;code&gt;TryScan&lt;/code&gt; is returned.&lt;/p&gt;

&lt;p&gt;So now lets take a look at the source of &lt;code&gt;TryScan&lt;/code&gt;.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-fsharp&#34;&gt;member x.TryScan ((f: &#39;Msg -&amp;gt; (Async&amp;lt;&#39;T&amp;gt;) option), timeout) : Async&amp;lt;&#39;T option&amp;gt; =
    let rec scan() =
        async { match x.scanArrivals(f) with
                | None -&amp;gt; // Deschedule and wait for a message. When it comes, rescan the arrivals
                          let! ok = waitOne(timeout)
                          if ok then return! scan() else return None
                | Some resP -&amp;gt; let! res = resP
                               return Some(res) }
    // Look in the inbox first
    async { match x.scanInbox(f,0) with
            | None  -&amp;gt; return! scan()
            | Some resP -&amp;gt; let! res = resP
                           return Some(res) }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;You can see here that an &lt;a href=&#34;http://msdn.microsoft.com/en-us/library/dd233250.aspx&#34; title=&#34;async workflows&#34;&gt;async workflow&lt;/a&gt; is declared that first pattern matches on &lt;code&gt;x.scanInbox&lt;/code&gt;, passing in the predicate scan function &lt;code&gt;f&lt;/code&gt; and the literal &lt;code&gt;0&lt;/code&gt;.  If &lt;code&gt;None&lt;/code&gt; is returned then there is no match and the recursive function &lt;code&gt;scan&lt;/code&gt; is returned.  This time the function &lt;code&gt;x.scanArrivals&lt;/code&gt; is be called, again passing in the predicate function &lt;code&gt;f&lt;/code&gt;.&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;An interesting point to note, is that each message that arrives that doesn&amp;rsquo;t match the predicate &lt;code&gt;f&lt;/code&gt; resets the  timer: &lt;code&gt;let! ok = waitOne(timeout)&lt;/code&gt;, this means that any number of trivial messages that arrive keep the &lt;code&gt;TryScan&lt;/code&gt; function running.  This was also mentioned by Jon Harrop in a Stackoverflow question entitled &lt;a href=&#34;http://stackoverflow.com/a/4891920/607275&#34; title=&#34;How to use TryScan in F# properly&#34;&gt;How to use TryScan in F# properly&lt;/a&gt;.  Jon also mentions locking which I will address in the &lt;code&gt;scanArrivals&lt;/code&gt; section below.&lt;br /&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;So what&amp;rsquo;s the difference between &lt;code&gt;scanArrivals&lt;/code&gt; and &lt;code&gt;scanInbox&lt;/code&gt;?&lt;/p&gt;

&lt;p&gt;&lt;code&gt;scanInbox&lt;/code&gt; operates on the &lt;code&gt;inboxStore&lt;/code&gt; which you might recall is a &lt;code&gt;List&amp;lt;T&amp;gt;&lt;/code&gt; type, whereas &lt;code&gt;scanArrivals&lt;/code&gt; operates on &lt;code&gt;arrivals&lt;/code&gt; which is a &lt;code&gt;Queue&amp;lt;T&amp;gt;&lt;/code&gt; type.  The big difference between these two is that as messages first arrive in the Mailbox they end up in the arrivals queue first, and when messages are not matched by the predicate function &lt;code&gt;f&lt;/code&gt; they are added to the &lt;code&gt;inboxStore&lt;/code&gt;, hence the need to always check the &lt;code&gt;inboxStore&lt;/code&gt; before the &lt;code&gt;arrivals&lt;/code&gt; queue otherwise previously unmatched scan messages would not be processed correctly.  You might be asking yourself why not use a &lt;code&gt;Queue&amp;lt;T&amp;gt;&lt;/code&gt; for both the &lt;code&gt;inbox&lt;/code&gt; and the &lt;code&gt;arrivals&lt;/code&gt;?  It comes down to the fact that it&amp;rsquo;s not possible to easily use a &lt;code&gt;Queue&amp;lt;T&amp;gt;&lt;/code&gt; for &lt;code&gt;arrivals&lt;/code&gt; because of the way that Scan works.  At any point in the queue there could do a potential match so each item would have to be dequeued and processed separately, an indexed &lt;code&gt;List&amp;lt;T&amp;gt;&lt;/code&gt; type is the best fit for this situation.&lt;/p&gt;

&lt;h3 id=&#34;scanarrivals-scanarrivalsunsafe&#34;&gt;scanArrivals / scanArrivalsUnsafe&lt;/h3&gt;

&lt;p&gt;Lets look at the &lt;code&gt;scanArrivals&lt;/code&gt; function, it&amp;rsquo;s just a lock construct around the &lt;code&gt;scanArrivals&lt;/code&gt; function.  This leads to an important point, the scan function is operating under a lock, which effectively means that end user code is also executed under the lock and if you hold onto the lock for any length of time then there will be significant blocking of the normal receive mechanism due to it also using the same lock when receiving.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-fsharp&#34;&gt;member x.scanArrivalsUnsafe(f) =
    if arrivals.Count = 0 then None
    else let msg = arrivals.Dequeue()
         match f msg with
         | None -&amp;gt;
             x.inbox.Add(msg);
             x.scanArrivalsUnsafe(f)
         | res -&amp;gt; res
 
// Lock the arrivals queue while we scan that
member x.scanArrivals(f) = lock syncRoot (fun () -&amp;gt; x.scanArrivalsUnsafe(f))
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;If we pause for a second and review the &lt;code&gt;MailBoxProcessor&lt;/code&gt; documentation on &lt;a href=&#34;http://msdn.microsoft.com/en-us/library/ee353583.aspx&#34; title=&#34;MSDN: F# MailbocProcessor&#34;&gt;MSDN&lt;/a&gt;:&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;For each agent, at most one concurrent reader may be active, so no more than one concurrent call to Receive, TryReceive, Scan or TryScan may be active.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;Obeying this rule should ensure that no deadlock situations will arise but lock contentions can still arise as messages will still be being posted to the mailbox, which will in turn attempt to acquire the same &lt;code&gt;syncRoot&lt;/code&gt; lock.&lt;/p&gt;

&lt;p&gt;Lets move onto the next function, I have saved this one for last as its the most interesting.&lt;/p&gt;

&lt;h3 id=&#34;scaninbox&#34;&gt;scanInbox&lt;/h3&gt;

&lt;p&gt;A quick glance at &lt;code&gt;scanInbox&lt;/code&gt; reveals another function which, to my eye, could have heavy-weight performance implications.   The &lt;code&gt;inbox&lt;/code&gt; is a &lt;code&gt;List&amp;lt;T&amp;gt;&lt;/code&gt; type, and the &lt;code&gt;RemoveAt&lt;/code&gt; function does an internal &lt;code&gt;Array.Copy&lt;/code&gt; for each removal.  This is an O(n) operation where n is (Count - index), so as soon as the list gets to a reasonable size then this then is going to really start chewing into your processing time.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-fsharp&#34;&gt;member x.scanInbox(f,n) =
    match inboxStore with
    | null -&amp;gt; None
    | inbox -&amp;gt;
        if n &amp;gt;= inbox.Count
        then None
        else
            let msg = inbox.[n]
            match f msg with
            | None -&amp;gt; x.scanInbox (f,n+1)
            | res -&amp;gt; inbox.RemoveAt(n); res
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;In order to check this theory lets do some quick profiling of the console test that we showed earlier:&lt;/p&gt;


&lt;figure &gt;
    
        &lt;img src=&#34;https://lh5.googleusercontent.com/-HRwdmElTHzk/UACUh2a0mmI/AAAAAAAABb0/X-PXjabROOU/s658/profile_run.png&#34; /&gt;
    
    
&lt;/figure&gt;


&lt;p&gt;This screen shot was taken using &lt;a href=&#34;http://www.jetbrains.com/profiler/&#34; title=&#34;Jet Brains Performance Profiling&#34;&gt;Jet Brains DotTrace 5.1&lt;/a&gt;.  This is one of my favourite performance profilers because it captures results to line level and maps back to the F# source code relatively easily.&lt;/p&gt;

&lt;p&gt;Yeah there it is, a whopping 44.41% of the time is spent in &lt;code&gt;RemoveAt&lt;/code&gt;.  Also notice that there were 200,000 calls which mirrors the number we placed in the queue before using the Lock/Unlock message types.&lt;/p&gt;

&lt;p&gt;One of the things that really stands out for me is that the &lt;code&gt;inbox&lt;/code&gt; is a simple list and completely unbounded.  In a high throughput situation where the scan function is being used it&amp;rsquo;s perfectly feasible to get into a runaway memory or CPU condition where the unmatched messages are sitting in the &lt;code&gt;inbox&lt;/code&gt; taking longer and longer to processes due to the O(n) operation that takes place in the &lt;code&gt;RemoveAt&lt;/code&gt; function.  Given a consistent throughput then eventually you are going to either run out memory, or the processing time will make throughput drop to dire levels which in turn will back up the &lt;code&gt;inbox&lt;/code&gt; even further, effectively this is a death spiral.&lt;/p&gt;

&lt;h2 id=&#34;conclusion&#34;&gt;Conclusion&lt;/h2&gt;

&lt;p&gt;So what conclusion can we draw from all of this?&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Firstly be careful with usage of &lt;code&gt;Scan&lt;/code&gt; and &lt;code&gt;TryScan&lt;/code&gt;, in certain situations the internal queue could back up to a certain size where you will be constantly struggling against the O(n) operation cost.&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;Agents are not a silver bullet solution. They cannot solve every problem.  Although it&amp;rsquo;s possible to use agent based techniques to solve various problems like blocking collections and such like, you have to use care and diligence in the solution to avoid introducing another problems into the mix.  I have seen several implementations that I have been able to break relatively easily.&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;Do I still use agents?  &lt;strong&gt;Absolutely!&lt;/strong&gt;  Agents are a fabulous tool to have in our toolbox and some extremely elegant solution exist to solve very complex problems.&lt;/li&gt;
&lt;li&gt;Do I use &lt;code&gt;Scan&lt;/code&gt; or &lt;code&gt;TryScan&lt;/code&gt;?  Not in its current form in the &lt;code&gt;MailboxProcessor&lt;/code&gt;.  I chose to implement a destructive scan in my &lt;a href=&#34;http://7sharpnine.com/2012/02/20/2012-02-19-fsharp-dataflow-agents-iii/&#34; title=&#34;FSharp Dataflow agents - Part 3&#34;&gt;TDF agent&lt;/a&gt; for the reasons discussed here.&lt;br /&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Before we finish, I&amp;rsquo;d like to briefly cover &lt;code&gt;TryScan&lt;/code&gt; from my &lt;a href=&#34;http://msdn.microsoft.com/en-us/devlabs/gg585582.aspx&#34; title=&#34;TPL Dataflow&#34;&gt;TDF&lt;/a&gt; based agent to complete the picture.&lt;/p&gt;

&lt;h3 id=&#34;destructive-tryscan&#34;&gt;Destructive TryScan&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&#34;language-fsharp&#34;&gt;member x.TryScan((scanner: &#39;Msg -&amp;gt; Async&amp;lt;_&amp;gt; option), timeout): Async&amp;lt;_ option&amp;gt; =
    let ts = TimeSpan.FromMilliseconds(float timeout)
    let rec loopForMsg = async {
        let! msg = Async.AwaitTask &amp;lt;| incomingMessages.ReceiveAsync(ts)
                                      .ContinueWith(fun (tt:Task&amp;lt;_&amp;gt;) -&amp;gt;
                                          if tt.IsCanceled || tt.IsFaulted then None
                                          else Some tt.Result)
        match msg with
        | Some m -&amp;gt;  let res = scanner m
                     match res with
                     | None -&amp;gt; return! loopForMsg
                     | Some res -&amp;gt; return! res
        | None -&amp;gt; return None}
    loopForMsg
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;A message is dequeued on the line 4 with &lt;code&gt;let! msg = Async.AwaitTask ...&lt;/code&gt;.  This is then processed by the pattern matching expression on line 9 &lt;code&gt;| Some m -&amp;gt;  let res = scanner m&lt;/code&gt;.  If the result of the scanner function results in &lt;code&gt;None&lt;/code&gt; being returned then the message is discarded and the next operation continues with another call to &lt;code&gt;loopForMsg&lt;/code&gt;, otherwise the message is returned with &lt;code&gt;| Some res -&amp;gt; return! res&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;One of the areas where I have a lot of experience is using pipelined operations based on input from network I/O.  One of the things that always causes a problem is unbounded situations such as having a queue with no absolute limit.  There comes a time when you have to protect yourself from what is effective a denial of service, you have to either destructively terminate messages or connections or route the overflowed data for processing later.&lt;/p&gt;

&lt;p&gt;Until next time&amp;hellip;&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>FSharp Dataflow agents III</title>
      <link>http://7sharpnine.com/2012/02/20/2012-02-19-fsharp-dataflow-agents-iii/</link>
      <pubDate>Mon, 20 Feb 2012 00:00:00 +0000</pubDate>
      
      <guid>http://7sharpnine.com/2012/02/20/2012-02-19-fsharp-dataflow-agents-iii/</guid>
      <description>

&lt;p&gt;This will be the last post on rebuilding the &lt;code&gt;MailboxProcessor&lt;/code&gt; using &lt;a href=&#34;http://msdn.microsoft.com/en-us/devlabs/gg585582&#34;&gt;TDF&lt;/a&gt;,
here&amp;rsquo;s a quick discussion of the missing pieces&amp;hellip;&lt;/p&gt;

&lt;p&gt;First, lets start with the simple ones, these don&amp;rsquo;t really require much discussion.&lt;/p&gt;

&lt;h3 id=&#34;defaulttimeout&#34;&gt;DefaultTimeout&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&#34;language-fsharp&#34;&gt;let mutable defaultTimeout = Timeout.Infinite

member x.DefaultTimeout
   with get() = defaultTimeout
   and set(value) = defaultTimeout &amp;lt;- value
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;This simply provides a mutable property using &lt;code&gt;Timeout.Infinite&lt;/code&gt; as a default setting.&lt;/p&gt;

&lt;h3 id=&#34;currentqueuelength&#34;&gt;CurrentQueueLength&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&#34;language-fsharp&#34;&gt;member x.CurrentQueueLength() = incomingMessages.Count 
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Another simple one, this methods uses into the underlying &lt;code&gt;BufferBlock&lt;/code&gt; to extract its current queue length using its &lt;code&gt;Count&lt;/code&gt; property.&lt;/p&gt;

&lt;h3 id=&#34;tryreceive&#34;&gt;TryReceive&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&#34;language-fsharp&#34;&gt;member x.TryReceive(?timeout) = 
    let ts = TimeSpan.FromMilliseconds(float &amp;lt;| defaultArg time out defaultTimeout)
    Async.AwaitTask &amp;lt;| incomingMessages.ReceiveAsync(ts)
                           .ContinueWith(fun (tt:Task&amp;lt;_&amp;gt;) -&amp;gt; 
                                             if tt.IsCanceled || tt.IsFaulted then None
                                             else Some tt.Result)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Here we get a little help from &lt;a href=&#34;http://msdn.microsoft.com/en-us/library/dd460717.aspx&#34;&gt;TPL&lt;/a&gt; to apply a continuation on completion
using &lt;code&gt;ContinueWith&lt;/code&gt;.  We use a lambda to return either &lt;code&gt;None&lt;/code&gt;, in a time out condition, or &lt;code&gt;Some tt.Result&lt;/code&gt; when we successfully receive an item.&lt;/p&gt;

&lt;h3 id=&#34;trypostandreply&#34;&gt;TryPostAndReply&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&#34;language-fsharp&#34;&gt;type AsyncResultCell&amp;lt;&#39;a&amp;gt;() = 
    ...
	member x.TryWaitResultSynchronously(timeout:int) = 
	    //early completion check
	    if source.Task.IsCompleted then 
	        Some source.Task.Result
	    //now force a wait for the task to complete
	    else 
	        if source.Task.Wait(timeout) then 
	            Some source.Task.Result
	        else None

member x.TryPostAndReply(replyChannelMsg, ?timeout) :&#39;Reply option = 
    let timeout = defaultArg timeout defaultTimeout
    let resultCell = AsyncResultCell&amp;lt;_&amp;gt;()
    let msg = replyChannelMsg(new AsyncReplyChannel&amp;lt;_&amp;gt;(fun reply -&amp;gt; resultCell.RegisterResult(reply)))
    if incomingMessages.Post(msg) then
        resultCell.TryWaitResultSynchronously(timeout)
    else None
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Things get a little more interesting from here on in.  Firstly we need to add a new synchronisation member to the &lt;code&gt;AsyncResultCell&amp;lt;&#39;a&amp;gt;&lt;/code&gt; type: &lt;code&gt;TryWaitResultSynchronously&lt;/code&gt;.   We again enlist the help of the TPL primitives to check for the early completion using &lt;code&gt;source.Task.IsCompleted&lt;/code&gt; returning the result if it is there, otherwise we use the &lt;code&gt;Task&lt;/code&gt; property&amp;rsquo;s &lt;code&gt;Wait&lt;/code&gt; method to check the item returns within the time out interval.  In the usual manner, &lt;code&gt;Some source.Task.Result&lt;/code&gt; is returned or &lt;code&gt;None&lt;/code&gt; for a failure.&lt;/p&gt;

&lt;h3 id=&#34;postandreply&#34;&gt;PostAndReply&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&#34;language-fsharp&#34;&gt;member x.PostAndReply(replyChannelMsg, ?timeout) : &#39;Reply = 
    match x.TryPostAndReply(replyChannelMsg, ?timeout = timeout) with
    | None -&amp;gt;  raise (TimeoutException(&amp;quot;PostAndReply timed out&amp;quot;))
    | Some result -&amp;gt; result
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;This one wraps a call to &lt;code&gt;TryPostAndReply&lt;/code&gt; with some pattern matching.  In the event of a time out &lt;code&gt;None&lt;/code&gt; is returned from &lt;code&gt;TryPostAndReply&lt;/code&gt; in this instance we raise a &lt;code&gt;TimeoutException&lt;/code&gt; otherwise we unwrap the result from the option using &lt;code&gt;| Some result -&amp;gt; result&lt;/code&gt;.&lt;/p&gt;

&lt;h3 id=&#34;tryscan&#34;&gt;TryScan&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&#34;language-fsharp&#34;&gt;member x.TryScan((scanner: &#39;Msg -&amp;gt; Async&amp;lt;_&amp;gt; option), timeout): Async&amp;lt;_ option&amp;gt; = 
    let ts = TimeSpan.FromMilliseconds( float timeout)
    let rec loopForMsg = async {
        let! msg = Async.AwaitTask &amp;lt;| incomingMessages.ReceiveAsync(ts)
                                      .ContinueWith(fun (tt:Task&amp;lt;_&amp;gt;) -&amp;gt; 
                                          if tt.IsCanceled || tt.IsFaulted then None
                                          else Some tt.Result)
        match msg with
        | Some m -&amp;gt;  let res = scanner m
                     match res with
                     | None -&amp;gt; return! loopForMsg
                     | Some res -&amp;gt; return! res 
        | None -&amp;gt; return None}                             
    loopForMsg
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;This one also uses the same &lt;code&gt;ContinueWith&lt;/code&gt; functionality in the recursive &lt;code&gt;loopForMsg&lt;/code&gt; function, perhaps some
of these functions could extracted out and refactored but I prefer to keep the code like this to better explain what&amp;rsquo;s going
on.  The the code is available on GitHub anyway so feel free to clean up any detritus and send me a pull request.  Again we use pattern matching to keep calling the &lt;code&gt;loopForMsg&lt;/code&gt; function until the result is returned or a time out occurs.&lt;/p&gt;

&lt;h3 id=&#34;scan&#34;&gt;Scan&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&#34;language-fsharp&#34;&gt;member x.Scan(scanner, timeout) =
    async { let! res = x.TryScan(scanner, timeout)
            match res with
            | None -&amp;gt; return raise(TimeoutException(&amp;quot;Scan TimedOut&amp;quot;))
            | Some res -&amp;gt; return res }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Finally we have Scan, this is much like PostAndReply in that it just acts as a wrapper around &lt;code&gt;TryScan&lt;/code&gt; making use of
pattern matching throwing an exception on a time out.&lt;/p&gt;

&lt;p&gt;That sums up the last few pieces, completing the TDF implementation of the &lt;code&gt;MailboxProcessor&lt;/code&gt;.  I think this series of posts has shown the elegance of F#&amp;rsquo;s asynchronous workflows.  The use of recursive functions and the compositional nature of asynchronous workflows really helps when you are doing this type of programming.  It&amp;rsquo;s also very nice on the eye, each section being clearly defined.&lt;/p&gt;

&lt;p&gt;The more astute of you may have noticed something a little different.  &lt;code&gt;Scan&lt;/code&gt; and &lt;code&gt;TryScan&lt;/code&gt; are destructive in this implementation, the unmatched messages are purged from the internal queue.  Although I could have mirrored the same functionality of the &lt;code&gt;MailboxProcessor&lt;/code&gt; by using an internal list to keep track of unmatched messages, this leads to performing checks during &lt;code&gt;Receive&lt;/code&gt; and &lt;code&gt;Scan&lt;/code&gt; and their derivatives to make sure that this list is used first when switching from &lt;code&gt;Scan&lt;/code&gt; and &lt;code&gt;Receive&lt;/code&gt; functionality.&lt;/p&gt;

&lt;p&gt;I think the separation of concerns are a little fuzzy in the &lt;code&gt;MailboxProcessor&lt;/code&gt;.  The &lt;code&gt;scan&lt;/code&gt; function seems like an after thought, even if you don&amp;rsquo;t use &lt;code&gt;Scan&lt;/code&gt; you still pay a price for it as there are numerous checks between the internal queue and the unmatched messages list.  You can also run into issues while using &lt;code&gt;Scan&lt;/code&gt; and &lt;code&gt;TryScan&lt;/code&gt; that can result in out of memory conditions due to the inherent unbounded nature.  I will briefly describe and explore the conditions that can lead to that in the next post.  In the implementation presented here we can get bounded checking by passing in an optional &lt;code&gt;DataflowBlockOptions&lt;/code&gt; and setting a value for the &lt;code&gt;BoundedCapacity&lt;/code&gt; property.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;EDIT:&lt;/strong&gt; The code for this series of articles is now available on GitHub: &lt;a href=&#34;https://github.com/7sharp9/FSharpDataflow&#34;&gt;FSharpDataflow&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;Until next time&amp;hellip;&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>F# Dataflow Agents Part II</title>
      <link>http://7sharpnine.com/2012/01/30/2012-01-24-fsharp-dataflow-agents-ii/</link>
      <pubDate>Mon, 30 Jan 2012 00:00:00 +0000</pubDate>
      
      <guid>http://7sharpnine.com/2012/01/30/2012-01-24-fsharp-dataflow-agents-ii/</guid>
      <description>

&lt;p&gt;Right, no messing about this time, straight to the code.&lt;/p&gt;

&lt;h2 id=&#34;construction&#34;&gt;Construction&lt;/h2&gt;

&lt;p&gt;This is pretty straight forward and I don&amp;rsquo;t want to detract from the important bits of this post, the only thing
of note is the &lt;code&gt;cancellationToken&lt;/code&gt; which is initialized to a default value using the &lt;code&gt;defaultArg&lt;/code&gt; function if the
optional parameter  &lt;code&gt;cancellationToken&lt;/code&gt; is not supplied. The TDF construct that we to use to perform most of the hard
work is &lt;code&gt;incomingMessages&lt;/code&gt; which is a &lt;code&gt;BufferBlock&amp;lt;&#39;Msg&amp;gt;&lt;/code&gt;.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-fsharp&#34;&gt;type DataflowAgent&amp;lt;&#39;Msg&amp;gt;(initial, ?cancellationToken) =
    let cancellationToken = 
        defaultArg cancellationToken Async.DefaultCancellationToken
    let mutable started = false
    let errorEvent = new Event&amp;lt;System.Exception&amp;gt;()
    let incomingMessages = new BufferBlock&amp;lt;&#39;Msg&amp;gt;()
    let mutable defaultTimeout = Timeout.Infinite
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;error&#34;&gt;Error&lt;/h2&gt;

&lt;p&gt;This is the public facing part for the Error event.  The &lt;code&gt;[&amp;lt;CLIEvent&amp;gt;]&lt;/code&gt; attribute exposes the event in a friendly manner to other .Net languages by adding the &lt;code&gt;add_Error&lt;/code&gt; and &lt;code&gt;remove_Error&lt;/code&gt; event handler properties to allow subscription to take place.  The &lt;code&gt;Error&lt;/code&gt; event fires when an exception is thrown in the &lt;code&gt;initial&lt;/code&gt; asynchronous workflow.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-fsharp&#34;&gt;[&amp;lt;CLIEvent&amp;gt;]
member this.Error = errorEvent.Publish
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;start&#34;&gt;Start&lt;/h2&gt;

&lt;p&gt;This is implemented the same as the MailboxProcessor.  An exception is thrown if the agent has already started as this is not valid operation.  We set the mutable field &lt;code&gt;started&lt;/code&gt; to true and proceed to start the &lt;code&gt;initial&lt;/code&gt; asynchronous workflow.  This workflow is wrapped in a &lt;code&gt;try with block&lt;/code&gt; so that if an exception is thrown we catch it and trigger the &lt;code&gt;Error&lt;/code&gt; event.  The computation is then started with &lt;code&gt;Async.Start(...)&lt;/code&gt;.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-fsharp&#34;&gt;member this.Start() =
    if started 
        then raise (new InvalidOperationException(&amp;quot;Already Started.&amp;quot;))
    else
        started &amp;lt;- true
        let comp = async { try do! initial this 
                           with error -&amp;gt; errorEvent.Trigger error }
        Async.Start(computation = comp, cancellationToken = cancellationToken)
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;receive&#34;&gt;Receive&lt;/h2&gt;

&lt;p&gt;The Receive member is used by the agent as a way of waiting for a message to arrive without blocking.  Because the TDF functionality is all TPL Task based we use the the &lt;a href=&#34;http://msdn.microsoft.com/en-us/library/ee370232.aspx&#34;&gt;Async&lt;/a&gt; helper functions.  In this instance we utilise the Async.AwaitTask passing in the &lt;code&gt;incomingMessages&lt;/code&gt; &lt;code&gt;ReceiveAsync&lt;/code&gt; method to wait for
a message to arrive.  The integration between F# async and TDF is nice and succinct here.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-fsharp&#34;&gt;member this.Receive(?timeout) = 
    Async.AwaitTask &amp;lt;| incomingMessages.ReceiveAsync()
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;post&#34;&gt;Post&lt;/h2&gt;

&lt;p&gt;The Post member allows a message to be sent to the agents, this member simply calls the &lt;code&gt;incomingMessages&lt;/code&gt; &lt;code&gt;Post&lt;/code&gt; method passing in the &lt;code&gt;item&lt;/code&gt;.  We raise an exception if there is a problem posting (i.e. the &lt;code&gt;incomingMessages&lt;/code&gt; internal queue is full).&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-fsharp&#34;&gt;member this.Post(item) = 
    let posted = incomingMessages.Post(item)
    if not posted then
        raise (InvalidOperationException(&amp;quot;Incoming message buffer full.&amp;quot;))
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;postandtryasyncreply-postandasyncreply&#34;&gt;PostAndTryAsyncReply / PostAndAsyncReply&lt;/h2&gt;

&lt;p&gt;I&amp;rsquo;m grouping both of these together as they are related in functionality.  In the previous post I purposely left
out some ancillary code as it added unnecessary complexity to the introduction.  There are a two types we need to be able to replicate the &lt;code&gt;PostAndTryAsyncReply&lt;/code&gt; and &lt;code&gt;PostAndAsyncReply&lt;/code&gt; members of the &lt;code&gt;MailboxProcessor&lt;/code&gt;.&lt;/p&gt;

&lt;h3 id=&#34;asyncreplychannel&#34;&gt;AsyncReplyChannel&lt;/h3&gt;

&lt;p&gt;The first type we need is the &lt;code&gt;AsyncReplyChannel&amp;lt;&#39;Reply&amp;gt;&lt;/code&gt;.  This type takes a function that accepts a generic &lt;code&gt;&#39;Reply&lt;/code&gt; and returns a unit.  It is used as a way of communicating back to the caller of the &lt;code&gt;PostAndTryAsyncReply&lt;/code&gt; and &lt;code&gt;PostAndAsyncReply&lt;/code&gt; members via its single member &lt;code&gt;Reply&lt;/code&gt;.  This should become a little clearer when we see it used in context.&lt;/p&gt;

&lt;p&gt;An &lt;code&gt;AsyncRepyChannel&lt;/code&gt; does actually exist in F# under the Microsoft.FSharp.Control namespace and is used my the &lt;code&gt;MailboxPRocessor&lt;/code&gt;, unfortunately its constructor is marked as internal so we are not able to reuse it here.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-fsharp&#34;&gt;type AsyncReplyChannel&amp;lt;&#39;Reply&amp;gt;(replyf : &#39;Reply -&amp;gt; unit) =
    member x.Reply(reply) = replyf(reply)
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;asyncresultcell&#34;&gt;AsyncResultCell&lt;/h3&gt;

&lt;p&gt;The next type we need is the &lt;code&gt;AsyncResultCell&amp;lt;&#39;a&amp;gt;&lt;/code&gt;.  We use this as a way to await for the results of an asynchronous operation.  We create a &lt;a href=&#34;http://msdn.microsoft.com/en-us/library/dd449174.aspx&#34;&gt;TaskCompletionSource&lt;/a&gt; (&lt;code&gt;source&lt;/code&gt;), which is a TPL type that we use as a way of signalling to a callback / lambda expression when a message has arrived.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;RegisterResult&lt;/strong&gt; is used as a way of notifying when a message has been arrived, this is used internally by our agent as a result of a reply being made to the AsyncReplyChannel.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;AsyncWaitResult&lt;/strong&gt; is a continuation wrapper, it is called when we want to wait indefinitely for the result to be returned.  It wraps a successful completion with a call to task.Result which then returns the result.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;GetWaitHandle&lt;/strong&gt; is used as a mechanism to force the asynchronous result to return within a specified timeout interval.  If a result is not returned within the timeout then this function will return false.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;GrabResult&lt;/strong&gt; returns the result from the TaskCompletionSource object &lt;code&gt;source&lt;/code&gt;.  This is set earlier by the &lt;code&gt;RegisterResult&lt;/code&gt; member.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-fsharp&#34;&gt;type AsyncResultCell&amp;lt;&#39;a&amp;gt;() =
    let source = new TaskCompletionSource&amp;lt;&#39;a&amp;gt;()
    member x.RegisterResult result = source.SetResult(result)

    member x.AsyncWaitResult =
        Async.FromContinuations(fun (cont,_,_) -&amp;gt; 
            let apply = fun (task:Task&amp;lt;_&amp;gt;) -&amp;gt; cont (task.Result)
            source.Task.ContinueWith(apply) |&amp;gt; ignore)

    member x.GetWaitHandle(timeout:int) =
        async { let waithandle = source.Task.Wait(timeout)
                return waithandle }
                
    member x.GrabResult() = source.Task.Result
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&#34;postandtryasyncreply&#34;&gt;PostAndTryAsyncReply&lt;/h4&gt;

&lt;p&gt;This one is a little more tricky and I have added a few line number references to try and make it easier.  On &lt;strong&gt;line 3&lt;/strong&gt; we
declare an resultCell to collect the result of the asynchronous operation.  This is used on &lt;strong&gt;line 4&lt;/strong&gt; when we create a &lt;code&gt;msg&lt;/code&gt;
to post to &lt;code&gt;incomingMessages&lt;/code&gt; on &lt;strong&gt;line 5&lt;/strong&gt;.  The &lt;code&gt;replyChannelMsg&lt;/code&gt; is a function that takes an &lt;code&gt;AsyncReplyChannel&lt;/code&gt; and returns
a message, so we create an &lt;code&gt;AsyncReplyChannel&lt;/code&gt; with a lambda expression that registers the reply with the &lt;code&gt;resultCell&lt;/code&gt;.  This
is the key to how this works, you have to remember that will be done the other side of the operation which will be within the
asynchronous processing loop of the agent when &lt;code&gt;Reply&lt;/code&gt; is called on the &lt;code&gt;AsyncReplyChannel&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;Finally pattern matching is used on &lt;strong&gt;line 7&lt;/strong&gt; to call either &lt;code&gt;AsyncWaitResult&lt;/code&gt; or &lt;code&gt;GetWaitHandle&lt;/code&gt; on the &lt;code&gt;resultCell&lt;/code&gt;.  The &lt;code&gt;AsyncWaitResult&lt;/code&gt; function is used to wait indefinitely and the &lt;code&gt;GetWaitHandle&lt;/code&gt; function is used if we want to use a timeout.  Both of these are asynchronous workflows that either return a result or return an option type containing the result.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-fsharp&#34;&gt;member this.PostAndTryAsyncReply(replyChannelMsg, ?timeout) = 
    let timeout = defaultArg timeout defaultTimeout
    let resultCell = AsyncResultCell&amp;lt;_&amp;gt;()
    let msg = replyChannelMsg(AsyncReplyChannel&amp;lt;_&amp;gt;(fun reply -&amp;gt; resultCell.RegisterResult(reply)))
    let posted = incomingMessages.Post(msg)
    if posted then
        match timeout with
        |   Threading.Timeout.Infinite -&amp;gt; 
                async { let! result = resultCell.AsyncWaitResult
                        return Some(result) }  
        |   _ -&amp;gt;
                async { let! ok =  resultCell.GetWaitHandle(timeout)
                        let res = (if ok then Some(resultCell.GrabResult()) else None)
                        return res }
    else async{return None}
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&#34;postandasyncreply&#34;&gt;PostAndAsyncReply&lt;/h4&gt;

&lt;p&gt;This member uses the same functionality as &lt;code&gt;PostAndTryAsyncReply&lt;/code&gt;, creating a message using the &lt;code&gt;AsyncReplyChannel&lt;/code&gt;.  The main
difference is that an asynchronous workflow is created that wraps a call to &lt;code&gt;PostAndTryAsyncReply&lt;/code&gt; if the &lt;code&gt;timeout&lt;/code&gt; is specified.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-fsharp&#34;&gt;member this.PostAndAsyncReply( replyChannelMsg, ?timeout) =
    let timeout = defaultArg timeout defaultTimeout
    match timeout with
    |   Threading.Timeout.Infinite -&amp;gt; 
        let resCell = AsyncResultCell&amp;lt;_&amp;gt;()
        let msg = replyChannelMsg (AsyncReplyChannel&amp;lt;_&amp;gt;(fun reply -&amp;gt; resCell.RegisterResult(reply) ))
        let posted = incomingMessages.Post(msg)
        if posted then
            resCell.AsyncWaitResult
        else
            raise (InvalidOperationException(&amp;quot;Incoming message buffer full.&amp;quot;))
    |   _ -&amp;gt;
        let asyncReply = this.PostAndTryAsyncReply(replyChannelMsg, timeout=timeout) 
        async { let! res = asyncReply
                match res with 
                | None -&amp;gt;  return! raise (TimeoutException(&amp;quot;PostAndAsyncReply TimedOut&amp;quot;))
                | Some res -&amp;gt; return res }
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;static-start&#34;&gt;Static Start&lt;/h2&gt;

&lt;p&gt;The static Start function is used as a way to construct and start the agent than using the constructor and then calling the Start function.  This is really just a simple short cut for this common use case.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-fsharp&#34;&gt;static member Start(initial, ?cancellationToken) =
    let dfa = DataflowAgent&amp;lt;&#39;Msg&amp;gt;(initial, ?cancellationToken = cancellationToken)
    dfa.Start()
    dfa
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Until next time&amp;hellip;&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>F# Dataflow Agents Part I</title>
      <link>http://7sharpnine.com/2012/01/22/2012-01-22-fsharp-dataflow-agents-i/</link>
      <pubDate>Sun, 22 Jan 2012 00:00:00 +0000</pubDate>
      
      <guid>http://7sharpnine.com/2012/01/22/2012-01-22-fsharp-dataflow-agents-i/</guid>
      <description>

&lt;p&gt;This is going to be a new series on using TPL Dataflow with F#.  First a little bit of history and background.&lt;/p&gt;

&lt;h2 id=&#34;tpl-dataflows-heritage-and-background&#34;&gt;TPL Dataflows heritage and background&lt;/h2&gt;

&lt;p&gt;TPL Dataflow or &lt;a href=&#34;http://msdn.microsoft.com/en-us/devlabs/gg585582&#34;&gt;(TDF)&lt;/a&gt; has been around for quite a
while, it first surfaced more than a year ago as the successor to the Concurrency and Coordination Runtime
&lt;a href=&#34;http://msdn.microsoft.com/en-us/library/bb648752.aspx&#34;&gt;(CCR)&lt;/a&gt; and with coming release of .Net 4.5 it will
be part of the &lt;code&gt;System.Threading.Tasks.Dataflow&lt;/code&gt; namespace.  Elements of the now halted project
&lt;a href=&#34;http://msdn.microsoft.com/en-us/devlabs/dd795202&#34;&gt;Axum&lt;/a&gt; are also present within the design of TDF.&lt;/p&gt;

&lt;h3 id=&#34;concurrency-and-coordination-runtime-ccr&#34;&gt;Concurrency and Coordination Runtime (CCR)&lt;/h3&gt;

&lt;p&gt;CCR is a library that deals with asynchrony, concurrency, and coordination between blocks of asynchronous
code so that the programmer doesn&amp;rsquo;t have to.  All of the low level details of synchronization and error
propagation are taken care of in a consistent fashion.  CCR is still is included in
&lt;a href=&#34;ttp://www.microsoft.com/robotics/&#34;&gt;Microsoft Robotics Studio&lt;/a&gt; where it is used extensively to exploit
parallel hardware and deal with partial failure of systems.&lt;/p&gt;

&lt;h3 id=&#34;axum&#34;&gt;Axum&lt;/h3&gt;

&lt;p&gt;Axum was another interesting Microsoft research project, it also utilized the actor model embracing the
principles of isolation, and message-passing.  There was also extensive use  symbolic operators as a terse
short hand way to indicate operations between actors.  For example &lt;code&gt;&amp;lt;--&lt;/code&gt; defined a way to pass a message
to an actor. Theres was also a similarity to CCR as Axum used the concepts of Ports and channels in a similar
way.  It was a very interesting project and it was a shame it was put on hold.&lt;/p&gt;

&lt;h3 id=&#34;tpl-dataflow-tdf&#34;&gt;TPL Dataflow (TDF)&lt;/h3&gt;

&lt;p&gt;TDF builds on CCR and Axum, consolidating and refine to produce a more friendly fluent interface, much in
the same vain as Language-Integrated Query &lt;a href=&#34;http://msdn.microsoft.com/en-us/library/bb308959.aspx&#34;&gt;(LINQ)&lt;/a&gt;
and Reactive Extensions &lt;a href=&#34;http://msdn.microsoft.com/en-us/data/gg577609&#34;&gt;(RX)&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;TDF is built around a number of different blocks which can be combined or linked together.  There are three
different categories of blocks are as follows:&lt;/p&gt;

&lt;h4 id=&#34;buffering-blocks&#34;&gt;Buffering Blocks&lt;/h4&gt;

&lt;p&gt;Buffering blocks simply buffer data in various ways before passing the data on to another block.&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;BufferBlock&amp;lt;&amp;rsquo;T&amp;gt;&lt;/strong&gt;  - The BufferBlock act as a first-in-first-out (FIFO) queue, buffering each input.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;BroadcastBlock&amp;lt;&amp;rsquo;T&amp;gt;&lt;/strong&gt; - The BroadcastBlock linking to multiple targets copying the data to each of the
connected blocks.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;WriteOnceBlock&amp;lt;&amp;rsquo;T&amp;gt;&lt;/strong&gt; - The WriteOnceBlock acts like an immutable target, after an item first item
is passed to it, it effectively becomes read only.&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&#34;executor-blocks&#34;&gt;Executor Blocks&lt;/h4&gt;

&lt;p&gt;The executor blocks run user supplied code in the form of a lambda expressions or a &lt;code&gt;Task&amp;lt;&#39;T&amp;gt;&lt;/code&gt;.&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;ActionBlock&amp;lt;&amp;lsquo;TInput&amp;gt;&lt;/strong&gt; - The ActionBlock acts like the &lt;code&gt;Action&amp;lt;&#39;T&amp;gt;&lt;/code&gt; delegate performing an action
on each datum posted to it.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;TransformBlock&amp;lt;&amp;lsquo;TInput,&amp;lsquo;TOutput&amp;gt;&lt;/strong&gt; - The TransformBlock acts just like the ActionBlock except
that the action performed can have an output, this output is buffered and behaves just like a BufferBlock.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;TransformManyBlock&amp;lt;&amp;lsquo;TInput,&amp;lsquo;TOutput&amp;gt;&lt;/strong&gt; - The TransformManyBlock is just like a TransformBlock except
that is can produce more than one output for a given datum.&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&#34;joining-blocks&#34;&gt;Joining Blocks&lt;/h4&gt;

&lt;p&gt;The Joining Blocks Combining or join data together in different ways.&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;BatchBlock&amp;lt;&amp;rsquo;T&amp;gt;&lt;/strong&gt; - The BatchBlock Combines multiple single items together, the items are
represented by arrays of elements.  The items are grouped together is batches and then passed on to
another block.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;JoinBlock&amp;lt;&amp;lsquo;T1,&amp;lsquo;T2,…&amp;gt;&lt;/strong&gt; - The JoinBlock acts as a form of &lt;code&gt;Enumerable.Zip&amp;lt;&#39;T1,&#39;T2,&#39;TResult&amp;gt;&lt;/code&gt;
except the zip operation is performed on the items in the source array.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;BatchedJoinBlock&amp;lt;&amp;lsquo;T1,&amp;lsquo;T2,…&amp;gt;&lt;/strong&gt; This block as the name suggests simply aggregates the JoinBlock and
the BatchBlock together.&lt;br /&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Thats an ultra high level tour thats only just scratches the surface.  I recommend you check out the
&lt;a href=&#34;http://www.microsoft.com/download/en/details.aspx?id=14782&#34;&gt;Introduction to TPL Dataflow&lt;/a&gt; document to read
up on the details.  Theres a few more resources in the &lt;a href=&#34;http://msdn.microsoft.com/en-us/devlabs/gg585582&#34;&gt;DevLabs area&lt;/a&gt;
that you might find useful.  Hopefully this series should also shed a bit more light on TDF as we go along&amp;hellip;&lt;/p&gt;

&lt;h3 id=&#34;f-asynchronous-workflows-and-agents&#34;&gt;F# Asynchronous Workflows and Agents&lt;/h3&gt;

&lt;p&gt;So where does that leave us in F#?&lt;br /&gt;
In F# we have &lt;a href=&#34;http://msdn.microsoft.com/en-us/library/dd233250.aspx&#34;&gt;Asynchronous Workflows&lt;/a&gt; and
&lt;a href=&#34;http://msdn.microsoft.com/en-us/library/ee370357.aspx&#34;&gt;agents&lt;/a&gt; and they help immensely in the concurrency
and message passing, but that doest mean that we cant take advantage of the new features and refinements
much in the same way as we can use Asynchronous Workflows to take advantage of Tasks.&lt;/p&gt;

&lt;p&gt;This post is going to be centered around F# agents but with a twist.  First of all are going to be
reimplementing a MailboxProcessor using TDF for the underlying processing.  This will allow us to to use
all of our existing agent code and examples and also stay within the F# agent paradigm.  Following this
approach we could also make use of the &lt;code&gt;DataflowBlockOptions&lt;/code&gt; type, it has some interesting
properties which we will look at in future posts:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;TaskScheduler&lt;/li&gt;
&lt;li&gt;CancellationToken&lt;/li&gt;
&lt;li&gt;MaxMessagesPerTask&lt;/li&gt;
&lt;li&gt;BoundedCapacity&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&#34;implementation&#34;&gt;Implementation&lt;/h3&gt;

&lt;p&gt;In this post we are going replicate the MailboxProcessor, we will be using Tomas Petricek&amp;rsquo;s caching agent
example from &lt;a href=&#34;http://fssnip.net/8V&#34;&gt;FSSnip&lt;/a&gt;).  I have made a couple of modification to Tomas&amp;rsquo;s code.&lt;br /&gt;
I replaced the Dictionary type with a ConcurrentDictionary so that the caching agent could be called multiple
times successively without the dictionary throwing an exception due to it already containing a key from a
previous cached result.  I also changed the example code so that it requests cached HTML from the caching
agent ten times with a 400ms interval in between each.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-fsharp&#34;&gt;module TplAgents
open System
open System.Collections.Generic
open System.Collections.Concurrent
open FsDataflow
open System.Net
open Microsoft.FSharp.Control.WebExtensions

type CachingMessage =
    | Add of string * string
    | Get of string * AsyncReplyChannel&amp;lt;option&amp;lt;string&amp;gt;&amp;gt;
    | Clear

let caching = DataflowAgent.Start(fun agent -&amp;gt; async {
   let table = ConcurrentDictionary&amp;lt;string, string&amp;gt;()
   while true do
      let! msg = agent.Receive()
      match msg with
      | Add(url, html) -&amp;gt; 
         // Add downloaded page to the cache
         table.AddOrUpdate(url, html, fun k v -&amp;gt; html) |&amp;gt; ignore
      | Get(url, repl) -&amp;gt; 
         // Get a page from the cache - returns 
         // None if the value isn&#39;t in the cache
         if table.ContainsKey(url) then
            repl.Reply(Some table.[url])
         else
            repl.Reply(None) 
      | Clear -&amp;gt; 
           table.Clear() })
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&#34;language-fsharp&#34;&gt;/// Prints information about the specified web site using cache
let printInfo url = async {
   // Try to get the cached HTML from the caching agent
   let! htmlOpt = caching.PostAndAsyncReply(fun ch -&amp;gt; Get(url, ch))
   match htmlOpt with
   | None -&amp;gt;
       // New url - download it and add it to the cache
       use wc = new WebClient()
       let! text = wc.AsyncDownloadString(Uri(url))
       caching.Post(Add(url, text))   
       Console.WriteLine( sprintf &amp;quot;Download: %s (%d)&amp;quot; url text.Length)
   | Some html -&amp;gt;
       // The url was downloaded earlier 
       Console.WriteLine( sprintf &amp;quot;Cached: %s (%d)&amp;quot; url html.Length) }

let printfuncpro = printInfo &amp;quot;http://functional-programming.net&amp;quot;
// Print information about a web site -
// Run this repeatedly to use cached value
for i in 1 .. 10 do
   printfuncpro |&amp;gt; Async.Start
   Async.RunSynchronously &amp;lt;| Async.Sleep 400

// Clear the cache - &#39;printInfo&#39; will need to
// download data from the web site again
Console.WriteLine(sprintf &amp;quot;Clearing the cache&amp;quot;)
caching.Post(Clear)
printfuncpro |&amp;gt; Async.Start

Console.ReadKey() |&amp;gt; ignore
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Looking at the implementation above you can see that we need to implement the following members:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Start:&lt;code&gt;unit -&amp;gt; unit&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;Receive:&lt;code&gt;?int -&amp;gt; Async&amp;lt;&#39;Msg&amp;gt;&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;Post:&lt;code&gt;&#39;Msg -&amp;gt; unit&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;PostAndTryAsyncReply:&lt;code&gt;(AsyncReplyChannel&amp;lt;&#39;Reply&amp;gt; -&amp;gt; &#39;Msg) * ?int -&amp;gt; Async&amp;lt;&#39;Reply option&amp;gt;&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;PostAndAsyncReply:&lt;code&gt;(AsyncReplyChannel&amp;lt;&#39;Reply&amp;gt; -&amp;gt; &#39;Msg) * int option -&amp;gt; Async&amp;lt;&#39;Reply&amp;gt;&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;static member Start:&lt;code&gt;(MailboxProcessor&amp;lt;&#39;Msg&amp;gt; -&amp;gt; Async&amp;lt;unit&amp;gt;) * ?CancellationToken -&amp;gt; MailboxProcessor&amp;lt;&#39;Msg&amp;gt;&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;These are the only members we need to complete the caching agent example, I didn&amp;rsquo;t want bamboozle everyone
with an explosion of code from the onset so the remaining members will be implemented as and when we need
them.  When we have implemented all the members from MailboxProcessor Ill post the full source on my
 &lt;a href=&#34;https://github.com/7sharp9&#34;&gt;GitHub&lt;/a&gt; account.&lt;/p&gt;

&lt;p&gt;The following members will be outstanding but it should be fairly trivial to implement them
 once we have completed the code here.&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;PostAndReply:&lt;code&gt;(AsyncReplyChannel&amp;lt;&#39;Reply&amp;gt; -&amp;gt; &#39;Msg) * int option -&amp;gt; &#39;Reply&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;Scan:&lt;code&gt;(&#39;Msg -&amp;gt; Async&amp;lt;&#39;T&amp;gt; option) * ?int -&amp;gt; Async&amp;lt;&#39;T&amp;gt;&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;TryPostAndReply:&lt;code&gt;(AsyncReplyChannel&amp;lt;&#39;Reply&amp;gt; -&amp;gt; &#39;Msg) * ?int -&amp;gt; &#39;Reply option&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;TryReceive:&lt;code&gt;?int -&amp;gt; Async&amp;lt;&#39;Msg option&amp;gt;&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;TryScan:&lt;code&gt;(&#39;Msg -&amp;gt; Async&amp;lt;&#39;T&amp;gt; option) * ?int -&amp;gt; Async&amp;lt;&#39;T option&amp;gt;&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;CurrentQueueLength:&lt;code&gt;int&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;DefaultTimeout:&lt;code&gt;int with get, set&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;So here we go, this is the Dataflow implementation of the MailboxProcessor:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-fsharp&#34;&gt;module FsDataflow
open System
open System.Threading
open System.Threading.Tasks
open System.Threading.Tasks.Dataflow
open System.Collections.Concurrent

type DataflowAgent&amp;lt;&#39;Msg&amp;gt;(initial, ?cancellationToken) =
    let cancellationToken = 
        defaultArg cancellationToken Async.DefaultCancellationToken
    let mutable started = false
    let errorEvent = new Event&amp;lt;System.Exception&amp;gt;()
    let incomingMessages = new BufferBlock&amp;lt;&#39;Msg&amp;gt;()
    let mutable defaultTimeout = Timeout.Infinite
    
    [&amp;lt;CLIEvent&amp;gt;]
    member this.Error = errorEvent.Publish

    member this.Start() =
        if started 
            then raise (new InvalidOperationException(&amp;quot;Already Started.&amp;quot;))
        else
            started &amp;lt;- true
            let comp = async { try do! initial this 
                               with error -&amp;gt; errorEvent.Trigger error }
            Async.Start(computation = comp, cancellationToken = cancellationToken)

    member this.Receive(?timeout) = 
        Async.AwaitTask &amp;lt;| incomingMessages.ReceiveAsync()

    member this.Post(item) = 
        let posted = incomingMessages.Post(item)
        if not posted then
            raise (InvalidOperationException(&amp;quot;Incoming message buffer full.&amp;quot;))

    member this.PostAndTryAsyncReply(replyChannelMsg, ?timeout) = 
        let timeout = defaultArg timeout defaultTimeout
        let resultCell = AsyncResultCell&amp;lt;_&amp;gt;()
        let msg = replyChannelMsg(AsyncReplyChannel&amp;lt;_&amp;gt;(fun reply -&amp;gt; resultCell.RegisterResult(reply)))
        let posted = incomingMessages.Post(msg)
        if posted then
            match timeout with
            |   Threading.Timeout.Infinite -&amp;gt; 
                    async { let! result = resultCell.AsyncWaitResult
                            return Some(result) }  
            |   _ -&amp;gt;
                    async { let! ok =  resultCell.GetWaitHandle(timeout)
                            let res = (if ok then Some(resultCell.GrabResult()) else None)
                            return res }
        else async{return None}

    member this.PostAndAsyncReply( replyChannelMsg, ?timeout) =                 
            let timeout = defaultArg timeout defaultTimeout
            match timeout with
            |   Threading.Timeout.Infinite -&amp;gt; 
                let resCell = AsyncResultCell&amp;lt;_&amp;gt;()
                let msg = replyChannelMsg (AsyncReplyChannel&amp;lt;_&amp;gt;(fun reply -&amp;gt; resCell.RegisterResult(reply) ))
                let posted = incomingMessages.Post(msg)
                if posted then
                    resCell.AsyncWaitResult  
                else
                    raise (InvalidOperationException(&amp;quot;Incoming message buffer full.&amp;quot;))
            |   _ -&amp;gt;            
                let asyncReply = this.PostAndTryAsyncReply(replyChannelMsg, timeout=timeout) 
                async { let! res = asyncReply
                        match res with 
                        | None -&amp;gt;  return! raise (TimeoutException(&amp;quot;PostAndAsyncReply TimedOut&amp;quot;))
                        | Some res -&amp;gt; return res }           
                    
    static member Start(initial, ?cancellationToken) =
        let dfa = DataflowAgent&amp;lt;&#39;Msg&amp;gt;(initial, ?cancellationToken = cancellationToken)
        dfa.Start()
        dfa
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The crux of the implementation from TDF&amp;rsquo;s point of view is the use of the BufferBlock.&lt;br /&gt;
This is one of the most fundamental blocks within TDF.  Its the equivalent of the &lt;code&gt;Port&amp;lt;&#39;T&amp;gt;&lt;/code&gt;
type from CCR and the &lt;code&gt;Mailbox&lt;/code&gt; type from F# which is used internally within the
MailboxProcessor.  As mentioned abouve the BufferBlock type is a first-in-first-out (FIFO) buffer
and is responsible for buffering any data that is Posted to it.&lt;/p&gt;

&lt;p&gt;OK, I&amp;rsquo;m going to leave it at that for now while you digest the code presented here.&lt;/p&gt;

&lt;p&gt;In part II I will be drilling into the detail on whats going on internally and also describing more
of the TDF model, so tune in soon for Part II.&lt;/p&gt;

&lt;p&gt;Until next time&amp;hellip;&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Fixing a hole...</title>
      <link>http://7sharpnine.com/2011/12/11/2011-12-11-fixing-a-hole/</link>
      <pubDate>Sun, 11 Dec 2011 00:00:00 +0000</pubDate>
      
      <guid>http://7sharpnine.com/2011/12/11/2011-12-11-fixing-a-hole/</guid>
      <description>&lt;p&gt;Due to popular demand&amp;hellip; well, I had a couple of requests anyway :-) Heres
a post inspired by my recent encounters profiling some of the code in
&lt;a href=&#34;https://github.com/fractureio/fracture&#34;&gt;Fracture-IO&lt;/a&gt;.  &lt;!-- more --&gt;I have recently been
profiling the code in fracture to remove any so called low hanging fruits.
During this time I also noticed an increase in memory allocation.  I
remembered I had recently been experimenting in a branch using pipelets as a
buffer between the send and receive stages in the Http Server, so I set up a
simple test to see if pipelets were contributing to the memory allocation
issues I was seeing.  Here&amp;rsquo;s the simple iteration test code I used for the
memory profiling:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-fsharp&#34;&gt;open System
open System.Diagnostics
open System.Threading
open Fracture.Pipelets  
let reverse (s:string) =
  String(s |&amp;gt; Seq.toArray |&amp;gt; Array.rev)  
let oneToSingleton a b f=
  let result = b |&amp;gt; f
  result |&amp;gt; Seq.singleton  
/// Total number to run through test cycle
let number = 100  
/// To Record when we are done
let counter = ref 0
let sw = new Stopwatch()
let countThis (a:String) =
  do Interlocked.Increment(counter) |&amp;gt; ignore
  if !counter % number = 0 then
    sw.Stop()
    printfn &amp;quot;Execution time: %A&amp;quot; sw.Elapsed.TotalMilliseconds
    printfn &amp;quot;Items input: %d&amp;quot; number
    printfn &amp;quot;Time per item: %A ms (Elapsed Time / Number of items)&amp;quot;
      (TimeSpan.FromTicks(sw.Elapsed.Ticks / int64 number).TotalMilliseconds)
    printfn &amp;quot;Press any key to repeat, press &#39;q&#39; to exit.&amp;quot;
    sw.Reset()
  counter |&amp;gt; Seq.singleton  
let OneToSeqRev a b =
  oneToSingleton a b reverse   
let generateCircularSeq (s) =
  let rec next () =
    seq {
      for element in s do
        yield element
      yield! next()
    }
  next()  
    let stage1 = new Pipelet&amp;lt;_,_&amp;gt;(&amp;quot;Stage1&amp;quot;, OneToSeqRev &amp;quot;1&amp;quot;, Routers.roundRobin, number, -1)
    let stage2 = new Pipelet&amp;lt;_,_&amp;gt;(&amp;quot;Stage2&amp;quot;, OneToSeqRev &amp;quot;2&amp;quot;, Routers.basicRouter, number, -1)
    let stage3 = new Pipelet&amp;lt;_,_&amp;gt;(&amp;quot;Stage3&amp;quot;, OneToSeqRev &amp;quot;3&amp;quot;, Routers.basicRouter, number, -1)
    let stage4 = new Pipelet&amp;lt;_,_&amp;gt;(&amp;quot;Stage4&amp;quot;, OneToSeqRev &amp;quot;4&amp;quot;, Routers.basicRouter, number, -1)
    let stage5 = new Pipelet&amp;lt;_,_&amp;gt;(&amp;quot;Stage5&amp;quot;, OneToSeqRev &amp;quot;5&amp;quot;, Routers.basicRouter, number, -1)
    let stage6 = new Pipelet&amp;lt;_,_&amp;gt;(&amp;quot;Stage6&amp;quot;, OneToSeqRev &amp;quot;6&amp;quot;, Routers.basicRouter, number, -1)
    let stage7 = new Pipelet&amp;lt;_,_&amp;gt;(&amp;quot;Stage7&amp;quot;, OneToSeqRev &amp;quot;7&amp;quot;, Routers.basicRouter, number, -1)
    let stage8 = new Pipelet&amp;lt;_,_&amp;gt;(&amp;quot;Stage8&amp;quot;, OneToSeqRev &amp;quot;8&amp;quot;, Routers.basicRouter, number, -1)
    let stage9 = new Pipelet&amp;lt;_,_&amp;gt;(&amp;quot;Stage9&amp;quot;, OneToSeqRev &amp;quot;9&amp;quot;, Routers.basicRouter, number, -1)
    let stage10 = new Pipelet&amp;lt;_,_&amp;gt;(&amp;quot;Stage10&amp;quot;, OneToSeqRev &amp;quot;10&amp;quot;, Routers.basicRouter, number, -1)
    let final = new Pipelet&amp;lt;_,_&amp;gt;(&amp;quot;Final&amp;quot;, countThis, Routers.basicRouter, number, -1)  
    let manyStages = [stage2;stage3;stage4;stage5;stage6;stage7;stage8;stage9;stage10]  
    oneToMany stage1 manyStages
    manyToOne manyStages final  
    System.AppDomain.CurrentDomain.UnhandledException |&amp;gt; Observable.add (fun x -&amp;gt;
      printfn &amp;quot;%A&amp;quot; (x.ExceptionObject :?&amp;gt; Exception); Console.ReadKey() |&amp;gt; ignore)  
    let circ = [&amp;quot;John&amp;quot;; &amp;quot;Paul&amp;quot;; &amp;quot;George&amp;quot;; &amp;quot;Ringo&amp;quot;; &amp;quot;Nord&amp;quot;; &amp;quot;Bert&amp;quot;] |&amp;gt; generateCircularSeq   
    let startoperations() =
      sw.Start()
      for str in circ |&amp;gt; Seq.take number
        do  str --&amp;gt; stage1
      printfn &amp;quot;Insert complete waiting for operation to complete.&amp;quot;  
    printfn &amp;quot;Press any key to process %i items&amp;quot; number
    while not (Console.ReadKey().Key = ConsoleKey.Q) do
      startoperations()
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Using process explorer from Mark Russinovich I watched the allocated memory
grow as the iterations progressed:&lt;/p&gt;


&lt;figure &gt;
    
        &lt;img src=&#34;https://lh4.googleusercontent.com/-VP1-Vo2VINU/TuS7yZFTTlI/AAAAAAAABNw/3ksn5vNXTtw/s400/leak.png&#34; /&gt;
    
    
&lt;/figure&gt;


&lt;p&gt;Theres definitely something leaking in there! So what can we do to find this?
Simple, we use a memory profiler.  There are several really good memory
profilers out there.  I have listed some of the best ones below:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;http://memprofiler.com/&#34;&gt;SciTech memory profiler&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://www.red-gate.com/products/dotnet-development/ants-memory-profiler/&#34;&gt;RedGates ANTS Memory Profiler&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://www.jetbrains.com/profiler/&#34;&gt;JetBrains dotTrace&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://www.yourkit.com/dotnet/features/index.jsp&#34;&gt;YourKit Profiler for .NET&lt;/a&gt;
To demonstrate finding the leak I will be using &lt;a href=&#34;http://www.red-gate.com/products/dotnet-development/ants-memory-
profiler/&#34;&gt;RedGates ANTS MemoryProfiler&lt;/a&gt;.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;First of all we launch the profiler and set it up to profile the application,
this is just a simple case of browsing to the release folder and picking the
application so I won&amp;rsquo;t bore with those trivial details here. Now that the
application is running we hit any key which caused the test application to
post 100 operations into the pipeline.  We want to create a baseline snapshot
of the memory allocation so we can see where our leak is.  To do this click
Take Memory Snapshot at the top right of the screen.  Next we hit any key
again in the test application, again causing it to post another 100 operations
into the pipeline.  Now we click Take Memory Snapshot again. Now we have a
snapshot of the difference between the two operations.  The summery screen is
shown below:&lt;/p&gt;


&lt;figure &gt;
    
        &lt;img src=&#34;https://lh4.googleusercontent.com/-N72POVbq0ZA/TuS7v0xBt1I/AAAAAAAABNQ/ExKfkJDCb50/s912/3%2Bsummary.png&#34; /&gt;
    
    
&lt;/figure&gt;


&lt;p&gt;From this screen you can see that there is 51.56KB of new memory allocated
since the last snapshot, and you can see some nice piecharts showing the
various allocations in G1, G2 etc.  On the right hand side of the pie chart
you can see that the largest classes are: object[], AsyncParamsAux,
Pipelets+loop@37-7&lt;Unit, string,string&gt;, and AsyncParams&lt;Unit&gt;.&lt;/p&gt;

&lt;p&gt;Now if we click on Class List button we can investigate these further, heres
the Class List:&lt;/p&gt;


&lt;figure &gt;
    
        &lt;img src=&#34;https://lh4.googleusercontent.com/-UDU20rPk7ck/TuS7xvK_67I/AAAAAAAABNg/tnxTlpBYBJg/s912/4%2Bclass%2Blist.png&#34; /&gt;
    
    
&lt;/figure&gt;


&lt;p&gt;Here things start to get interesting.  If you click on the instance Diff (+/-)
column you can sort the list of classed by the differences to the last
snapshot.&lt;/p&gt;

&lt;p&gt;Now looking at the results we have:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;300 more instances of AsyncBuilderImpl, AsyncParamsArgs, and AsyncParams&lt;/li&gt;
&lt;li&gt;200 more instances of Pipelets+loop@37-7&lt;Unit, string, string&gt;&lt;/li&gt;
&lt;li&gt;100 more instances of Pipelets+loop@37-7&lt;Unit, string, FSharpRef&lt;int&gt;&amp;gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Is it a coincidence that we just pushed 100 operations through the pipeline?
I think not!&lt;/p&gt;

&lt;p&gt;Now that we have a target for further inspection we can highlight the row for
the function &lt;strong&gt;Pipelets+loop@37-7&lt;Unit, string, FSharpRef&lt;int&gt;&amp;gt;&amp;gt;&lt;/strong&gt; and then
click on the icon that has three little blue boxes on it.  This will take us
to the instance List as shown below:&lt;/p&gt;


&lt;figure &gt;
    
        &lt;img src=&#34;https://lh6.googleusercontent.com/-csF589rWobQ/TuS7wzT6NWI/AAAAAAAABNY/TM95SUmaCEQ/s912/5%2Binstance%2Blist.png&#34; /&gt;
    
    
&lt;/figure&gt;


&lt;p&gt;I have sorted the instance list by the distance from the GC Root, you can see
there is a strange pattern emerging, the GC root distant increase by three
each time.  Now lets look at the Instance Retention graph for the first one
with a GC Root distance of 9, this is the icon on the right hand side of the
function name, it looks like a few rectangles joined up with a line:&lt;/p&gt;


&lt;figure &gt;
    
        &lt;img src=&#34;https://lh3.googleusercontent.com/-9orgQ4etsdI/TuS7yE-Dh7I/AAAAAAAABNs/0-dc3x8u-Mo/s525/first.png&#34; /&gt;
    
    
&lt;/figure&gt;


&lt;p&gt;The Pipelets+loop function is linked from the mailbox processor shown at the
top of the graph and flows into the Async infrastructure, and finally to the
loop function at the bottom.&lt;/p&gt;

&lt;p&gt;Lets look at the next one, this has a GC Root distance of 12:&lt;/p&gt;


&lt;figure &gt;
    
        &lt;img src=&#34;https://lh3.googleusercontent.com/-j1eALRVz0kA/TuS7z0ycXDI/AAAAAAAABN8/SGPVpPQbSz0/s531/second.png&#34; /&gt;
    
    
&lt;/figure&gt;


&lt;p&gt;If you look carefully there is another pattern here, the field references
args, aux@, econt@ are repeated in the red boxes.  The functions look to be
quite similar too.  Lets look at the next one GC Root Distance  of 15:&lt;/p&gt;


&lt;figure &gt;
    
        &lt;img src=&#34;https://lh6.googleusercontent.com/-d3V1WkCktTM/TuS7zxVnizI/AAAAAAAABOA/wA5xlP-UTxA/s646/third.png&#34; /&gt;
    
    
&lt;/figure&gt;


&lt;p&gt;Looking at this we have a definite repeat of the functions and arguments,  if
we look down to GC Root at a depth of 60 we get this:&lt;/p&gt;


&lt;figure &gt;
    
        &lt;img src=&#34;https://lh3.googleusercontent.com/-X3v-_UfEkI4/TuS7xzETTHI/AAAAAAAABNk/js7xg3GTHIo/s640/60.png&#34; /&gt;
    
    
&lt;/figure&gt;


&lt;p&gt;So whats happening here is that there is a continuation that has been built
around the asynchronous calls that gets bigger and bigger on each iteration.&lt;/p&gt;

&lt;p&gt;Now that we have identified the leak, lets look at the code and see whats
going on.  That would be the loop function in Pipelets:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-fsharp&#34;&gt;let mailbox = MailboxProcessor.Start(fun inbox -&amp;gt;
  let rec loop routes = async {
    let! msg = inbox.Receive()
    match msg with
    | Payload(data) -&amp;gt;
      ss.Release() |&amp;gt; ignore
      try
        data |&amp;gt; transform |&amp;gt; router &amp;lt;| routes
        return! loop routes
      with //force loop resume on error
      | ex -&amp;gt; errors ex
          return! loop routes
    | Attach(stage) -&amp;gt; return! loop (stage::routes)
    | Detach(stage) -&amp;gt; return! loop (List.filter (fun x -&amp;gt; x &amp;lt;&amp;gt; stage) routes)
  }
  loop [])
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Have a look at lines 9 and 12.  Can you guess whats wrong?&lt;/p&gt;

&lt;p&gt;Well, to quote the &lt;a href=&#34;http://blogs.msdn.com/b/fsharpteam/archive/2011/07/08/tail-calls-in-fsharp.aspx&#34;&gt;F# Teams blog&lt;/a&gt;:&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;On the .NET platform, there are limitations on where tail calls may occur.
One restriction is that tail calls cannot be performed in try-catch or try-
finally blocks (neither in the body of the try nor in the catch or finally
handlers).&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;It goes on further to discuss another subtle issue with use bindings:&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;use bindings implicitly generate a try-finally around the code that follows
them to ensure that the Dispose method is called on the bound value.  This
means that no calls following a use binding will be tail calls.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;So all we have to do change the way the try catch block is formulated in that
section.  The most idiomatic way of dealing with this is to use the
&lt;a href=&#34;http://msdn.microsoft.com/en-us/library/ee353899.aspx&#34;&gt;Async.Catch function&lt;/a&gt;
which would result in code something like the following:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-fsharp&#34;&gt;let mailbox = MailboxProcessor.Start(fun inbox -&amp;gt;
  let rec loop routes = async {
    let! msg = inbox.Receive()
    match msg with
    | Payload(data) -&amp;gt;
      ss.Release() |&amp;gt; ignore
      let result = async{data |&amp;gt; transform |&amp;gt; router &amp;lt;| routes} 
      |&amp;gt; Async.Catch 
      |&amp;gt; Async.RunSynchronously
      match result with
      | Choice1Of2() -&amp;gt; ()
      | Choice2Of2 exn -&amp;gt; errors exn
      return! loop routes
    | Attach(stage) -&amp;gt; return! loop (stage::routes)
    | Detach(stage) -&amp;gt; return! loop (List.filter (fun x -&amp;gt; x &amp;lt;&amp;gt; stage) routes)
  }
  loop [])
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Alternatively you could move the entire try with section out to a more local
section thats not in the recursive async loop construct:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-fsharp&#34;&gt;let computeAndRoute data routes =
  try
    data |&amp;gt; transform |&amp;gt; router &amp;lt;| routes
    Choice1Of2()
  with
  | ex -&amp;gt; Choice2Of2 ex  

let mailbox = MailboxProcessor.Start(fun inbox -&amp;gt;
  let rec loop routes = async {
    let! msg = inbox.Receive()
    match msg with
    | Payload(data) -&amp;gt;
      ss.Release() |&amp;gt; ignore
      match computeAndRoute data routes with
      | Choice2Of2 exn -&amp;gt; errors exn
      | _ -&amp;gt; ()
      return! loop routes
    | Attach(stage) -&amp;gt; return! loop (stage::routes)
    | Detach(stage) -&amp;gt; return! loop (List.filter (fun x -&amp;gt; x &amp;lt;&amp;gt; stage) routes)}
  loop [])
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Anyway I hope that sheds a bit of light on how to spot where memory leaks are
stemming from, and also some of the little known and often forgotten caveats
with tail recursion.&lt;/p&gt;

&lt;p&gt;Until next time&amp;hellip;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;EDIT&lt;/strong&gt;: Just to make things a little bit clearer.  The memory leak here is caused by the async block being transformed into chains of continuation passing-style functions, and due to tail call elimination not being possible inside of the try catch blocks, the continuation grows and grows during each recursion.&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Agent based scheduling</title>
      <link>http://7sharpnine.com/2011/07/03/2011-07-03-agent-based-scheduling/</link>
      <pubDate>Sun, 03 Jul 2011 00:00:00 +0000</pubDate>
      
      <guid>http://7sharpnine.com/2011/07/03/2011-07-03-agent-based-scheduling/</guid>
      <description>

&lt;p&gt;One of the areas that I am very interested in is agents and I have been doing
quite a lot of work in this area lately.&lt;/p&gt;

&lt;p&gt;Agents can be used for a multitude of different purposes ranging from:
isolated message passing, object caching, finite state machines, web crawling,
and even reactive user interfaces.  One of the ideas that I have been looking
into lately is agent based scheduling.&lt;!-- more --&gt;&lt;/p&gt;

&lt;h2 id=&#34;scheduleragent&#34;&gt;SchedulerAgent&lt;/h2&gt;

&lt;p&gt;A simple Agent based scheduler:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-fsharp&#34;&gt;    module AgentUtilities
    open System
    open System.Threading 
 
    //Agent alias for MailboxProcessor
    type Agent&amp;lt;&#39;T&amp;gt; = MailboxProcessor&amp;lt;&#39;T&amp;gt; 
 
    /// Two types of Schedule messages that can be sent
    type ScheduleMessage&amp;lt;&#39;a&amp;gt; =
      | Schedule of (&#39;a -&amp;gt; unit) * &#39;a * TimeSpan * TimeSpan * CancellationTokenSource AsyncReplyChannel
      | ScheduleOnce of (&#39;a -&amp;gt; unit) * &#39;a * TimeSpan * CancellationTokenSource AsyncReplyChannel
  
    /// An Agent based scheduler
    type SchedulerAgent&amp;lt;&#39;a&amp;gt;()=   
      let scheduleOnce delay msg receiver (cts: CancellationTokenSource)=
        async { do! Async.Sleep(delay)
            if (cts.IsCancellationRequested)
            then cts.Dispose()
            else msg |&amp;gt; receiver }  
      let scheduleMany initialDelay  msg receiver delayBetween cts=
        let rec loop time (cts: CancellationTokenSource) =
           async { do! Async.Sleep(time)
               if (cts.IsCancellationRequested)
               then cts.Dispose()
               else msg |&amp;gt; receiver
               return! loop delayBetween cts}
        loop initialDelay cts  
      let scheduler = Agent.Start(fun inbox -&amp;gt;
        let rec loop() = async {
          let! msg = inbox.Receive()
          let cs = new CancellationTokenSource()
          match msg with
          | Schedule(receiver, msg:&#39;a, initialDelay, delayBetween, replyChan) -&amp;gt;
            Async.StartImmediate(scheduleMany
                         (int initialDelay.TotalMilliseconds)
                         msg
                         receiver
                         (int delayBetween.TotalMilliseconds)
                         cs )
            replyChan.Reply(cs)
            return! loop()
          | ScheduleOnce(receiver, msg:&#39;a, delay, replyChan) -&amp;gt;
            Async.StartImmediate(scheduleOnce
                         (int delay.TotalMilliseconds)
                         msg
                         receiver
                         cs)
            replyChan.Reply(cs)
            return! loop()
        }
        loop())  
      ///Schedules a message to be sent to the receiver after the initialDelay.
      ///  If delaybetween is specified then the message is sent reoccuringly at the delaybetween interval.
      member this.Schedule(receiver, msg, initialDelay, ?delayBetween) =
        let buildMessage replyChan =
          match delayBetween with
          | Some(x) -&amp;gt; Schedule(receiver,msg,initialDelay, x, replyChan)
          | _ -&amp;gt; ScheduleOnce(receiver,msg,initialDelay, replyChan)
        scheduler.PostAndReply (fun replyChan -&amp;gt; replyChan |&amp;gt; buildMessage)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The structure of the SchedulerAgent broken down into sections below:&lt;/p&gt;

&lt;h3 id=&#34;schedulemessage&#34;&gt;ScheduleMessage&lt;/h3&gt;

&lt;p&gt;Lines &lt;strong&gt;9-11&lt;/strong&gt; (&lt;code&gt;type ScheduleMessage&amp;lt;&#39;a&amp;gt; =&lt;/code&gt;) show the definition of ScheduleMessage.  This is a discriminated
union of two different types of Schedule message.&lt;/p&gt;

&lt;h4 id=&#34;scheduleonce&#34;&gt;ScheduleOnce&lt;/h4&gt;

&lt;p&gt;ScheduleOnce has four parameters:&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;A function which is called at the schedule time (&amp;lsquo;a -&amp;gt; unit).&lt;/li&gt;
&lt;li&gt;The message that is sent at the schedules time (&amp;lsquo;a).&lt;/li&gt;
&lt;li&gt;A TimeSpan which is the length of time to wait before triggering the schedule.&lt;/li&gt;
&lt;li&gt;An AsyncReplyChannel&lt;CancellationTokenSource&gt;(CancellationTokenSource AsyncReplyChannel).  This is used to return a CancellationTokenSource which can be used to cancel the Schedule.&lt;/li&gt;
&lt;/ol&gt;

&lt;h4 id=&#34;schedule&#34;&gt;Schedule&lt;/h4&gt;

&lt;p&gt;Schedule has five parameters which are as follows:&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;A function which is called at the schedule time (&amp;lsquo;a -&amp;gt; unit).&lt;/li&gt;
&lt;li&gt;The message that is sent at the schedules time (&amp;lsquo;a).&lt;/li&gt;
&lt;li&gt;A TimeSpan which is the initial length of time to wait before first triggering the schedule function.&lt;/li&gt;
&lt;li&gt;A TimeSpan which is used as an interval between each subsequent triggering of the schedule function.&lt;/li&gt;
&lt;li&gt;An AsyncReplyChannel&lt;CancellationTokenSource&gt;(CancellationTokenSource AsyncReplyChannel).  This is used to return a CancellationTokenSource which can be used to cancel the Schedule.&lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id=&#34;scheduleragent-1&#34;&gt;SchedulerAgent&lt;/h2&gt;

&lt;h3 id=&#34;scheduleonce-1&#34;&gt;scheduleOnce&lt;/h3&gt;

&lt;p&gt;Lines &lt;strong&gt;16-20&lt;/strong&gt; define an async workflow, which asynchronously sleeps for the specified time before checking that the schedule hasn&amp;rsquo;t been cancelled before finally calling the schedule function.&lt;/p&gt;

&lt;h3 id=&#34;schedulemany&#34;&gt;scheduleMany&lt;/h3&gt;

&lt;p&gt;Lines &lt;strong&gt;22-29&lt;/strong&gt; define a recursive async workflow, which asynchronously sleeps for the specified interval (&lt;em&gt;3rd Parameter&lt;/em&gt;) before checking the schedule hasn&amp;rsquo;t been cancelled before finally calling the schedule function. The &lt;strong&gt;loop&lt;/strong&gt; function is then called passing in the second TimeSpan interval &lt;em&gt;(4th Parameter)&lt;/em&gt;.&lt;/p&gt;

&lt;h3 id=&#34;scheduler&#34;&gt;scheduler&lt;/h3&gt;

&lt;p&gt;This is the main processing loop for the agent.  A recursive &lt;strong&gt;loop&lt;/strong&gt; function
is declared on line &lt;strong&gt;32&lt;/strong&gt;.  On line &lt;strong&gt;33&lt;/strong&gt; the agent waits for a message
to arrive.  Once a message arrives a &lt;strong&gt;CancellationTokenSource&lt;/strong&gt; is created on
line &lt;strong&gt;36&lt;/strong&gt; which can be used to cancel an already scheduled message.
Pattern matching is used on line &lt;strong&gt;35&lt;/strong&gt; to find the type of message that has
been received.  The first pattern matching block on lines &lt;strong&gt;36-43&lt;/strong&gt; matches
the &lt;strong&gt;Schedule&lt;/strong&gt; message.  The parameters from the Schedule message are passed
into the &lt;strong&gt;scheduleMany&lt;/strong&gt; function.  This is then invoked asynchronously via
the &lt;strong&gt;Async.StartImmediate&lt;/strong&gt; function.  The CancellationTokenSource is now
returned to the caller on line &lt;strong&gt;43&lt;/strong&gt;. This allows the caller to cancel an
already running schedule.   Finally the recursive &lt;strong&gt;loop&lt;/strong&gt; function is called
on line &lt;strong&gt;44&lt;/strong&gt;.  The second pattern matching block on lines &lt;strong&gt;45-52&lt;/strong&gt; is much
the same passing the parameters from the &lt;strong&gt;ScheduleOnce&lt;/strong&gt; message into the
&lt;strong&gt;scheduleOnce&lt;/strong&gt; function, again this is invoked via the
&lt;strong&gt;Async.StartImmediate&lt;/strong&gt; function.  Like the Schedule message the
CancellationTokenSource returned on line &lt;strong&gt;51&lt;/strong&gt; and the recursive &lt;strong&gt;loop&lt;/strong&gt;
function is called on line &lt;strong&gt;52&lt;/strong&gt;.&lt;/p&gt;

&lt;p&gt;The agent is then started on line &lt;strong&gt;51&lt;/strong&gt; by calling the &lt;strong&gt;loop&lt;/strong&gt; function for the first time.&lt;/p&gt;

&lt;h3 id=&#34;members&#34;&gt;Members&lt;/h3&gt;

&lt;p&gt;The SchedulerAgent has only a single member &lt;strong&gt;Schedule&lt;/strong&gt;.  This member
function takes three parameters and an optional parameter &lt;strong&gt;delayBetween&lt;/strong&gt;.  A
function called &lt;strong&gt;buildMessage&lt;/strong&gt; on line &lt;strong&gt;59&lt;/strong&gt; uses the optional parameter
with pattern matching to determine whether a &lt;strong&gt;ScheduleOnce&lt;/strong&gt; or a
&lt;strong&gt;Schedule&lt;/strong&gt; message is created.  The agent is posted the correct message type
on line &lt;strong&gt;63&lt;/strong&gt; using the synchronous call scheduler.PostAndReply.  We use a
synchronous call to return the cancellationTokenSource immediately, and this
can be used to cancel a running schedule.&lt;/p&gt;

&lt;h2 id=&#34;sample-application&#34;&gt;Sample Application&lt;/h2&gt;

&lt;p&gt;Shows a test harness that creates and uses a simple string based message scheduler:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-fsharp&#34;&gt;    open AgentUtilities
    open System
    open System.Threading  
    let scheduler = SchedulerAgent&amp;lt;_&amp;gt;()
    let printer message =
      printfn &amp;quot;%s: %s&amp;quot; (DateTime.Now.TimeOfDay.ToString()) message  
    let singlecancel = scheduler.Schedule(printer,
                        &amp;quot;Hello from the scheduler&amp;quot;,
                        TimeSpan(0,0,0,5))  
    let multicancel = scheduler.Schedule( printer,
                        &amp;quot;Hello from the multi scheduler&amp;quot;,
                        TimeSpan(0,0,0,5),
                        TimeSpan(0,0,0,0,500))  
    printfn &amp;quot;Press any key to cancel.&amp;quot;
    Console.ReadKey() |&amp;gt; ignore  
    //Cancel the multi scheduler
    multicancel.Cancel()
    printfn &amp;quot;Cancelled, press any key to exit.&amp;quot;
    Console.ReadKey() |&amp;gt; ignore
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;I hope this gives you a feel for what you can do with agent based scheduling.
The library here could be expanded further in several ways.  You could replace
the fixed message with a message generator function or even an agent based
message generator.  If the schedule function was abstracted somewhat it could
be made to accept an agent as the receiver.&lt;/p&gt;

&lt;p&gt;One of the key areas I am looking at is building a distributed agent library
that would allow an agent to communicate over network layers transparently.  A
scheduler agent would be even more powerful in this environment.  I could
envisage them used for a many different things in this environment:  heart
beat messages, performance sampling, diagnostics and testing.&lt;/p&gt;

&lt;p&gt;Until next time&amp;hellip;&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title> Agents and ObjectPools</title>
      <link>http://7sharpnine.com/2011/06/05/2011-06-05-agents-and-objectpools/</link>
      <pubDate>Sun, 05 Jun 2011 00:00:00 +0000</pubDate>
      
      <guid>http://7sharpnine.com/2011/06/05/2011-06-05-agents-and-objectpools/</guid>
      <description>&lt;p&gt;Everyone knows F# agents are cool right?  Well here&amp;rsquo;s yet another example of how versatile they can be&amp;hellip;&lt;/p&gt;

&lt;p&gt;There was a series of posts last April by Stephen Toub from the &lt;a href=&#34;http://blogs.msdn.com/b/pfxteam/&#34;&gt;pfxteam&lt;/a&gt; at Microsoft.  I was reading
through some of the posts again the other day and thought some of the ideas presented there would make interesting projects in F# to demonstrate the
flexibility and succinctness of the language.  I thought the &lt;a href=&#34;http://blogs.msdn.com/b/pfxteam/archive/2010/04/13/9990427.aspx&#34;&gt;ObjectPool&lt;/a&gt;
example would make an interesting project in F# using agents aka MailboxProcessors.  An ObjectPool is basically a pool of objects that have been
pre-created so that you can grab one and use it, and then place it back in the pool when you&amp;rsquo;re finished.  They are useful in situations where the cost of
creating object from scratch is very high or you want to cut down on allocations in the garbage collector.&lt;!-- more --&gt;&lt;/p&gt;

&lt;p&gt;First of all heres the C# code as it was presented in the Parallel Extensions download:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;using System.Collections.Generic;
using System.Diagnostics;  
namespace System.Collections.Concurrent
{
  /// &amp;lt;summary&amp;gt;Provides a thread-safe object pool.&amp;lt;/summary&amp;gt;
  /// &amp;lt;typeparam name=&amp;quot;T&amp;quot;&amp;gt;Specifies the type of the elements stored in the pool.&amp;lt;/typeparam&amp;gt;
  [DebuggerDisplay(&amp;quot;Count={Count}&amp;quot;)]
  [DebuggerTypeProxy(typeof(IProducerConsumerCollection_DebugView&amp;lt;&amp;gt;))]
  public sealed class ObjectPool&amp;lt;T&amp;gt; : ProducerConsumerCollectionBase&amp;lt;T&amp;gt;
  {
    private readonly Func&amp;lt;T&amp;gt; _generator;  
    /// &amp;lt;summary&amp;gt;Initializes an instance of the ObjectPool class.&amp;lt;/summary&amp;gt;
    /// &amp;lt;param name=&amp;quot;generator&amp;quot;&amp;gt;The function used to create items when no items exist in the pool.&amp;lt;/param&amp;gt;
    public ObjectPool(Func&amp;lt;T&amp;gt; generator) : this(generator, new ConcurrentQueue&amp;lt;T&amp;gt;()) { }  
    /// &amp;lt;summary&amp;gt;Initializes an instance of the ObjectPool class.&amp;lt;/summary&amp;gt;
    /// &amp;lt;param name=&amp;quot;generator&amp;quot;&amp;gt;The function used to create items when no items exist in the pool.&amp;lt;/param&amp;gt;
    /// &amp;lt;param name=&amp;quot;collection&amp;quot;&amp;gt;The collection used to store the elements of the pool.&amp;lt;/param&amp;gt;
    public ObjectPool(Func&amp;lt;T&amp;gt; generator, IProducerConsumerCollection&amp;lt;T&amp;gt; collection)
      : base(collection)
    {
      if (generator == null) throw new ArgumentNullException(&amp;quot;generator&amp;quot;);
      _generator = generator;
    }  
    /// &amp;lt;summary&amp;gt;Adds the provided item into the pool.&amp;lt;/summary&amp;gt;
    /// &amp;lt;param name=&amp;quot;item&amp;quot;&amp;gt;The item to be added.&amp;lt;/param&amp;gt;
    public void PutObject(T item) { base.TryAdd(item); }  
    /// &amp;lt;summary&amp;gt;Gets an item from the pool.&amp;lt;/summary&amp;gt;
    /// &amp;lt;returns&amp;gt;The removed or created item.&amp;lt;/returns&amp;gt;
    /// &amp;lt;remarks&amp;gt;If the pool is empty, a new item will be created and returned.&amp;lt;/remarks&amp;gt;
    public T GetObject()
    {
      T value;
      return base.TryTake(out value) ? value : _generator();
    }  
    /// &amp;lt;summary&amp;gt;Clears the object pool, returning all of the data that was in the pool.&amp;lt;/summary&amp;gt;
    /// &amp;lt;returns&amp;gt;An array containing all of the elements in the pool.&amp;lt;/returns&amp;gt;
    public T[] ToArrayAndClear()
    {
      var items = new List&amp;lt;T&amp;gt;();
      T value;
      while (base.TryTake(out value)) items.Add(value);
      return items.ToArray();
    }  
    protected override bool TryAdd(T item)
    {
      PutObject(item);
      return true;
    }  
    protected override bool TryTake(out T item)
    {
      item = GetObject();
      return true;
    }
  }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;There&amp;rsquo;s also a base class which looks like this:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;/// &amp;lt;summary&amp;gt;
/// Provides a base implementation for producer-consumer collections that wrap other
/// producer-consumer collections.
/// &amp;lt;/summary&amp;gt;
/// &amp;lt;typeparam name=&amp;quot;T&amp;quot;&amp;gt;Specifies the type of elements in the collection.&amp;lt;/typeparam&amp;gt;
[Serializable]
public abstract class ProducerConsumerCollectionBase&amp;lt;T&amp;gt; : IProducerConsumerCollection&amp;lt;T&amp;gt;
{
private readonly IProducerConsumerCollection&amp;lt;T&amp;gt; _contained;  
/// &amp;lt;summary&amp;gt;Initializes the ProducerConsumerCollectionBase instance.&amp;lt;/summary&amp;gt;
/// &amp;lt;param name=&amp;quot;contained&amp;quot;&amp;gt;The collection to be wrapped by this instance.&amp;lt;/param&amp;gt;
protected ProducerConsumerCollectionBase(IProducerConsumerCollection&amp;lt;T&amp;gt; contained)
{
  if (contained == null) throw new ArgumentNullException(&amp;quot;contained&amp;quot;);
  _contained = contained;
}  
/// &amp;lt;summary&amp;gt;Gets the contained collection.&amp;lt;/summary&amp;gt;
protected IProducerConsumerCollection&amp;lt;T&amp;gt; ContainedCollection { get { return _contained; } }  
/// &amp;lt;summary&amp;gt;Attempts to add the specified value to the end of the deque.&amp;lt;/summary&amp;gt;
/// &amp;lt;param name=&amp;quot;item&amp;quot;&amp;gt;The item to add.&amp;lt;/param&amp;gt;
/// &amp;lt;returns&amp;gt;true if the item could be added; otherwise, false.&amp;lt;/returns&amp;gt;
protected virtual bool TryAdd(T item) { return _contained.TryAdd(item); }  
/// &amp;lt;summary&amp;gt;Attempts to remove and return an item from the collection.&amp;lt;/summary&amp;gt;
/// &amp;lt;param name=&amp;quot;item&amp;quot;&amp;gt;
/// When this method returns, if the operation was successful, item contains the item removed. If
/// no item was available to be removed, the value is unspecified.
/// &amp;lt;/param&amp;gt;
/// &amp;lt;returns&amp;gt;
/// true if an element was removed and returned from the collection; otherwise, false.
/// &amp;lt;/returns&amp;gt;
protected virtual bool TryTake(out T item) { return _contained.TryTake(out item); }  
/// &amp;lt;summary&amp;gt;Attempts to add the specified value to the end of the deque.&amp;lt;/summary&amp;gt;
/// &amp;lt;param name=&amp;quot;item&amp;quot;&amp;gt;The item to add.&amp;lt;/param&amp;gt;
/// &amp;lt;returns&amp;gt;true if the item could be added; otherwise, false.&amp;lt;/returns&amp;gt;
bool IProducerConsumerCollection&amp;lt;T&amp;gt;.TryAdd(T item) { return TryAdd(item); }  
/// &amp;lt;summary&amp;gt;Attempts to remove and return an item from the collection.&amp;lt;/summary&amp;gt;
/// &amp;lt;param name=&amp;quot;item&amp;quot;&amp;gt;
/// When this method returns, if the operation was successful, item contains the item removed. If
/// no item was available to be removed, the value is unspecified.
/// &amp;lt;/param&amp;gt;
/// &amp;lt;returns&amp;gt;
/// true if an element was removed and returned from the collection; otherwise, false.
/// &amp;lt;/returns&amp;gt;
bool IProducerConsumerCollection&amp;lt;T&amp;gt;.TryTake(out T item) { return TryTake(out item); }  
/// &amp;lt;summary&amp;gt;Gets the number of elements contained in the collection.&amp;lt;/summary&amp;gt;
public int Count { get { return _contained.Count; } }  
/// &amp;lt;summary&amp;gt;Creates an array containing the contents of the collection.&amp;lt;/summary&amp;gt;
/// &amp;lt;returns&amp;gt;The array.&amp;lt;/returns&amp;gt;
public T[] ToArray() { return _contained.ToArray(); }  
/// &amp;lt;summary&amp;gt;Copies the contents of the collection to an array.&amp;lt;/summary&amp;gt;
/// &amp;lt;param name=&amp;quot;array&amp;quot;&amp;gt;The array to which the data should be copied.&amp;lt;/param&amp;gt;
/// &amp;lt;param name=&amp;quot;index&amp;quot;&amp;gt;The starting index at which data should be copied.&amp;lt;/param&amp;gt;
public void CopyTo(T[] array, int index) { _contained.CopyTo(array, index); }  
/// &amp;lt;summary&amp;gt;Copies the contents of the collection to an array.&amp;lt;/summary&amp;gt;
/// &amp;lt;param name=&amp;quot;array&amp;quot;&amp;gt;The array to which the data should be copied.&amp;lt;/param&amp;gt;
/// &amp;lt;param name=&amp;quot;index&amp;quot;&amp;gt;The starting index at which data should be copied.&amp;lt;/param&amp;gt;
void ICollection.CopyTo(Array array, int index) { _contained.CopyTo(array, index); }  
/// &amp;lt;summary&amp;gt;Gets an enumerator for the collection.&amp;lt;/summary&amp;gt;
/// &amp;lt;returns&amp;gt;An enumerator.&amp;lt;/returns&amp;gt;
public IEnumerator&amp;lt;T&amp;gt; GetEnumerator() { return _contained.GetEnumerator(); }  
/// &amp;lt;summary&amp;gt;Gets an enumerator for the collection.&amp;lt;/summary&amp;gt;
/// &amp;lt;returns&amp;gt;An enumerator.&amp;lt;/returns&amp;gt;
IEnumerator IEnumerable.GetEnumerator() { return GetEnumerator(); }  
/// &amp;lt;summary&amp;gt;Gets whether the collection is synchronized.&amp;lt;/summary&amp;gt;
bool ICollection.IsSynchronized { get { return _contained.IsSynchronized; } }  
/// &amp;lt;summary&amp;gt;Gets the synchronization root object for the collection.&amp;lt;/summary&amp;gt;
object ICollection.SyncRoot { get { return _contained.SyncRoot; } }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;Wow!&lt;/strong&gt;  Thats a fair bit of code in C#, fair enough there is a lot of noise in the xml doc comments, but theres also a lot of boiler plate code in there too.&lt;/p&gt;

&lt;p&gt;Ok now we have gotten that out of the way heres the good bit.  &lt;/p&gt;

&lt;p&gt;Below is an agent based design which implements the same functionality but uses a lot less code.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-fsharp&#34;&gt;module Poc

//Agent alias for MailboxProcessor
type Agent&amp;lt;&#39;T&amp;gt; = MailboxProcessor&amp;lt;&#39;T&amp;gt;
 
///One of three messages for our Object Pool agent
type PoolMessage&amp;lt;&#39;a&amp;gt; =
  | Get of AsyncReplyChannel&amp;lt;&#39;a&amp;gt;
  | Put of &#39;a * AsyncReplyChannel&amp;lt;unit&amp;gt;
  | Clear of AsyncReplyChannel&amp;lt;List&amp;lt;&#39;a&amp;gt;&amp;gt;
 
/// Object pool representing a reusable pool of objects
type ObjectPool&amp;lt;&#39;a&amp;gt;(generate: unit -&amp;gt; &#39;a, initialPoolCount) =
  let initial = List.init initialPoolCount (fun (x) -&amp;gt; generate())
  let agent = Agent.Start(fun inbox -&amp;gt;
    let rec loop(x) = async {
      let! msg = inbox.Receive()
      match msg with
      | Get(reply) -&amp;gt;
        let res = match x with
              | a :: b -&amp;gt;
                reply.Reply(a);b
              | [] as empty-&amp;gt;
                reply.Reply(generate());empty
        return! loop(res)
      | Put(value, reply)-&amp;gt;
        reply.Reply()
        return! loop(value :: x)
      | Clear(reply) -&amp;gt;
        reply.Reply(x)
        return! loop(List.empty&amp;lt;&#39;a&amp;gt; )
    }
    loop(initial))  
  /// Clears the object pool, returning all of the data that was in the pool.
  member this.ToListAndClear() =
    agent.PostAndAsyncReply(Clear)
  /// Puts an item into the pool
  member this.Put(item) =
    agent.PostAndAsyncReply((fun ch -&amp;gt; Put(item, ch)))
  /// Gets an item from the pool or if there are none present use the generator
  member this.Get(item) =
    agent.PostAndAsyncReply(Get)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;We have a discriminated union (PoolMessage) which describes the messages that we are going to use with this agent, they are pretty straight forward to follow.  &lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;Get&lt;/strong&gt; simply returns either a stored item or generates a brand new one using the generator function which is passed into the ObjectPools constructor &lt;strong&gt;(generate: unit -&amp;gt; &amp;lsquo;a)&lt;/strong&gt;.  &lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Put&lt;/strong&gt; simply adds the item onto the internal list.&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Clear&lt;/strong&gt; simply returns the current pool and then clears it.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;The core processing all happens in the &lt;strong&gt;async{}&lt;/strong&gt; block, we simply wait for a message to arrive, then we pattern match on one of the messages either Get,Put, or Clear.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Get&lt;/strong&gt; takes an item from the internal list if there are items present, otherwise it invokes the generator function and returns a newly generated object.&lt;/p&gt;

&lt;p&gt;For a &lt;strong&gt;Put&lt;/strong&gt; operation we use the cons &lt;strong&gt;(::)&lt;/strong&gt; operator to add the item onto the internal list via the recursive loop.&lt;/p&gt;

&lt;p&gt;For the &lt;strong&gt;Clear&lt;/strong&gt; operation we return the entire list then return an empty list to the recursive loop.&lt;/p&gt;

&lt;p&gt;I think you will agree this is a nice succinct example of the flexibility and elegance of agents and yet another reason to use F# for more server side
activities.  It&amp;rsquo;s not simply a language for the mathematical and finance orientated developers.&lt;/p&gt;

&lt;p&gt;For anyone interested all of the code should be in my &lt;a href=&#34;http://bit.ly/mDQyfH&#34;&gt;GitHub repository &lt;/a&gt;to download.&lt;/p&gt;

&lt;p&gt;Thanks to &lt;a href=&#34;http://tomasp.net/&#34;&gt;Tomas Petricek&lt;/a&gt; for suggesting using the recursive loop to pass the list rather than using a ref cell and the (&lt;strong&gt;:=&lt;/strong&gt;) operator.&lt;/p&gt;

&lt;p&gt;Until next time&amp;hellip;&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Pipeline processing 3</title>
      <link>http://7sharpnine.com/2011/04/04/2011-04-04-pipeline-processing-3/</link>
      <pubDate>Mon, 04 Apr 2011 00:00:00 +0000</pubDate>
      
      <guid>http://7sharpnine.com/2011/04/04/2011-04-04-pipeline-processing-3/</guid>
      <description>

&lt;p&gt;Ok so I have been offline for a while now, what with starting a new financial contract in London and not having any broadband access for a while.  I have
been working on something, honest!&lt;/p&gt;

&lt;p&gt;Since the last post I have been reflecting on the pipeline design and it had a distinct object orientated feel to it that I wasnt happy with, so I have
amended the structure of the code and come up with the following which simplifies in some areas and expands in others&amp;hellip;&lt;!-- more --&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-fsharp&#34;&gt;module Pipeline
  open System.Collections.Concurrent

  [&amp;lt;Interface&amp;gt;]
  type IPipelineInput&amp;lt;&#39;a&amp;gt; =
    abstract Insert: &#39;a -&amp;gt; unit
 
  [&amp;lt;Interface&amp;gt;]
  type IPipelineConnection&amp;lt;&#39;a&amp;gt; =
    abstract Attach: IPipelineInput&amp;lt;&#39;a&amp;gt; -&amp;gt; unit
    abstract Detach: IPipelineInput&amp;lt;&#39;a&amp;gt; -&amp;gt; unit
 
  [&amp;lt;Interface&amp;gt;]
  type IPipeline&amp;lt;&#39;a,&#39;b&amp;gt; =
    inherit IPipelineConnection&amp;lt;&#39;b&amp;gt;
    inherit IPipelineInput&amp;lt;&#39;a&amp;gt;

  type PipelineStage&amp;lt;&#39;a,&#39;b&amp;gt;(processor, router: seq&amp;lt;IPipelineInput&amp;lt;&#39;b&amp;gt;&amp;gt; * &#39;b -&amp;gt; seq&amp;lt;IPipelineInput&amp;lt;&#39;b&amp;gt;&amp;gt;, ?overflow, ?capacity, ?blockingTime) =
    let processor = processor
    let router = router  
    let createBlockingCollection x =
        match x with
        | Some c -&amp;gt; new BlockingCollection&amp;lt;&#39;a&amp;gt;(c:int)
        | None -&amp;gt; new BlockingCollection&amp;lt;&#39;a&amp;gt;()  
    let buffer = createBlockingCollection capacity
    let routes = ref List.empty&amp;lt;IPipelineInput&amp;lt;&#39;b&amp;gt;&amp;gt;
    let queuedOrRunning = ref false  
    let blocktime =
      match blockingTime with
      | Some b -&amp;gt; b
      | None -&amp;gt; 250  
    let consumerLoop = async {
      try
        let rec loop()=
          let item = ref Unchecked.defaultof&amp;lt;_&amp;gt;
          let taken = buffer.TryTake(item, blocktime)
          if taken then
              do !item
              |&amp;gt; processor
              |&amp;gt; Seq.iter (fun z -&amp;gt;
              (match !routes with
               | [] -&amp;gt; ()(*we cant route with no routes*)
               | _ -&amp;gt; do router (!routes, z) |&amp;gt; Seq.iter (fun r -&amp;gt; (r.Insert z ))) )
              loop()
          else ()(*exit nothing to consume in time limit*)
        loop()
      with e -&amp;gt; raise e
      }  
    member this.ClearRoutes = routes := []  
    interface IPipelineInput&amp;lt;&#39;a&amp;gt; with
      member this.Insert payload =
        let added = buffer.TryAdd(payload, blocktime)
        if added then
          //begin consumer loop
          if not !queuedOrRunning then
            lock consumerLoop (fun() -&amp;gt;
            Async.Start(async {do! consumerLoop })
            queuedOrRunning := true)
          else()
        else
          //overflow here if function passed
          match overflow with
          | Some t -&amp;gt;  payload |&amp;gt; overflow.Value
          | None -&amp;gt; ()  
    interface IPipelineConnection&amp;lt;&#39;b&amp;gt; with
      member this.Attach (stage) =
        let current = !routes
        routes := stage :: current  
      member this.Detach (stage) =
        let current = !routes
        routes := List.filter (fun el -&amp;gt; el &amp;lt;&amp;gt; stage) current  
    static member Attach (a:IPipelineConnection&amp;lt;_&amp;gt;) (b) =
      a.Attach b ;b  
    static member Detach (a: IPipelineConnection&amp;lt;_&amp;gt;) (b) =
      a.Detach b ;a  
    static member (++&amp;gt;) (a:IPipelineConnection&amp;lt;_&amp;gt;, b) =
      a.Attach (b) ;b  
    static member (--&amp;gt;) (a:IPipelineConnection&amp;lt;_&amp;gt;, b) =
      a.Detach b ;a  
    static member (&amp;lt;&amp;lt;--) (a:IPipelineInput&amp;lt;_&amp;gt;, b:&#39;b) =
      a.Insert b  
    static member (--&amp;gt;&amp;gt;) (b,a:IPipelineInput&amp;lt;_&amp;gt;) =
      a.Insert b
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;summary&#34;&gt;Summary.&lt;/h3&gt;

&lt;p&gt;I only want to summarise the code as I think its fairly straight forward to
see whats going on.&lt;/p&gt;

&lt;h3 id=&#34;interfaces&#34;&gt;Interfaces&lt;/h3&gt;

&lt;p&gt;We have two main interfaces defined &lt;strong&gt;IPipelineInput&amp;lt;&amp;lsquo;a&amp;gt;&lt;/strong&gt; and
**IPipelineConnection&amp;lt;&amp;lsquo;a&amp;gt;, **as you can tell by the names they are involved
with connecting the pipeline together and getting information into the
pipeline.  Those two interfaces are merged together in the IPipeline&amp;lt;&amp;lsquo;a, &amp;lsquo;b&amp;gt;
interface, this keeps a nice separation between connecting and inserting into
the pipeline, it also makes implementation easier and allows the interfaces to
be implemented in other areas of code that need to talk to or connect to a
pipeline.&lt;/p&gt;

&lt;h3 id=&#34;internals&#34;&gt;Internals&lt;/h3&gt;

&lt;p&gt;Inside the pipeline we have the bounded blocking queue which is implemented by
the BlockingCollection from TPL. This is used to store the pipeline payloads
that are waiting to be processed.&lt;/p&gt;

&lt;p&gt;The consumerLoop function is recursive and continually tries to take items
from the blocking collection processing and routing each one to the next
pipeline stage.&lt;/p&gt;

&lt;p&gt;The processor is a function that transforms from type &amp;lsquo;a to type &amp;lsquo;b.&lt;/p&gt;

&lt;p&gt;The router is a function that takes a sequence of IPipelineInput&amp;lt;&amp;lsquo;b&amp;gt; and also
the payload &amp;lsquo;b it returns a sequence of IPipelineInput&amp;lt;&amp;lsquo;b&amp;gt;.  What this
effectively means is that we can route by the connected stages (i.e. round
robin routing, multi-cast routing.)   Or we could route by payload contents
(i.e. if the payload contains a certain bytes sequence we could choose a
certain IPipelineInput&amp;lt;&amp;lsquo;b&amp;gt;.)&lt;/p&gt;

&lt;p&gt;Each item taken is passed to the processor and router via pipeline (&lt;strong&gt;|&amp;gt;&lt;/strong&gt;) and
Seq operations, recursively calling itself until an item can no longer be
retrieved from the buffer.&lt;/p&gt;

&lt;p&gt;The implementation of IPipelineInput&amp;lt;&amp;lsquo;a&amp;gt;.Insert is the counterpart to the
previous function. It first tries to inset the item into the bounded blocking
queue, if this cannot be done then the overflow function is called if one is
present. Next the async consumer loop is started if it is not already running.
The idea behind this is that by keeping the payload processing running on the
thread pool while there is work to do it will cut down on the number of
context switches between threads.  Once an item cannot be taken from the
bounding blocking queue the loop will exit.&lt;/p&gt;

&lt;p&gt;The rest of the code is pretty standard stuff and should be pretty easy to
follow.&lt;/p&gt;

&lt;p&gt;I also define some symbolic operations to simply constructing and using the
pipeline:&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;++&amp;gt;&lt;/strong&gt; Attaches the pipeline stage on the right hand side to the one on the left. &lt;strong&gt;&amp;ndash;&amp;gt;&lt;/strong&gt; Detaches the pipelinestage on the right from the one on the left. &lt;strong&gt;&amp;lt;&amp;lt;&amp;ndash;&lt;/strong&gt; Inserts a payload on the right into the pipeline stage on the left. &lt;strong&gt;&amp;ndash;&amp;gt;&amp;gt;&lt;/strong&gt; Inserts a payload on the left hand side into the pipeline stage on the right.&lt;br /&gt;
These help to keep a nice terse description of the pipeline, once things get a little more complex other operators may be required, the now discontinued
&lt;a href=&#34;http://msdn.microsoft.com/en-us/devlabs/dd795202.aspx&#34;&gt;Axiom&lt;/a&gt; had a whole host of these, its a pity Microsoft dropped the language.&lt;/p&gt;

&lt;h3 id=&#34;example&#34;&gt;Example&lt;/h3&gt;

&lt;p&gt;Heres a quick sample pipeline showing the pipeline in use:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Stage 1 takes a string and splits it based on the &amp;lsquo;,&amp;rsquo;.&lt;/li&gt;
&lt;li&gt;Stage 2 reverses each string.&lt;/li&gt;
&lt;li&gt;Stage 3 reverses the string back to the original.&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code class=&#34;language-fsharp&#34;&gt;module program
  open System
  open Pipeline  
  let consoleLock = new obj()  
  let split del n (s:string) =
    lock consoleLock (fun() -&amp;gt;
    do printfn &amp;quot;%A:before split %A&amp;quot; n s
    let split = s.Split([|del|])
    do printfn &amp;quot;%A:after: split into: %A&amp;quot; n split
    split |&amp;gt; Array.toSeq)  
  let reverse (s:string) =
    new string(s |&amp;gt; Seq.toArray |&amp;gt; Array.rev)  
  let oneToSingleton a b f=
    lock consoleLock (fun() -&amp;gt;
      printfn &amp;quot;%A:before reverse %A&amp;quot; a b
      let result = b |&amp;gt; f
      printfn &amp;quot;%A:after reverse %A&amp;quot; a result
      result|&amp;gt; Seq.singleton)  
  let OneToSeqRev a b = oneToSingleton a b reverse   
  ///Simply picks the first route
  let basicRouter( r, i) =
    let head = Seq.head r
    Seq.singleton head  
  let p1 = PipelineStage( split &#39;,&#39; &amp;quot;1&amp;quot;, basicRouter)
  let p2 = PipelineStage( OneToSeqRev &amp;quot;2&amp;quot;, basicRouter)
  let p3 = PipelineStage( OneToSeqRev &amp;quot;3&amp;quot;, basicRouter)  
  p1 ++&amp;gt; p2 ++&amp;gt; p3 |&amp;gt; ignore  
  let generateCircularSeq (lst:&#39;a list) =
    let rec next () =
      seq {
        for element in lst do
          yield element
        yield! next()
      }
    next()  
  for str in [&amp;quot;John,Paul,George,Ringo&amp;quot;]
  |&amp;gt; generateCircularSeq
  |&amp;gt; Seq.take 10
    do  str --&amp;gt;&amp;gt; p1  
  let x = Console.ReadKey()
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;As you can see the assignment of the pipeline stages is pretty simple as is the composition of multiple stages.  This was often one of the most difficult
areas while developing a similar pipelines in C# you could often find yourself with a few hundred lines of setup code which was a often a nightmare to debug
a few weeks later.&lt;/p&gt;

&lt;p&gt;Hopefully I have whet your appetite with pipelines, in a future article I will be combining socket operations with pipeline stages to produce a flexible
framework to deal with high throughput network applications.&lt;/p&gt;

&lt;p&gt;As always I appreciate any comments, until next time&amp;hellip;&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Sockets and Bockets 3</title>
      <link>http://7sharpnine.com/2011/01/20/2011-01-20-sockets-and-bockets-part-3/</link>
      <pubDate>Thu, 20 Jan 2011 00:00:00 +0000</pubDate>
      
      <guid>http://7sharpnine.com/2011/01/20/2011-01-20-sockets-and-bockets-part-3/</guid>
      <description>

&lt;h2 id=&#34;welcome-to-part-three&#34;&gt;Welcome to part three!&lt;/h2&gt;

&lt;p&gt;As promised heres a description of the inner workings.  I&amp;rsquo;m sick to death of
typing SocketAsyncEventArgs so from now on I will refer to it as SAEA.&lt;!-- more --&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;BocketPool&lt;/strong&gt;&lt;br /&gt;
The BocketPool has an interesting name and with it an interesting constructor!
It takes the following parameters:&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;number&lt;/strong&gt;: The number of items to create in the BocketPool. &lt;strong&gt;size&lt;/strong&gt;: The size of each buffer in bytes. &lt;strong&gt;callback&lt;/strong&gt;: A callback function which is invoked whenever the SAEA object completes its operation.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-fsharp&#34;&gt;type BocketPool( number, size, callback) as this =
    let number = number
    let size = size
    let totalsize = (number * size)
    let buffer = Array.create totalsize 0uy
    let pool = new BlockingCollection&amp;lt;SocketAsyncEventArgs&amp;gt;(number:int)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;A &lt;strong&gt;buffer&lt;/strong&gt; is created with a size equal to the (&lt;strong&gt;number&lt;/strong&gt; * &lt;strong&gt;size&lt;/strong&gt;)
in bytes.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-fsharp&#34;&gt;do
      let rec loop n =
        match n with
        | x when x &amp;lt; totalsize -&amp;gt;
          let saea = new SocketAsyncEventArgs()
          saea.Completed |&amp;gt; Observable.add callback
          saea.SetBuffer(buffer, n, size)
          this.CheckIn(saea)
          loop (n + size)
        | _ -&amp;gt; ()
      loop 0
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The tail recursive loop function creates a SAEA object and adds it to the
BlockingCollection(pool).&lt;/p&gt;

&lt;p&gt;The buffer is assigned to each SAEA but each is given a unique offset to use,
this is done by the SetBuffer method.  Using this method of allocation, memory
fragmentation is reduced to a minimum by allowing the same buffer to be
reused.&lt;/p&gt;

&lt;p&gt;We use the pipeline operator to attach the &lt;strong&gt;Completed&lt;/strong&gt; event to the callback
method that is passed in the constructor.&lt;/p&gt;

&lt;p&gt;The CheckIn, CheckOut, and Count methods are simply wrappers around the
BlockingCollection.&lt;/p&gt;

&lt;p&gt;We also implement &lt;strong&gt;IDisposable&lt;/strong&gt; to take care of the disposal of the SAEA in the
BlockingCollection.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Connection&lt;/strong&gt;&lt;br /&gt;
The main purpose for this type is to encapsulate the sending and receiving of
messages for a particular client. A BocketPool is created for both the send
and receive operations, the receiveCompleted and SentCompleted are invoked
when the respective operations complete.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Send&lt;/strong&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-fsharp&#34;&gt;member this.Send (msg:byte[]) =
  let s = sendPool.CheckOut()
  Buffer.BlockCopy(msg, 0, s.Buffer, s.Offset, msg.Length)
  socket.SendAsyncSafe(this.sendCompleted, s)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Initially a Bocket is checked out of the sendPool using sendPool.Checkout(),
the &lt;strong&gt;msg&lt;/strong&gt; byte array is copied to the corresponding &lt;strong&gt;Offset&lt;/strong&gt; property of
the SAEA.&lt;/p&gt;

&lt;p&gt;Finally the SendAsyncSafe extension method is called passing in the SAEA and
the callback.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;sendCompleted&lt;/strong&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-fsharp&#34;&gt;member this.sendCompleted (args: SocketAsyncEventArgs) =
      try
        match args.LastOperation with
        | SocketAsyncOperation.Send -&amp;gt;
          match args.SocketError with
          | SocketError.Success -&amp;gt;
            ()
          | SocketError.NoBufferSpaceAvailable
          | SocketError.IOPending
          | SocketError.WouldBlock -&amp;gt;
            if not(anyErrors) then
              anyErrors &amp;lt;- true
              failwith &amp;quot;Buffer overflow or send buffer timeout&amp;quot;
          | _ -&amp;gt; args.SocketError.ToString() |&amp;gt; printfn &amp;quot;socket error on send: %s&amp;quot;
        | _ -&amp;gt; failwith &amp;quot;invalid operation, should be receive&amp;quot;
      finally
        sendPool.CheckIn(args)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;This function matches the LastOperation property of the SAEA using pattern
matching, this ensures that the LastOperation is always SocketError.Success.&lt;/p&gt;

&lt;p&gt;We raise exceptions on NoBufferSpaceAvailable, IOPending, and WouldBlock as
buffer overflows and match any other conditions the wildcard.&lt;/p&gt;

&lt;p&gt;Finally we Check the Bocket back in so that it can be reused.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;receiveCompleted&lt;/strong&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-fsharp&#34;&gt;member this.receiveCompleted (args: SocketAsyncEventArgs) =
      try
        match args.LastOperation with
        | SocketAsyncOperation.Receive -&amp;gt;
          match args.SocketError with
          | SocketError.Success -&amp;gt;
            socket.ReceiveAsyncSafe( this.receiveCompleted, receivePool.CheckOut())
            let data = Array.create args.BytesTransferred 0uy
            Buffer.BlockCopy(args.Buffer, args.Offset, data, 0, data.Length)
            let client = args.RemoteEndPoint
            args.RemoteEndPoint &amp;lt;- null
            data |&amp;gt; printfn &amp;quot;received data: %A&amp;quot;
          | _ -&amp;gt; args.SocketError.ToString() |&amp;gt; printfn &amp;quot;socket error on receive: %s&amp;quot;
        | _ -&amp;gt; failwith &amp;quot;unknown operation, should be receive&amp;quot;
      finally
        receivePool.CheckIn(args)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;This function is very similar to the sendCompleted and could probably be
refactored a bit using the &lt;a href=&#34;http://enfranchisedmind.com/blog/posts/the-hole-in-the-middle-
pattern/&#34;&gt;Hole in the middle
pattern&lt;/a&gt;.  Again we check to ensure the last operation was a success, we
checkout another Bocket and start another ReceiveAsyncSafe. This ensures that
the socket can begin another receive operation as soon as possible while we
take the data from the SAEA Buffer, we do this with Buffer.Block copy.&lt;/p&gt;

&lt;p&gt;If this were a fully-fledged API then we would raise an event here so that
users of the component could consume the data.&lt;/p&gt;

&lt;p&gt;In my own component the data is inserted into a series of processing stages
using the &lt;a href=&#34;http://www.cise.ufl.edu/research/ParallelPatterns
/PatternLanguage/AlgorithmStructure/Pipeline.htm&#34;&gt;Pipeline Pattern&lt;/a&gt;, which I will be may
describe in a future post if anyone&amp;rsquo;s interested.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;TcpListener&lt;/strong&gt;&lt;br /&gt;
The TcpListener is very similar to the Connection object in that it has a pool
of SAEA objects that are used to accept connection from clients, again a round
of refactoring could be done here to avoid duplication with the Connection
type.  The main difference is that we don&amp;rsquo;t need to use the Buffer on the SAEA
to send anything to the client when it initially connects.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;acceptCompleted&lt;/strong&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-fsharp&#34;&gt;member this.acceptcompleted (args : SocketAsyncEventArgs) =
      try
        match args.LastOperation with
        | SocketAsyncOperation.Accept -&amp;gt;
          match args.SocketError with
          | SocketError.Success -&amp;gt;
            listeningSocket.AcceptAsyncSafe( this.acceptcompleted, acceptPool.Take())
            //create new connection
            let connection = newConnection args.AcceptSocket
            connection.Start()  
            //update stats
            reportConnections   
            //async start of messages to client
            startSending connection  
            //remove the AcceptSocket because we will be reusing args
            args.AcceptSocket &amp;lt;- null
          | _ -&amp;gt; args.SocketError.ToString() |&amp;gt; printfn &amp;quot;socket error on accept: %s&amp;quot;
        | _ -&amp;gt; args.LastOperation |&amp;gt; failwith &amp;quot;Unknown operation, should be accept but was %a&amp;quot;
      finally
        acceptPool.Add(args)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;This function is similar to the send and receive completed methods in the
Connection type, although this time we create a Connection object and call the
Start function, this puts the Connection into receive mode.&lt;/p&gt;

&lt;p&gt;The reportConnections is called next which simply prints how many clients are
connected, we now start an Asyncronous workflow using the startSending
function.&lt;/p&gt;

&lt;p&gt;Finally we set the AcceptSocket property to null on the SAEA object and add it
back to the BlockingCollection so that it can be reused.&lt;/p&gt;

&lt;p&gt;The purpose of the BlockingCollection here is to have a fixed pool of SAEA
that block when there isn&amp;rsquo;t an SAEA to service the new connection, this could
be a potential issue for the client as it could timeout while waiting for a
connection but this is a far preferable situation than causing your server to
be effectively denied service due to overload.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;startSending&lt;/strong&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-fsharp&#34;&gt;let startSending connection =
      Async.Start (async {
        try
          use _holder = connection
          do! asyncServiceClient connection
        with e -&amp;gt;
          if not(anyErrors) then
            anyErrors &amp;lt;- true
            Console.WriteLine(&amp;quot;server ERROR&amp;quot;)
          raise e
        } )
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;This function uses the syntactic sugar of the asynchronous workflows to start
an operation on the Thread pool, once queued on the thread pool it is wrapped
in a using block with the &lt;strong&gt;_use &lt;em&gt;holder = connection&lt;/em&gt;&lt;/strong&gt; statement and
asynchronously calls the asyncServiceClient function, this has the effect of
disposing of the Connection type when it exits scope or encounters an
exception.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;asyncServiceClient&lt;/strong&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-fsharp&#34;&gt;let asyncServiceClient (client: Connection) = async {
      client.Send(header)
      while true do
        do! asyncWriteStockQuote(client) }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;This function sends a one byte header message to the client using the
Connection.Send, followed by calling asyncWriteStockQuote in a continuous
loop.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;asyncWriteStockQuote&lt;/strong&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-fsharp&#34;&gt;let asyncWriteStockQuote(connection:Connection) = async {
      do! Async.Sleep 1000
      connection.Send(testMessage)
      Interlocked.Increment(&amp;amp;numWritten) |&amp;gt; ignore }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;This function sleeps for 1000ms and uses the Connection.Send function to sent
a message to the client, the number of results is updated using the
Interlocked class.&lt;/p&gt;

&lt;p&gt;I would like to refer you to &lt;a href=&#34;http://lorgonblog.wordpress.com/2010/03/28/f-async-on-the-server-side/&#34;&gt;Brian McNamara&amp;rsquo;s
post&lt;/a&gt;
that describes this part in more detail.  The only difference in our workflow
is that we don&amp;rsquo;t use a stream operation as we have the SendAsyncSafe function
to do all the work for us.  IDispose is also implemented on this type too as
we have to dispose of the SAEA objects that are used for the asynchronous
accepts.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;createTcpSocket&lt;/strong&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-fsharp&#34;&gt;let createTcpSocket() =
      new Socket(AddressFamily.InterNetwork, SocketType.Stream, ProtocolType.Tcp)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;This function simply wraps the Sockets class constructor mapping it to: Tcp
protocol, Streaming, and InterNetwork Address type.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;createListener&lt;/strong&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-fsharp&#34;&gt;let createListener (ip:IPAddress, port, backlog) =
      let s = createTcpSocket()
      s.Bind(new IPEndPoint(ip, port))
      s.Listen(backlog); s
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;This function calls the createTcpSocket function, binds to the IPAddress and
port that are passed in and starts listening for connections.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Start&lt;/strong&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-fsharp&#34;&gt;member this.start () =
      listeningSocket.AcceptAsyncSafe( this.acceptcompleted, acceptPool.Take())
      while true do
      Thread.Sleep 1000
      let count = Interlocked.Exchange(&amp;amp;numWritten, 0)
      count |&amp;gt; printfn &amp;quot;Quotes per sec: %A&amp;quot;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;This function starts the whole process of listening for a connection from
clients.  A SAEA is taken from the BlockingCollection and AcceptAsyncSafe is
called.&lt;/p&gt;

&lt;p&gt;I have tried to describe all of the functions that I think merit a description
but I have been involved in this sort of code for years now so if you have any
queries feel free to just drop a comment and I will try to help.&lt;/p&gt;

&lt;p&gt;When looking through the code remember that this is just a demo, I am
currently still working on a few things but may offer the full API available
for download at a later date or put it on GitHub.&lt;/p&gt;

&lt;p&gt;In part four we are going to compare some of the differences in operation
between the xxxAsync and the IAsync pattern, obviously there is a lot more
code and inherent complexity in this implementation but in high volume
situations it makes a lot of difference.&lt;/p&gt;

&lt;p&gt;See you next time.&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Sockets and Bockets 2</title>
      <link>http://7sharpnine.com/2011/01/14/2011-01-14-sockets-and-bockets-part-2/</link>
      <pubDate>Fri, 14 Jan 2011 00:00:00 +0000</pubDate>
      
      <guid>http://7sharpnine.com/2011/01/14/2011-01-14-sockets-and-bockets-part-2/</guid>
      <description>

&lt;h3 id=&#34;welcome-to-part-two&#34;&gt;Welcome to part two&lt;/h3&gt;

&lt;p&gt;Lets jump in at the deep end and take a look at some code&amp;hellip;&lt;/p&gt;

&lt;p&gt;When you look at the method syntax for the xxxAsync methods you will notice
they return a boolean value that indicates if the method completed
synchronously, this means that you have to check the return value every time
you use one of the methods and invoke the callback yourself if it completes
synchronously.  In practice this hardly ever happens, and normally only on a
send operation.  But as it is a possibility we will add module with a some
extension methods in to help us out, this will make the code more readable and
avoid unnecessary duplication.&lt;!-- more --&gt;&lt;/p&gt;

&lt;h3 id=&#34;socketextensions&#34;&gt;SocketExtensions&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&#34;language-fsharp&#34;&gt;module SocketExtensions
  open System
  open System.Net
  open System.Net.Sockets  
  type Socket with
    /// extension method to make async based call easier, this ensures the callback always gets
    /// called even if there is an error or the async method completed syncronously
    member s.InvokeAsyncMethod( asyncmethod, callback, args:SocketAsyncEventArgs) =
      let result = asyncmethod args
      if result &amp;lt;&amp;gt; true then callback args
    member s.AcceptAsyncSafe(callback, args) = s.InvokeAsyncMethod(s.AcceptAsync, callback, args)
    member s.ReceiveAsyncSafe(callback, args) = s.InvokeAsyncMethod(s.ReceiveAsync, callback, args)
    member s.SendAsyncSafe(callback, args) = s.InvokeAsyncMethod(s.SendAsync, callback, args)
    member s.DisconnectAsyncSafe(callback, args) = s.InvokeAsyncMethod(s.DisconnectAsync, callback, args)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Now lets get down to business, the next few types have a fair bit of code in
them so I will briefly explain each type in turn:&lt;/p&gt;

&lt;h3 id=&#34;bocketpool&#34;&gt;BocketPool&lt;/h3&gt;

&lt;p&gt;A BocketPool is a combination of a
&lt;a href=&#34;http://msdn.microsoft.com/en-
us/library/system.net.sockets.socketasynceventargs.aspx&#34;&gt;SocketAsyncEventArgs&lt;/a&gt; object and a chunk of
memory allocated in an array.  The array is sliced up into sections and
allocated for each send or receive operation by setting a start and end index
using &lt;a href=&#34;http://msdn.microsoft.com/en-us/library/bb549836.aspx&#34;&gt;SetBuffer()&lt;/a&gt;.
If you remember last time I mentioned that a lot of memory fragmentation can
occur during sending and receiving due to continuously allocating memory
buffers on the Socket object, this is primarily done through the BeginSend and
BeginReceive methods passing in a byte array.  Using the BocketPool it a great
way of reducing the amount of garbage collection during heavy traffic.&lt;/p&gt;

&lt;p&gt;The other major difference with SocketAsyncEventArgs is the way in which you
make the send and receive calls, heres the general flow that occurs:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Create a SocketAsyncEventArgs object or get one from a pool.&lt;/li&gt;
&lt;li&gt;Allocate an array to the buffer.&lt;/li&gt;
&lt;li&gt;Allocate an offset and length to the buffer.&lt;/li&gt;
&lt;li&gt;Allocate a callback method.&lt;/li&gt;
&lt;li&gt;Call Socket.xxxAsync passing in the SocketAsyncEventArgs, the operation will complete and invoke the callback.&lt;br /&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;What we are going to do is wrap the whole creation, array allocation, and
offsetting to the BocketPool:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-fsharp&#34;&gt;namespace Fes
  open System
  open System.Net.Sockets
  open System.Collections.Concurrent  
  type BocketPool( number, size, callback) as this =
    let number = number
    let size = size
    let totalsize = (number * size)
    let buffer = Array.create totalsize 0uy
    let pool = new BlockingCollection&amp;lt;SocketAsyncEventArgs&amp;gt;(number:int)
    let mutable disposed = false
    let cleanUp() =
      if not disposed then
        disposed &amp;lt;- true
        pool.CompleteAdding()
        while pool.Count &amp;gt; 1 do
          (pool.Take() :&amp;gt; IDisposable).Dispose()
        pool.Dispose()
    do
      let rec loop n =
        match n with
        | x when x &amp;lt; totalsize -&amp;gt;
          let saea = new SocketAsyncEventArgs()
          saea.Completed |&amp;gt; Observable.add( fun saea -&amp;gt; (callback saea))
          saea.SetBuffer(buffer, n, size)
          this.CheckIn(saea)
          loop (n + size)
        | _ -&amp;gt; ()
      loop 0
    member this.CheckOut()=
      pool.Take()
    member this.CheckIn(saea)=
      pool.Add(saea)
    member this.Count =
      pool.Count
    interface IDisposable with
      member this.Dispose() = cleanUp()
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Next up we have to look at the Connection and the Tcplistener types as two
interconnected entities:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;The TcpListener listens for a connection on a socket and port number.&lt;/li&gt;
&lt;li&gt;The client connects to the server.&lt;/li&gt;
&lt;li&gt;An accept socket is allocated to the client, at this point we have one socket for the server and once for each client.&lt;/li&gt;
&lt;li&gt;We also need to allocate a BocketPool for send and receive operation for each client
To simplify things we are going to encapsulate the accept socket management
into a type, it will also need a corresponding BocketPool to service any send
and receive operations to and from the client&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&#34;connection&#34;&gt;Connection&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&#34;language-fsharp&#34;&gt;namespace Fes
  open System
  open System.Net
  open System.Net.Sockets
  open System.Collections.Generic
  open System.Collections.Concurrent
  open System.Threading
  open SocketExtensions  
  type Connection(maxreceives, maxsends, size, socket:Socket) as this =
    let socket = socket
    let maxreceives = maxreceives
    let maxsends = maxsends
    let sendPool = new BocketPool(maxsends, size, this.sendCompleted )
    let receivePool = new BocketPool(maxreceives, size, this.receiveCompleted)
    let mutable disposed = false
    let mutable anyErrors = false  
    let cleanUp() =
      if not disposed then
        disposed &amp;lt;- true
        socket.Shutdown(SocketShutdown.Both)
        socket.Disconnect(false)
        socket.Close()
        (sendPool :&amp;gt; IDisposable).Dispose()
        (receivePool :&amp;gt; IDisposable).Dispose()  
    member this.Start() =
      socket.ReceiveAsyncSafe(this.receiveCompleted, receivePool.CheckOut())  
    member this.Stop() =
      socket.Close(2)  
    member this.receiveCompleted (args: SocketAsyncEventArgs) =
      try
        match args.LastOperation with
        | SocketAsyncOperation.Receive -&amp;gt;
          match args.SocketError with
          | SocketError.Success -&amp;gt;
            socket.ReceiveAsyncSafe( this.receiveCompleted, receivePool.CheckOut())
            let data = Array.create args.BytesTransferred 0uy
            Buffer.BlockCopy(args.Buffer, args.Offset, data, 0, data.Length)
            let client = args.RemoteEndPoint
            args.RemoteEndPoint &amp;lt;- null
            data |&amp;gt; printfn &amp;quot;received data: %A&amp;quot;
          | _ -&amp;gt; args.SocketError.ToString() |&amp;gt; printfn &amp;quot;socket error on receive: %s&amp;quot;
        | _ -&amp;gt; failwith &amp;quot;unknown operation, should be receive&amp;quot;
      finally
        receivePool.CheckIn(args)  
    member this.sendCompleted (args: SocketAsyncEventArgs) =
      try
        match args.LastOperation with
        | SocketAsyncOperation.Send -&amp;gt;
          match args.SocketError with
          | SocketError.Success -&amp;gt; ()
          | SocketError.NoBufferSpaceAvailable
          | SocketError.IOPending
          | SocketError.WouldBlock -&amp;gt;
            if not(anyErrors) then
              anyErrors &amp;lt;- true
              failwith &amp;quot;Buffer overflow or send buffer timeout&amp;quot;
          | _ -&amp;gt; args.SocketError.ToString() |&amp;gt; printfn &amp;quot;socket error on send: %s&amp;quot;
        | _ -&amp;gt; failwith &amp;quot;invalid operation, should be receive&amp;quot;
      finally
        sendPool.CheckIn(args)  
    member this.Send (msg:byte[]) =
      let s = sendPool.CheckOut()
      Buffer.BlockCopy(msg, 0, s.Buffer, s.Offset, msg.Length)
      socket.SendAsyncSafe(this.sendCompleted, s)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Finally here&amp;rsquo;s the TcpListener type.  It is responsible for creating an
initial Connection object for each client and starts asynchronous sending
messages to that client once a second, also notice that there is another
BlockingCollection involved, this is somewhat simpler than the usage in the
bocketPool as we have no buffer to manage here.&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;em&gt;It is possible to fill the initial Buffer property, this causes the buffer to be sent to the client as soon as it has connected to the server, this can be useful to sent initial data to the client, such as protocol definitions etc)&lt;/em&gt;
A finite number of connections can occur before blocking will occur depending
on the number of AsyncEventArgs in the collection, this stops potential denial
of service attacks due to too many connection being made.&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&#34;tcplistener&#34;&gt;TcpListener&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&#34;language-fsharp&#34;&gt;namespace Fes
  open System
  open System.Net
  open System.Net.Sockets
  open System.Collections.Generic
  open System.Collections.Concurrent
  open System.Threading
  open SocketExtensions  
  type TcpListener(maxaccepts, maxsends, maxreceives, size, port, backlog) as this =  
    let createTcpSocket() =
      new Socket(AddressFamily.InterNetwork, SocketType.Stream, ProtocolType.Tcp)  
    let createListener (ip:IPAddress, port, backlog) =
      let s = createTcpSocket()
      s.Bind(new IPEndPoint(ip, port))
      s.Listen(backlog); s  
    let listeningSocket = createListener( IPAddress.Loopback, port, backlog)  
    let initPool (maxinpool, callback) =
      let pool = new BlockingCollection&amp;lt;SocketAsyncEventArgs&amp;gt;(maxinpool:int)
      let rec loop n =
        match n with
        | x when x &amp;lt; maxinpool -&amp;gt;
          let saea = new SocketAsyncEventArgs()
          saea.Completed |&amp;gt; Observable.add callback
          pool.Add saea
          loop (n+1)
        | _ -&amp;gt; ()
      loop 0
      pool  
    let acceptPool = initPool (maxaccepts, this.acceptcompleted)
    let newConnection socket = new Connection (maxreceives, maxsends, size, socket)
    let testMessage = Array.init&amp;lt;byte&amp;gt; 128 (fun _ -&amp;gt; 1uy)
    let header = Array.init&amp;lt;byte&amp;gt; 1 (fun _ -&amp;gt; 1uy)
    let mutable disposed = false  
    //mutable state from original
    let mutable anyErrors = false
    let mutable requestCount = 0
    let mutable numWritten = 0  
    //async code from original
    let asyncWriteStockQuote(connection:Connection) = async {
      do! Async.Sleep 1000
      connection.Send(testMessage)
      Interlocked.Increment(&amp;amp;numWritten) |&amp;gt; ignore }  
    //async code from original
    let asyncServiceClient (client: Connection) = async {
      client.Send(header)
      while true do
        do! asyncWriteStockQuote(client) }  
    let startSending connection =
      Async.Start (async {
        try
          use _holder = connection
          do! asyncServiceClient connection
        with e -&amp;gt;
          if not(anyErrors) then
            anyErrors &amp;lt;- true
            Console.WriteLine(&amp;quot;server ERROR&amp;quot;)
          raise e
        } )  
    let reportConnections =
      Interlocked.Increment(&amp;amp;requestCount) |&amp;gt; ignore
      if requestCount % 1000 = 0 then
        requestCount |&amp;gt; printfn &amp;quot;%A Clients accepted&amp;quot;  
    let cleanUp() =
      if not disposed then
        disposed &amp;lt;- true
        listeningSocket.Shutdown(SocketShutdown.Both)
        listeningSocket.Disconnect(false)
        listeningSocket.Close()  
    member this.acceptcompleted (args : SocketAsyncEventArgs) =
      try
        match args.LastOperation with
        | SocketAsyncOperation.Accept -&amp;gt;
          match args.SocketError with
          | SocketError.Success -&amp;gt;
            listeningSocket.AcceptAsyncSafe( this.acceptcompleted, acceptPool.Take())
            //create new connection
            let connection = newConnection args.AcceptSocket
            connection.Start()  
            //update stats
            reportConnections   
            //async start of messages to client
            startSending connection  
            //remove the AcceptSocket because we will be reusing args
            args.AcceptSocket &amp;lt;- null
          | _ -&amp;gt; args.SocketError.ToString() |&amp;gt; printfn &amp;quot;socket error on accept: %s&amp;quot;
        | _ -&amp;gt; args.LastOperation |&amp;gt; failwith &amp;quot;Unknown operation, should be accept but was %a&amp;quot;
      finally
        acceptPool.Add(args)  
    member this.start () =
      listeningSocket.AcceptAsyncSafe( this.acceptcompleted, acceptPool.Take())
      while true do
      Thread.Sleep 1000
      let count = Interlocked.Exchange(&amp;amp;numWritten, 0)
      count |&amp;gt; printfn &amp;quot;Quotes per sec: %A&amp;quot;  
    member this.Close() =
      cleanUp()  
    interface IDisposable with
      member this.Dispose() = cleanUp()
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Its a fair bit of code to take in at once, so Ill leave you with it to ponder
over.  Ill be explaining all of the interesting bits in more detail in part
three&amp;hellip;&lt;/p&gt;

&lt;p&gt;Please feel free to leave any comments you have, especially on better use of
functional constructs.&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Sockets and Bockets 1</title>
      <link>http://7sharpnine.com/2011/01/13/2011-01-13-sockets-and-bockets-1/</link>
      <pubDate>Thu, 13 Jan 2011 00:00:00 +0000</pubDate>
      
      <guid>http://7sharpnine.com/2011/01/13/2011-01-13-sockets-and-bockets-1/</guid>
      <description>

&lt;h3 id=&#34;welcome-to-part-1&#34;&gt;Welcome to part 1&lt;/h3&gt;

&lt;p&gt;A while back I read an interesting article by &lt;em&gt;Brian McNamara&lt;/em&gt; &lt;a href=&#34;http://lorgonblog.wordpress.com/2010/03/28/f-async-on-the-server-side/&#34;&gt;f-async-on-the-server-side&lt;/a&gt;
which describes C# and F# versions of a simple asynchronous
socket server, one of the driving forces behind the article was how F# can
wrap the traditional asynchronous model with &lt;a href=&#34;http://msdn.microsoft.com/en-us/library/dd233250.aspx&#34;&gt;Asynchronous Workflows&lt;/a&gt;, this
produces nice clean simple code compared to the C# version which uses lambda
expressions, the code looks quite ugly in this style!  However thats not the
end of the story, a lot of memory fragmentation can occur using the APM model
when there is a high throughput, so I thought I would see if I could take this
a step further&amp;hellip;&lt;!-- more --&gt;&lt;/p&gt;

&lt;p&gt;There are some lesser known methods that were added to the &lt;a href=&#34;http://msdn.microsoft.com/en-us/library/system.net.sockets.socket.aspx&#34;&gt;Socket&lt;/a&gt;
class in .Net 2.0 SP1: ReceiveAsync, SendAsync, ConnectAsync and DisconnectAsync.
These methods use an event driven model and &lt;strong&gt;do not&lt;/strong&gt; result in the creation
of AsyncResult objects, these are created on every asynchronous call in the
traditional Socket Begin/End methods.  Once you have thousands of clients
sending and receiving thousands of messages all of the object creation can
really have an adverse effect on performance on the garbage collected, you
will regularly see the AsyncResult objects hitting Generation 1 and 2.&lt;/p&gt;

&lt;p&gt;To use the xxxAsync methods you have pass a &lt;a href=&#34;http://msdn.microsoft.com/en-us/library/system.net.sockets.socketasynceventargs.aspx&#34;&gt;SocketAsyncEventArgs&lt;/a&gt;object which is
assigned callback method and a buffer, the callback method called
asynchronously when the operation completes and is passed the corresponding
SocketAsyncEventArgs object, this allows you query the buffer in a receive
operation.&lt;/p&gt;

&lt;p&gt;The scope of this series of articles is to initially replicate Brian&amp;rsquo;s demo
using F# and a pool of SocketAsyncEventArgs and a contiguous block of memory
to hold the data being sent and received on the Socket, this again further
reduces memory fragmentation on the send and receive buffers.&lt;/p&gt;

&lt;p&gt;I have successfully developed an enterprise server for a client using this
method, it processed thousands of simultaneous connected clients and messages,
key components in the system were the High performance sockets, a pipeline
processor and a highly efficiency means of data compaction, I will only be
including the High performance sockets in this series but the other components
will be at a later date in separate articles.  Interestingly all of the code
was originally developed in c# but had a distinctly functional style, even the
Pipeline Processing is reminiscent of functional composition using the F#
pipeline operator &lt;strong&gt;|&amp;gt;&lt;/strong&gt; although an analogue of attach and detach was used
which in itself is declarative.&lt;/p&gt;

&lt;p&gt;Although there is no code in this article there is plenty in the next!&lt;/p&gt;

&lt;p&gt;Please feel free to leave comments or add any suggestions, hope to see you
next time&amp;hellip;&lt;/p&gt;
</description>
    </item>
    
  </channel>
</rss>