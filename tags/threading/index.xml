<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Threading on 7sharp9</title>
    <link>http://7sharpnine.com/tags/threading/</link>
    <description>Recent content in Threading on 7sharp9</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <copyright>Dave Thomas</copyright>
    <lastBuildDate>Sun, 22 Apr 2012 00:00:00 +0000</lastBuildDate>
    <atom:link href="http://7sharpnine.com/tags/threading/index.xml" rel="self" type="application/rss+xml" />
    
    <item>
      <title>Back to the Primitive II</title>
      <link>http://7sharpnine.com/2012/04/22/2012-04-22-back-to-the-primitive-ii/</link>
      <pubDate>Sun, 22 Apr 2012 00:00:00 +0000</pubDate>
      
      <guid>http://7sharpnine.com/2012/04/22/2012-04-22-back-to-the-primitive-ii/</guid>
      <description>

&lt;p&gt;In the last post I discussed an asynchronous version of the &lt;code&gt;ManualResetEvent&lt;/code&gt; and as promised this time we will be looking at an
 asynchronous version of the &lt;code&gt;AutoResetEvent&lt;/code&gt;.  I&amp;rsquo;m using &lt;a href=&#34;http://blogs.msdn.com/b/pfxteam/archive/2012/02/11/10266923.aspx&#34;&gt;Stephen Toubs post&lt;/a&gt;
as reference and we will be building a version that is functional in style that maps straight into asynchronous work flows without and conversion
or adaptors.&lt;/p&gt;

&lt;h3 id=&#34;what-is-an-autoresetevent&#34;&gt;What is an AutoResetEvent?&lt;/h3&gt;

&lt;p&gt;An &lt;code&gt;AutoResetEvent&lt;/code&gt; can be described as a turnstile mechanism, it lets a single waiting person through before re-latching
waiting for the next signal.  This is opposed to a &lt;code&gt;ManualResetEvent&lt;/code&gt; which functions like an ordinary gate. Calling Set opens
the gate, allowing any number of threads that are waiting to be let through. Calling Reset closes the gate.&lt;/p&gt;

&lt;h3 id=&#34;asyncautoresetevent&#34;&gt;AsyncAutoResetEvent&lt;/h3&gt;

&lt;p&gt;First of all here is the shape of the type that we will be building:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;type AsyncAutoResetEvent =
    new : ?reusethread:bool -&amp;gt; AsyncAutoResetEvent
    member Set : unit -&amp;gt; unit
    member WaitAsync : unit -&amp;gt; Async&amp;lt;bool&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Fairly simple: implied constructor, &lt;code&gt;Set&lt;/code&gt; and &lt;code&gt;WaitAsync&lt;/code&gt; members.&lt;/p&gt;

&lt;h3 id=&#34;implied-constructor&#34;&gt;Implied Constructor&lt;/h3&gt;

&lt;p&gt;Thinking about this logically we may need the following items:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;A queue mechanism to store asynchronous waiters - &lt;code&gt;let mutable awaits = Queue&amp;lt;_&amp;gt;()&lt;/code&gt;.&lt;/li&gt;
&lt;li&gt;A way of knowing if a signal has been made in the absence of any waiters - &lt;code&gt;let mutable signalled = false&lt;/code&gt;.&lt;/li&gt;
&lt;li&gt;We can also declare a short-circuit asynchronous workflow for the situation that &lt;code&gt;Set()&lt;/code&gt; is called before &lt;code&gt;WaitAsync()&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;let completed = async.Return true&lt;/code&gt;.  This will save us constructing an &lt;code&gt;AsyncResultCell&amp;lt;_&amp;gt;&lt;/code&gt; and going though the
rest of the asynchronous mechanism.&lt;br /&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Also notice that an optional parameter called &lt;code&gt;reusethread&lt;/code&gt; is defined, we use the &lt;code&gt;?&lt;/code&gt; prefix when defining it to make it
optional.  We then make use of the &lt;code&gt;defaultArg&lt;/code&gt; function to give it a default value of false if a one is not passed in.  This
will be used in the &lt;code&gt;Set&lt;/code&gt; operation to determine if the code will run on the same thread or a thread in the ThreadPool.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;open System
open System.Threading
open System.Collections.Generic
 
    type AsyncAutoResetEvent(?reusethread) =
		let mutable awaits = Queue&amp;lt;_&amp;gt;()
		let mutable signalled = false
        let completed = async.Return true
        let reuseThread = defaultArg reusethread false
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;waitasync&#34;&gt;WaitAsync()&lt;/h3&gt;

&lt;p&gt;The first step is to use  a locking construct to control access to the mutable queue &lt;code&gt;awaits&lt;/code&gt;.  Inside this lock we
check to see if &lt;code&gt;signalled&lt;/code&gt; is true and if so we reset it to false and return our pre-built &lt;code&gt;completed&lt;/code&gt; asynchronous workflow.  If
signalled is false then we create a new &lt;code&gt;AsyncResultCell&amp;lt;_&amp;gt;&lt;/code&gt; and add it to the queue then return the &lt;code&gt;AsyncResult&lt;/code&gt; to the caller.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;        member x.WaitAsync() =
            lock awaits (fun () -&amp;gt;
                if signalled then
                    signalled &amp;lt;- false
                    completed
                else
                    let are = AsyncResultCell&amp;lt;_&amp;gt;()
                    awaits.Enqueue are
                    are.AsyncResult)
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;set&#34;&gt;Set()&lt;/h3&gt;

&lt;p&gt;We first declare a function called &lt;code&gt;getWaiter()&lt;/code&gt;, we use this function to return an &lt;a href=&#34;http://msdn.microsoft.com/en-us/library/dd233245.aspx&#34;&gt;option type&lt;/a&gt;
 that is either &lt;code&gt;Some AsyncResultCell&amp;lt;bool&amp;gt;&lt;/code&gt; or &lt;code&gt;None&lt;/code&gt;.  We use the lock function to control access to the mutable queue &lt;code&gt;lock awaits&lt;/code&gt;.  Once
inside the lock we use pattern matching to capture &lt;code&gt;awaits.Count&lt;/code&gt; and &lt;code&gt;signalled&lt;/code&gt;:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;The first pattern match &lt;code&gt;(x,_)&lt;/code&gt; checks if there are any waiters (&lt;code&gt;awaits.Count &amp;gt; 0&lt;/code&gt;) and then dequeues an &lt;code&gt;AsyncResultCell&amp;lt;bool&amp;gt;&lt;/code&gt; from the
queue and returns it within an option type: &lt;code&gt;Some &amp;lt;| awaits.Dequeue()&lt;/code&gt;.&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;The second pattern match &lt;code&gt;(_,y)&lt;/code&gt; checks whether &lt;code&gt;signalled&lt;/code&gt; is set to false before setting its value to true.  This causes next &lt;code&gt;WaitAsync()&lt;/code&gt;
caller to get the short-circuited value &lt;code&gt;completed&lt;/code&gt;.  This means that an &lt;code&gt;AsyncResultCell&amp;lt;bool&amp;gt;&lt;/code&gt; does not need to be created and go though the
whole async mechanism.  We then return &lt;code&gt;None&lt;/code&gt; as there is no waiter to be notified.&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;The final pattern match &lt;code&gt;(_,_)&lt;/code&gt; is used when there are no waiting callers and &lt;code&gt;signalled&lt;/code&gt; has already being set, there is simply nothing to do in
this situation so we return &lt;code&gt;None&lt;/code&gt;.&lt;br /&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;We use the &lt;code&gt;getWaiter()&lt;/code&gt; function via pattern match.  If we have a result i.e. Some AsyncResultCell&lt;bool&gt; then we call &lt;code&gt;RegisterResult&lt;/code&gt;
passing in &lt;code&gt;AsyncOK(true)&lt;/code&gt; to indicate a completion.  Notice that we also pass in the &lt;code&gt;reuseThread&lt;/code&gt; boolean that was declared as part of the
constructor.  If &lt;code&gt;reuseThread&lt;/code&gt; is true then the notification to the waiter happens &lt;strong&gt;synchronously&lt;/strong&gt; use this with care!  Personally I would stick
with the default of false to ensure that the operation is completed via the thread pool, unless you have a performance critical reason and the
waiting code that executes is &lt;strong&gt;very fast&lt;/strong&gt;.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;		member x.Set() =
		    let getWaiter()=
		        lock awaits (fun () -&amp;gt;
		            match (awaits.Count, signalled) with
		            | (x,_) when x &amp;gt; 0 -&amp;gt; Some &amp;lt;| awaits.Dequeue()
		            | (_,y) when not y -&amp;gt; signalled &amp;lt;- true;None
		            | (_,_) -&amp;gt; None)
		    match getWaiter() with
		    | Some a -&amp;gt; a.RegisterResult(AsyncOk(true), reuseThread)
		    | None _ -&amp;gt; ()
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The reason for using the &lt;code&gt;getWaiter()&lt;/code&gt; function is to separate the locking function away from the notification, if &lt;code&gt;RegisterResult&lt;/code&gt;
was called within the lock and &lt;code&gt;reuseThread&lt;/code&gt; was true then the awaiting function would be called synchronously within the lock which
would not be a very good situation to be in.&lt;/p&gt;

&lt;p&gt;So there we have it, I could take this series further and convert the other primitives that Stephen Toub describes but there should be
enough information in these two posts to set you on your way.  If anyone would like me to complete the series then let me know.  I
may well finish them off and post them on GitHub in the future, time permitting.&lt;/p&gt;

&lt;p&gt;Thanks for tuning in, until next time&amp;hellip;&lt;/p&gt;

&lt;hr style=&#34;margin: 1em 0&#34;&gt;
&lt;h1 id=&#34;essential-listening&#34;&gt;Essential listening:&lt;/h1&gt;


&lt;div class=&#34;pure-g&#34;&gt;

  
  
  
  
  &lt;div class=&#34;&#34;&gt;
    &lt;div style=&#34;width: 20%; float: left;padding: 0 .2em .2em 0&#34;&gt;
        &lt;figure style=&#34;margin: 0&#34;&gt;
            &lt;img src=&#34;http://upload.wikimedia.org/wikipedia/en/a/a8/CowboysFromHell.jpg&#34; style=&#34;margin: 0&#34;
                 alt=&#34;Pantera - Cowboys From Hell&#34; /&gt;
            &lt;figcaption&gt;
                &lt;h6&gt;Pantera - Cowboys From Hell&lt;/h4&gt;
            &lt;/figcaption&gt;
        &lt;/figure&gt;
    &lt;/div&gt;
  &lt;/div&gt;
  

  
  
  
  
  &lt;div class=&#34;&#34;&gt;
    &lt;div style=&#34;width: 20%; float: left;padding: 0 .2em .2em 0&#34;&gt;
        &lt;figure style=&#34;margin: 0&#34;&gt;
            &lt;img src=&#34;http://upload.wikimedia.org/wikipedia/en/0/09/Cacophony_-_1988_-_Go_Off%21.jpg&#34; style=&#34;margin: 0&#34;
                 alt=&#34;Cacophony - Go Off&#34; /&gt;
            &lt;figcaption&gt;
                &lt;h6&gt;Cacophony - Go Off&lt;/h4&gt;
            &lt;/figcaption&gt;
        &lt;/figure&gt;
    &lt;/div&gt;
  &lt;/div&gt;
  

&lt;/div&gt;




</description>
    </item>
    
    <item>
      <title>Back to the Primitive</title>
      <link>http://7sharpnine.com/2012/04/12/2012-04-12-back-to-the-primitive/</link>
      <pubDate>Thu, 12 Apr 2012 00:00:00 +0000</pubDate>
      
      <guid>http://7sharpnine.com/2012/04/12/2012-04-12-back-to-the-primitive/</guid>
      <description>&lt;p&gt;In this post we are going &lt;strong&gt;back to the primitive&lt;/strong&gt;.  No it&amp;rsquo;s not about the same named song by Soulfly, &lt;em&gt;(which incidentally does contains F# notes)&lt;/em&gt; but a return to thread synchronisation primitives and their asynchronous counterparts.&lt;/p&gt;

&lt;p&gt;We are going to be looking at an asynchronous version of the &lt;a href=&#34;http://msdn.microsoft.com/en-us/library/system.threading.manualresetevent.aspx&#34;&gt;ManualResetEvent&lt;/a&gt;.  This was
recently covered by Stephen Toub on the &lt;a href=&#34;http://blogs.msdn.com/b/pfxteam/archive/2012/02/11/10266920.aspx&#34;&gt;pfx team blog&lt;/a&gt;.  We will be taking a slightly different view on
this as we will be using asynchronous workflows which will give us nice idiomatic usage within F#.&lt;/p&gt;

&lt;p&gt;First lets look of the shape of the type that Stephen defined:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;public class AsyncManualResetEvent 
{ 
    public Task WaitAsync(); 
    public void Set(); 
    public void Reset(); 
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Now this can be used from within F# by using the &lt;code&gt;Async.AwaitTask&lt;/code&gt; function from the Async module but this is like wrapping one asynchronous paradigm with another, and
although this does work, what if you want to avoid the overhead of wrappers and stay strictly within async workflows.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-fsharp&#34;&gt;type asyncManualResetEvent() =
    member x.WaitAsync() : unit -&amp;gt; Async&amp;lt;bool&amp;gt;
    member x.Set() : unit -&amp;gt; unit
    member x.Reset() : unit -&amp;gt; unit
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;That&amp;rsquo;s what we want to see!  I don&amp;rsquo;t want to get into the details of the description of how the C# version works as Stephen does a very good job of that already.  What I will explain though is how we essentially do the same thing while staying with the realm of functional programming.  As we are getting into the lower lever details no doubt we will have to start relying on some low level locking primitives like Monitors, Semaphores, and Interlocked operations, even the F# core libraries have a
cornucopia of those.&lt;/p&gt;

&lt;p&gt;Lets look at the first member &lt;code&gt;WaitAsync()&lt;/code&gt;.  The first step is to create a something to store the result of the operation, all we will just be storing and returning
asynchronously is a boolean to indicate that the wait handle has been set.  To do this we use one of the types from the
&lt;a href=&#34;http://fsharppowerpack.codeplex.com/&#34;&gt;F# power pack&lt;/a&gt; &lt;code&gt;AsyncResultCell&amp;lt;&#39;T&amp;gt;&lt;/code&gt;.  I think that such a type should of been exposed from the F# core libraries but it was
omitted for some reason.  There is a type called &lt;code&gt;ResultCell&amp;lt;&#39;T&amp;gt;&lt;/code&gt; with much the same functionality in the FSharp.Core.Control namespace but it is marked internal so
it&amp;rsquo;s not available for our use.&lt;/p&gt;

&lt;p&gt;We declare a &lt;a href=&#34;http://msdn.microsoft.com/en-us/library/dd233186.aspx&#34;&gt;reference cell&lt;/a&gt; of type &lt;code&gt;AsyncResultCell&amp;lt;&#39;T&amp;gt;&lt;/code&gt; and then create the &lt;code&gt;WaitAsync()&lt;/code&gt; member, all we have
to do is dereference the value of the reference cell with &lt;code&gt;!&lt;/code&gt; and call its &lt;code&gt;AsyncResult&lt;/code&gt; member, this gives us an &lt;code&gt;Async&amp;lt;bool&amp;gt;&lt;/code&gt; which we can easily use in an asynchronous workflow.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-fsharp&#34;&gt;type asyncManualResetEvent() =
    let aResCell = ref &amp;lt;| AsyncResultCell&amp;lt;_&amp;gt;()

    member x.WaitAsync() = (!aResCell).AsyncResult
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The next bit is fairly simple too.  All we need to do is dereference the value of the reference cell, and invoke the &lt;code&gt;RegisterResult&lt;/code&gt; member by passing in a value of
 &lt;code&gt;AsyncOk(true)&lt;/code&gt;.  The boolean value of true will be used by the type inference system to constrain the value of the &lt;code&gt;Async&amp;lt;_&amp;gt;&lt;/code&gt; returned from &lt;code&gt;WaitAsync&lt;/code&gt;.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-fsharp&#34;&gt;    member x.Set() = (!aResCell).RegisterResult(AsyncOk(true))
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The last part is the most complex &lt;em&gt;(as usual)&lt;/em&gt;.  Here we create a recursive function called &lt;code&gt;swap&lt;/code&gt; that will try to exchange the &lt;code&gt;AsyncResultCell&amp;lt;&#39;T&amp;gt;&lt;/code&gt; for a new
one.  We dereference the reference cell to &lt;code&gt;currentValue&lt;/code&gt;, then we use a CAS (Compare And Swap) operation to compare the &lt;code&gt;aResCell&lt;/code&gt; with &lt;code&gt;currentValue&lt;/code&gt; and if they
are equal &lt;code&gt;newVal&lt;/code&gt; will replace &lt;code&gt;aResCell&lt;/code&gt;.  On the next line if the result of the CAS operation means that &lt;code&gt;result&lt;/code&gt; and &lt;code&gt;currentValue&lt;/code&gt; are equal then we are finished,
otherwise we spin the current thread for 20 cycles using &lt;code&gt;Thread.SpinWait 20&lt;/code&gt; before retrying the operation via recursion &lt;code&gt;swap newVal&lt;/code&gt;.  This will be a lot less
expensive than switching to user or kernel mode locking, and the period of contention between threads should be very small.  Finally the swap operation is started
by passing in a new &lt;code&gt;AsyncResultCell&amp;lt;&#39;T&amp;gt;&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;There are various other methods we could of used, for instance we could of wrapped a &lt;code&gt;ManualResetEvent&lt;/code&gt; with a call to &lt;code&gt;Async.AwaitWaitHandle&lt;/code&gt;, although this
would of meant using the kernel mode locking of the &lt;code&gt;ManualResetEvent&lt;/code&gt; which is a bit more expensive.&lt;/p&gt;

&lt;p&gt;In Stephen Toub&amp;rsquo;s post he mentions Task&amp;rsquo;s being orphaned due to the &lt;code&gt;Reset()&lt;/code&gt; method being called before the &lt;code&gt;Task&amp;lt;&#39;T&amp;gt;&lt;/code&gt; has been completed, that shouldn&amp;rsquo;t happen in our
implementation due the the closures being stored internally for completion by the async infrastructure.  Heres a quick test harness to make sure everything works as expected anyway.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-fsharp&#34;&gt;    member x.Reset() =
        let rec swap newVal = 
            let currentValue = !aResCell
            let result = Interlocked.CompareExchange&amp;lt;_&amp;gt;(aResCell, newVal, currentValue)
            if obj.ReferenceEquals(result, currentValue) then ()
            else Thread.SpinWait 20
                 swap newVal
        swap &amp;lt;| AsyncResultCell&amp;lt;_&amp;gt;()
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&#34;language-fsharp&#34;&gt;let amre = asyncManualResetEvent()
let x = async{let! x = amre.WaitAsync()
              Console.WriteLine(&amp;quot;First signalled&amp;quot;)}

let y = async{let! x = amre.WaitAsync()
             Console.WriteLine(&amp;quot;Second signalled&amp;quot;)}

let z = async{let! x = amre.WaitAsync()
              Console.WriteLine(&amp;quot;Third signalled&amp;quot;)}
//start async workflows x and y
Async.Start x
Async.Start y

//reset the asyncManualResetEvent, this will test whether the async workflows x and y 
// are orphaned due to the AsyncResultCell being recycled.
amre.Reset()

//now start the async z
Async.Start z

//we set a single time, this should result in the three async workflows completing
amre.Set()

Console.ReadLine() |&amp;gt; ignore
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Here we can see everything works out as we expected:&lt;/p&gt;


&lt;figure &gt;
    
        &lt;img src=&#34;https://lh6.googleusercontent.com/-NYIKC5Gaahs/T4YAQGtP9RI/AAAAAAAABR8/_cTOriC1_Fw/amre.png&#34; /&gt;
    
    
&lt;/figure&gt;


&lt;p&gt;Thats all there is too it, next time I will be exploring an asyncAutoResetEvent in much the same vein.&lt;/p&gt;

&lt;p&gt;Until next time&amp;hellip;&lt;/p&gt;

&lt;hr style=&#34;margin: 1em 0&#34;&gt;
&lt;h1 id=&#34;essential-listening&#34;&gt;Essential listening:&lt;/h1&gt;


&lt;div class=&#34;pure-g&#34;&gt;

  
  
  
  
  &lt;div class=&#34;&#34;&gt;
    &lt;div style=&#34;width: 20%; float: left;padding: 0 .2em .2em 0&#34;&gt;
        &lt;figure style=&#34;margin: 0&#34;&gt;
            &lt;img src=&#34;http://upload.wikimedia.org/wikipedia/en/f/fb/Zeitgeist_cover.png&#34; style=&#34;margin: 0&#34;
                 alt=&#34;Smashing Pumpkins Zeitgeist&#34; /&gt;
            &lt;figcaption&gt;
                &lt;h6&gt;Smashing Pumpkins Zeitgeist&lt;/h4&gt;
            &lt;/figcaption&gt;
        &lt;/figure&gt;
    &lt;/div&gt;
  &lt;/div&gt;
  

  
  
  
  
  &lt;div class=&#34;&#34;&gt;
    &lt;div style=&#34;width: 20%; float: left;padding: 0 .2em .2em 0&#34;&gt;
        &lt;figure style=&#34;margin: 0&#34;&gt;
            &lt;img src=&#34;http://upload.wikimedia.org/wikipedia/en/3/34/Primitive.png&#34; style=&#34;margin: 0&#34;
                 alt=&#34;Soulfly Primitive&#34; /&gt;
            &lt;figcaption&gt;
                &lt;h6&gt;Soulfly Primitive&lt;/h4&gt;
            &lt;/figcaption&gt;
        &lt;/figure&gt;
    &lt;/div&gt;
  &lt;/div&gt;
  

  
  
  
  
  &lt;div class=&#34;&#34;&gt;
    &lt;div style=&#34;width: 20%; float: left;padding: 0 .2em .2em 0&#34;&gt;
        &lt;figure style=&#34;margin: 0&#34;&gt;
            &lt;img src=&#34;http://upload.wikimedia.org/wikipedia/en/0/0d/FooFighters-FooFighters.jpg&#34; style=&#34;margin: 0&#34;
                 alt=&#34;FooFighters&#34; /&gt;
            &lt;figcaption&gt;
                &lt;h6&gt;FooFighters&lt;/h4&gt;
            &lt;/figcaption&gt;
        &lt;/figure&gt;
    &lt;/div&gt;
  &lt;/div&gt;
  

&lt;/div&gt;




</description>
    </item>
    
  </channel>
</rss>