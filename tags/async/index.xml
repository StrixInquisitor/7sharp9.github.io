<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Async on 7sharp9</title>
    <link>http://7sharpnine.com/tags/async/</link>
    <description>Recent content in Async on 7sharp9</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <copyright>Dave Thomas</copyright>
    <lastBuildDate>Sun, 05 May 2013 00:00:00 +0000</lastBuildDate>
    <atom:link href="http://7sharpnine.com/tags/async/index.xml" rel="self" type="application/rss+xml" />
    
    <item>
      <title>I node something (Bout You)</title>
      <link>http://7sharpnine.com/2013/05/05/2013-05-05-i-node-something/</link>
      <pubDate>Sun, 05 May 2013 00:00:00 +0000</pubDate>
      
      <guid>http://7sharpnine.com/2013/05/05/2013-05-05-i-node-something/</guid>
      <description>

&lt;h1 id=&#34;what-is-edge-js&#34;&gt;What is Edge.js?&lt;/h1&gt;


&lt;figure class=&#34;img-left sixth&#34;&gt;
    
        &lt;img src=&#34;http://nodejs.org/images/logos/nodejs-dark.png&#34; /&gt;
    
    
&lt;/figure&gt;


&lt;p&gt;Unless you &lt;em&gt;live in a hole&lt;/em&gt; you have probably heard of &lt;a href=&#34;http://nodejs.org&#34;&gt;node.js&lt;/a&gt; so I&amp;rsquo;ll not bother to explain what it is or what it does.  An interesting project has come to light lately, namely &lt;a href=&#34;http://tjanczuk.github.io/edge/#/&#34;&gt;Edge.js&lt;/a&gt;.  The Edge.js project allows you to connect node.js with .Net.&lt;/p&gt;

&lt;p&gt;The creator of Edge.js Tomasz Janczuk sums this up nicely:&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;An edge connects two nodes&lt;br /&gt;
This edge connects node.js with .NET&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;Currently Edge.js is only available on Windows but there is work underway to bring this to Mono, thus opening up the possibilities even further.  &lt;!-- more --&gt;&lt;/p&gt;

&lt;p&gt;The coding model for Edge.js offers different integration options depending on the quantity of code you are writing, and whether you want to call a .Net dll directly.&lt;/p&gt;

&lt;p&gt;Here are a few examples:&lt;/p&gt;

&lt;h2 id=&#34;single-line-lambda-expressions&#34;&gt;Single line lambda expressions:&lt;/h2&gt;

&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;var edge = require(&#39;edge&#39;);
var hello = edge.func(
    &#39;async (input) =&amp;gt; { return &amp;quot;.NET welcomes &amp;quot; + input.ToString(); }&#39;
);

hello(&#39;Node.js&#39;, function (error, result) {
    if (error) throw error;
    console.log(result);
});
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;multi-line-lambda-expressions&#34;&gt;Multi line lambda expressions:&lt;/h2&gt;

&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;var hello = require(&#39;edge&#39;).func(function () {/*
    async (input) =&amp;gt; {
        return &amp;quot;.NET welcomes &amp;quot; + input.ToString(); 
    }
*/});

hello(&#39;Node.js&#39;, function (error, result) { ... });
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;file-based-expresions&#34;&gt;File based expresions:&lt;/h2&gt;

&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;var hello = require(&#39;edge&#39;).func(&#39;hello.csx&#39;);

hello(&#39;Node.js&#39;, function (error, result) { ... });
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;invoking-via-a-dll&#34;&gt;Invoking via a dll:&lt;/h2&gt;

&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;var add7 = require(&#39;edge&#39;).func(&#39;My.Sample.dll&#39;);

add7(12, function (error, result) { ... }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The entry point into your .NET code is a delegate normalized to a &lt;code&gt;Func&amp;lt;object,Task&amp;lt;object&amp;gt;&amp;gt;&lt;/code&gt;. This allows node.js code to call the .NET code asynchronously and avoid blocking the node.js event loop.  If you think about the possibilities of this for a moment, a lot of different options begin to open up with this framework.  I can foresee a lot of interesting things appearing in the future.&lt;/p&gt;

&lt;p&gt;There are currently two .Net compilers part of Edge.js.  A C# based compiler and an &lt;a href=&#34;http://ironpython.net&#34;&gt;IronPython&lt;/a&gt; one.  You can probably guess what I&amp;rsquo;m going say next&amp;hellip;&lt;/p&gt;

&lt;h1 id=&#34;introducing-edge-fs-an-f-complier-for-edge-js&#34;&gt;Introducing Edge-fs - An F# complier for edge.js&lt;/h1&gt;

&lt;p&gt;First let&amp;rsquo;s look at the interop model for Edge.js:&lt;br /&gt;

&lt;figure class=&#34;6u&#34;&gt;
    &lt;a href=&#34;http://tjanczuk.github.io/edge/#/4&#34;&gt;
        &lt;img src=&#34;https://f.cloud.github.com/assets/822369/234085/b305625c-8768-11e2-8de0-e03ae98e7249.PNG&#34; /&gt;
    &lt;/a&gt;
    
&lt;/figure&gt;
&lt;/p&gt;

&lt;p&gt;In summary, if we want to integrate with Edge.js then we must coerce whatever input that is passed to a single delegate function &lt;code&gt;Func&amp;lt;Object, Task&amp;lt;Object&amp;gt;&amp;gt;&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;In terms of the C# Edge compiler a lambda expression is passed in the &lt;a href=&#34;http://msdn.microsoft.com/en-us/library/vstudio/hh191443.aspx&#34;&gt;async await&lt;/a&gt; style:-&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-csharp&#34;&gt;async (input) =&amp;gt; { return &amp;quot;.NET welcomes &amp;quot; + input.ToString(); }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The Python Edge compiler is passed a lambda in it&amp;rsquo;s native format too:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;def hello(input):
        return &amp;quot;Python welcomes &amp;quot; + input

    lambda x: hello(x)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;So where does that leave us with F# compiler support?  Well, I suppose the most intuitive support for F# would be to use F# async workflow support.  This would mean the that lambda expression would look like this:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-fsharp&#34;&gt;fun input -&amp;gt; async{return &amp;quot;.NET welcomes &amp;quot; + input.ToString()}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;You can see it&amp;rsquo;s not that different from C#&amp;rsquo;s&amp;rsquo; async await style syntax, you can really see the F# async workflow heritage here.&lt;/p&gt;

&lt;h2 id=&#34;script-example&#34;&gt;Script Example&lt;/h2&gt;

&lt;p&gt;Now lets look at how a script file or dll and have a look to see how this would fits:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-fsharp&#34;&gt;namespace global
type Startup() =
    let addSeven v =  v + 7
    member x.Invoke(input:obj) =
        let v = input :?&amp;gt; int
        async.Return (addSeven v :&amp;gt; obj) |&amp;gt; Async.StartAsTask
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;This is really easy too, the Async module has a StartAsTask function that perfectly fits here.&lt;/p&gt;

&lt;p&gt;By default Edge.js looks for a type in the global namespace called &lt;code&gt;Startup&lt;/code&gt; with a public method called &lt;code&gt;Invoke&lt;/code&gt;.  The invoke method takes a single parameter &lt;code&gt;input&lt;/code&gt; which is of the type &lt;code&gt;Object&lt;/code&gt;.  The return type of this method is as you might have guessed &lt;code&gt;Task&amp;lt;Object&amp;gt;&lt;/code&gt;.  You can also add parameters to the node.js to indicate the location of the assembly, type and method name using the &lt;code&gt;assemblyName&lt;/code&gt;, &lt;code&gt;typeName&lt;/code&gt; and &lt;code&gt;methodName&lt;/code&gt; parameters respectively.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;var clrMethod = edge.func({
    assemblyFile: &#39;My.Edge.Samples.dll&#39;,
    typeName: &#39;Samples.FooBar.MyType&#39;,
    methodName: &#39;MyMethod&#39;
});
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;further-documentation&#34;&gt;Further Documentation&lt;/h2&gt;

&lt;p&gt;Edge.js has some really good &lt;a href=&#34;https://github.com/tjanczuk/edge&#34;&gt;documentation&lt;/a&gt; so if your interested then you really should check it out.  I plan on supporting all of the calling conventions that the C# edge compiler has to offer.  At the moment only the in-line lambdas and the file based inputs have been tested, but I&amp;rsquo;m working on further examples, and fixes as needed.&lt;/p&gt;

&lt;h2 id=&#34;why-do-you-need-a-custom-compiler&#34;&gt;Why do you need a Custom Compiler&lt;/h2&gt;

&lt;p&gt;As an aside, with dll based inputs any .Net language would work with Edge.js, you don&amp;rsquo;t need a custom compiler.  The internals of Edge.js invoke your dll via reflection.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;Handle&amp;lt;v8::Value&amp;gt; ClrFunc::Initialize(const v8::Arguments&amp;amp; args)
{
    ...
    // reference .NET code through pre-compiled CLR assembly 
    String::Utf8Value assemblyFile(jsassemblyFile);
    String::Utf8Value nativeTypeName(options-&amp;gt;Get(String::NewSymbol(&amp;quot;typeName&amp;quot;)));
    String::Utf8Value nativeMethodName(options-&amp;gt;Get(String::NewSymbol(&amp;quot;methodName&amp;quot;)));  
    typeName = gcnew System::String(*nativeTypeName);
    methodName = gcnew System::String(*nativeMethodName);      
    assembly = Assembly::LoadFrom(gcnew System::String(*assemblyFile));
    ClrFuncReflectionWrap^ wrap = ClrFuncReflectionWrap::Create(assembly, typeName, methodName);
    result = ClrFunc::Initialize(
        gcnew System::Func&amp;lt;System::Object^,Task&amp;lt;System::Object^&amp;gt;^&amp;gt;(
            wrap, &amp;amp;ClrFuncReflectionWrap::Call));
    ...
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;A custom compiler is only required for compiling code in the form of scripts or lambda expressions.  It&amp;rsquo;s expected that this will be a common use case so it&amp;rsquo;s important to have a native F# compiler support.&lt;/p&gt;

&lt;p&gt;So there we have it, a very quick whistle stop tour of &lt;strong&gt;Edge-fs&lt;/strong&gt; the F# compiler for Edge.js.  I realise that this post only just skims the surface but I just wanted to get this out in the wild.  Ill be updating my &lt;a href=&#34;https://github.com/7sharp9/edge-fs&#34;&gt;repo&lt;/a&gt; over the next day or so, and a stable release will go out via the &lt;a href=&#34;https://npmjs.org&#34;&gt;npm package&lt;/a&gt; as soon as things stabilise.&lt;/p&gt;

&lt;p&gt;Next time we&amp;rsquo;re going to lift the lid on the F# Edge compiler and take a look at it&amp;rsquo;s guts, we&amp;rsquo;ll also go through some of the trials and tribulations I had along the way.  Ill also continue the series with some more documentation and samples too.&lt;/p&gt;

&lt;p&gt;Until next time!&lt;/p&gt;

&lt;hr style=&#34;margin: 1em 0&#34;&gt;
&lt;h1 id=&#34;essential-listening&#34;&gt;Essential listening:&lt;/h1&gt;


&lt;div class=&#34;pure-g&#34;&gt;

  
  
  
  
  &lt;div class=&#34;&#34;&gt;
    &lt;div style=&#34;width: 20%; float: left;padding: 0 .2em .2em 0&#34;&gt;
        &lt;figure style=&#34;margin: 0&#34;&gt;
            &lt;img src=&#34;http://upload.wikimedia.org/wikipedia/en/4/43/Alice_In_Chains-Facelift.jpg&#34; style=&#34;margin: 0&#34;
                 alt=&#34;Alice In Chains - Facelift&#34; /&gt;
            &lt;figcaption&gt;
                &lt;h6&gt;Alice In Chains - Facelift&lt;/h4&gt;
            &lt;/figcaption&gt;
        &lt;/figure&gt;
    &lt;/div&gt;
  &lt;/div&gt;
  

  
  
  
  
  &lt;div class=&#34;&#34;&gt;
    &lt;div style=&#34;width: 20%; float: left;padding: 0 .2em .2em 0&#34;&gt;
        &lt;figure style=&#34;margin: 0&#34;&gt;
            &lt;img src=&#34;http://upload.wikimedia.org/wikipedia/en/1/12/PanteraVulgarDisplayofPower.jpg&#34; style=&#34;margin: 0&#34;
                 alt=&#34;Pantera - Vulgar Display Of Power&#34; /&gt;
            &lt;figcaption&gt;
                &lt;h6&gt;Pantera - Vulgar Display Of Power&lt;/h4&gt;
            &lt;/figcaption&gt;
        &lt;/figure&gt;
    &lt;/div&gt;
  &lt;/div&gt;
  

&lt;/div&gt;




</description>
    </item>
    
    <item>
      <title>iOS async revisited</title>
      <link>http://7sharpnine.com/2013/04/18/2013-04-18-ios-async-revisited/</link>
      <pubDate>Thu, 18 Apr 2013 00:00:00 +0000</pubDate>
      
      <guid>http://7sharpnine.com/2013/04/18/2013-04-18-ios-async-revisited/</guid>
      <description>

&lt;p&gt;In this post weare going to look as async again, but from the perspective of F#.&lt;/p&gt;

&lt;h3 id=&#34;xamarin-evolve-2013&#34;&gt;Xamarin Evolve 2013&lt;/h3&gt;

&lt;p&gt;
&lt;figure &gt;
    
        &lt;img src=&#34;http://blog.xamarin.com/wp-content/uploads/2013/04/Screen-Shot-2013-04-03-at-11.07.21-AM.png&#34; /&gt;
    
    
&lt;/figure&gt;
&lt;br /&gt;
I have been watching the Xamarin Evolve conference this week and it was good to see Miguel announce full support for F#.  Those that follow me on twitter etc, will know that I have been doing F# for quite a while in MonoDevelop and Xamarin Studio.  The new support currently entails some new project templates so that you can easily create epic new F# Apps without having to refer to my blog.  While its sad that my content now falls into the archives its nice to get official support announced in such a grand fashion.  &lt;!-- more --&gt;&lt;/p&gt;

&lt;h3 id=&#34;f-async&#34;&gt;F# Async&lt;/h3&gt;

&lt;p&gt;Kudos to Miguel for covering some history of C#&amp;rsquo;s async feature right back down to its F# heritage too, which appeared in 2007, thanks to the work of Don Syme and the F# team.  You can read more about that on &lt;a href=&#34;http://blogs.msdn.com/b/dsyme/archive/2013/03/24/asynchronous-programming-from-f-to-python.aspx&#34;&gt;Don Syme&amp;rsquo;s blog&lt;/a&gt; or have a look at the research paper &lt;a href=&#34;http://research.microsoft.com/apps/pubs/default.aspx?id=147194&#34;&gt;here&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;So the highly anticipated async await model in C# that&amp;rsquo;s just gone beta in Xamarin addin channel?  We&amp;rsquo;ve had it for ages in F#!  In fact, I suspect you will have been able to use it for quite some time, even before I started hacking together support for F# in iOS!  Anyway, that&amp;rsquo;s enough of the smugness :-) lets get on and see what it looks like using some of the code from the previous post as a reference.&lt;/p&gt;

&lt;p&gt;Ill include the C# version first so that you can see the difference rather than having to open my last post.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-csharp&#34;&gt;// Asynchronous HTTP request
public async void HttpSample ()
{
    Application.Busy ();
    var request = WebRequest.Create (Application.WisdomUrl);

    //async await version
    try{
        var response = await request.GetResponseAsync();
        Application.Done ();
        ad.RenderRssStream(response.GetResponseStream());
    } catch {
        // Error
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;One of the advantages of the F# Async model is it&amp;rsquo;s composable nature and controllability.  The key to F# async is that its defined with F#&amp;rsquo;s &lt;a href=&#34;http://msdn.microsoft.com/en-gb/library/dd233182.aspx&#34;&gt;computation expression&lt;/a&gt; syntax:&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;Computation expressions in F# provide a convenient syntax for writing computations that can be sequenced and combined using control flow constructs and bindings.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;There are several built in workflows: &lt;a href=&#34;http://msdn.microsoft.com/en-gb/library/dd233209.aspx&#34;&gt;Sequences&lt;/a&gt;, &lt;a href=&#34;http://msdn.microsoft.com/en-gb/library/dd233250.aspx&#34;&gt;Asynchronous Workflows&lt;/a&gt;, and &lt;a href=&#34;http://msdn.microsoft.com/en-gb/library/hh225374.aspx&#34;&gt;Query Expressions&lt;/a&gt;.  Whenever you use a computation expression it is as follows:- &lt;code&gt;builder-name { expression }&lt;/code&gt;.  With that tiny bit of background, lets look at the corresponding F# async code:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-fsharp&#34;&gt;member x.HttpSample() =
    Application.Busy() 
    let request = WebRequest.Create(Application.WisdomUrl )
    
    //F# async version
    async {try let! response = request.AsyncGetResponse()
               Application.Done()
               ad(response.GetResponseStream())
           with ex -&amp;gt; () } |&amp;gt; Async.Start
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;You can see there is quite a similarity between this snippet and the C# one and you should be able to figure out what&amp;rsquo;s happening given the knowledge from the previous post.&lt;/p&gt;

&lt;p&gt;One of the first things you will notice the builder - &lt;code&gt;async { ...&lt;/code&gt;, followed by the &lt;code&gt;let!&lt;/code&gt; statement.  You can think of the &lt;code&gt;let!&lt;/code&gt; as the C# equivalent of await.  &lt;code&gt;let!&lt;/code&gt; starts the computation &lt;code&gt;request.AsyncGetResponse()&lt;/code&gt;, and then the thread is suspended until the result is available, at this point execution continues to the next statment, which in this case is &lt;code&gt;Application.Done()&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;Those of you comparing the difference will notice that in the C# version after &lt;code&gt;Application.Done();&lt;/code&gt; we call &lt;code&gt;ad.RenderRssStream(response.GetResponseStream())&lt;/code&gt; but in the F# version we simply call &lt;code&gt;ad(response.GetResponseStream())&lt;/code&gt;.  If we take a quick look at the constructors for the types that hold these methods I can show you the difference a bit better:&lt;/p&gt;

&lt;p&gt;The C# version looks like this:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-csharp&#34;&gt;public class DotNet 
{
	AppDelegate ad;

	public DotNet (AppDelegate ad)
	{
		this.ad = ad;
	}
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The F# one I can show on a single line:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-fsharp&#34;&gt;type DotNet(ad: Stream -&amp;gt; unit) =
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The main difference is that The C# version has the entire &lt;code&gt;AppDelegate&lt;/code&gt; class is passed in, whereas the F# version just takes a function with the signature &lt;code&gt;Stream -&amp;gt; unit&lt;/code&gt;.  In fact the F# version doesn&amp;rsquo;t even need to be placed inside a type like the C# version, we can use a &lt;a href=&#34;http://msdn.microsoft.com/en-gb/library/dd233221.aspx&#34;&gt;module&lt;/a&gt;, again Ill quote from MSDN:&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;In the context of the F# language, a module is a grouping of F# code, such as values, types, and function values, in an F# program. Grouping code in modules helps keep related code together and helps avoid name conflicts in your program.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h3 id=&#34;f-modules&#34;&gt;F# Modules&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&#34;language-fsharp&#34;&gt;module DotNet&#39; =
    let HttpSample(ad) =
            Application.Busy() 
            let request = WebRequest.Create(Application.WisdomUrl )
            
            //F# async version
            async {try let! response = request.AsyncGetResponse()
                       Application.Done()
                       ad(response.GetResponseStream())
                   with ex -&amp;gt; () } |&amp;gt; Async.Start
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;When we want to call this code we can open the module like you would a namespace:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-fsharp&#34;&gt;open DotNet
HttpSample(ad)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Or access it fully qualified by including the &lt;code&gt;module&lt;/code&gt; name:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-fsharp&#34;&gt;DotNet.HttpSample(ad)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;How would this code look from the context of this sample application?&lt;/p&gt;

&lt;p&gt;Here is a snipped from the AppDelegate code which makes use of this module&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-fsharp&#34;&gt;// This method is invoked when the application has loaded its UI and its ready to run
override x.FinishedLaunching (app:UIApplication, options:NSDictionary) =
    x.window.AddSubview (x.navigationController.View)
    x.button1.TouchDown.Add 
        (fun _ -&amp;gt;  if not UIApplication.SharedApplication.NetworkActivityIndicatorVisible then           
                       match x.stack.SelectedRow() with
                       | 0 -&amp;gt; DotNet.HttpSample x.RenderRssStream
                       | 1 -&amp;gt; DotNet.HttpSecureSample x.RenderStream
                       | _ -&amp;gt; (new Cocoa(x.RenderRssStream)).HttpSample() |&amp;gt; ignore )    
    TableViewSelector.Configure (x.stack, [|&amp;quot;http  - WebRequest&amp;quot;
                                            &amp;quot;https - WebRequest&amp;quot;
                                            &amp;quot;http  - NSUrlConnection&amp;quot; |] )                    
    x.window.MakeKeyAndVisible()
    true
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;There are a few departures from the C# sample code which Ill include below now:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;// This method is invoked when the application has loaded its UI and its ready to run
public override bool FinishedLaunching (UIApplication app, NSDictionary options)
{
  window.AddSubview (navigationController.View);

  button1.TouchDown += Button1TouchDown;
  TableViewSelector.Configure (this.stack, new string [] {
    &amp;quot;http  - WebRequest&amp;quot;,
    &amp;quot;https - WebRequest&amp;quot;,
    &amp;quot;http  - NSUrlConnection&amp;quot;
  });

  window.MakeKeyAndVisible ();

  return true;
}

void Button1TouchDown (object sender, EventArgs e)
{
  // Do not queue more than one request
  if (UIApplication.SharedApplication.NetworkActivityIndicatorVisible)
    return;

  switch (stack.SelectedRow ()){
  case 0:
    new DotNet (this).HttpSample ();
    break;

  case 1:
    new DotNet (this).HttpSecureSample ();
    break;

  case 2:
    new Cocoa (this).HttpSample ();
    break;
  }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Firstly we are using an lambda expression for the event handler via the Add method rather than the += handler which we use in C#.  We are also using F#&amp;rsquo;s awesome &lt;a href=&#34;http://msdn.microsoft.com/en-gb/library/dd547125.aspx&#34;&gt;pattern matching&lt;/a&gt; feature on the results of &lt;code&gt;x.stack.SelectedRow()&lt;/code&gt;.  This allows you to encode complex logic and also have the compiler assist you by catching non covered cases.&lt;/p&gt;

&lt;p&gt;I&amp;rsquo;m going to leave it there for now as I don&amp;rsquo;t want to bombard any newcomers with tons of new F# features, and I also don&amp;rsquo;t want to teach any of my regular F# followers how to suck eggs.  If anyone has a preference for more in depth comparisons to the C# version then let me know then I can tailor that into further posts on the subject.&lt;/p&gt;

&lt;p&gt;Until next time!&lt;/p&gt;

&lt;hr style=&#34;margin: 1em 0&#34;&gt;
&lt;h1 id=&#34;essential-listening&#34;&gt;Essential listening:&lt;/h1&gt;


&lt;div class=&#34;pure-g&#34;&gt;

  
  
  
  
  &lt;div class=&#34;&#34;&gt;
    &lt;div style=&#34;width: 20%; float: left;padding: 0 .2em .2em 0&#34;&gt;
        &lt;figure style=&#34;margin: 0&#34;&gt;
            &lt;img src=&#34;http://upload.wikimedia.org/wikipedia/en/b/b4/PerpetualBurn.jpg&#34; style=&#34;margin: 0&#34;
                 alt=&#34;Jason Becker - Perpetual Burn&#34; /&gt;
            &lt;figcaption&gt;
                &lt;h6&gt;Jason Becker - Perpetual Burn&lt;/h4&gt;
            &lt;/figcaption&gt;
        &lt;/figure&gt;
    &lt;/div&gt;
  &lt;/div&gt;
  

  
  
  
  
  &lt;div class=&#34;&#34;&gt;
    &lt;div style=&#34;width: 20%; float: left;padding: 0 .2em .2em 0&#34;&gt;
        &lt;figure style=&#34;margin: 0&#34;&gt;
            &lt;img src=&#34;http://upload.wikimedia.org/wikipedia/en/d/dc/Megadeth-RustInPeace.jpg&#34; style=&#34;margin: 0&#34;
                 alt=&#34;Megadeth - Rust In Peace&#34; /&gt;
            &lt;figcaption&gt;
                &lt;h6&gt;Megadeth - Rust In Peace&lt;/h4&gt;
            &lt;/figcaption&gt;
        &lt;/figure&gt;
    &lt;/div&gt;
  &lt;/div&gt;
  

  
  
  
  
  &lt;div class=&#34;&#34;&gt;
    &lt;div style=&#34;width: 20%; float: left;padding: 0 .2em .2em 0&#34;&gt;
        &lt;figure style=&#34;margin: 0&#34;&gt;
            &lt;img src=&#34;http://www.metal-archives.com/images/4/6/3/9/4639.jpg?3304&#34; style=&#34;margin: 0&#34;
                 alt=&#34;&#34; /&gt;
            &lt;figcaption&gt;
                &lt;h6&gt;&lt;/h4&gt;
            &lt;/figcaption&gt;
        &lt;/figure&gt;
    &lt;/div&gt;
  &lt;/div&gt;
  

&lt;/div&gt;




</description>
    </item>
    
    <item>
      <title>A little bit of iOS async</title>
      <link>http://7sharpnine.com/2013/04/16/2013-04-16-a-little-bit-of-ios-async/</link>
      <pubDate>Tue, 16 Apr 2013 00:00:00 +0000</pubDate>
      
      <guid>http://7sharpnine.com/2013/04/16/2013-04-16-a-little-bit-of-ios-async/</guid>
      <description>&lt;p&gt;I was going to title this post as &amp;lsquo;Now for something completely different&amp;rsquo; but felt that a little bit too &lt;a href=&#34;http://en.wiktionary.org/wiki/Pythonesque&#34;&gt;Pythonesque&lt;/a&gt;, and when I thought about it a bit it isn&amp;rsquo;t really completely just slightly different, namely C# rather than my usual F# posts.  &lt;!-- more --&gt;&lt;/p&gt;

&lt;p&gt;Right, enough of the waffling, this post is a little tour into the relatively unknown area of async on iOS.  Xamarin announced the alpha preview of async await on March 11th this year (2013).  There are a couple of blog post floating around on the net if you look around, Rodrigo Kumpera posted a small example &lt;a href=&#34;http://blog.xamarin.com/brave-new-async-mobile-world/&#34;&gt;here&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;I&amp;rsquo;m no stranger to async, I have spent a great deal of time over the years debugging and refining &lt;a href=&#34;http://msdn.microsoft.com/en-GB/library/system.iasyncresult.aspx&#34;&gt;IAsyncResult&lt;/a&gt; style procedures and found Jeffrey Richter and Joe Duffy&amp;rsquo;s books below to be an excellent reference for those interested.&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;http://www.amazon.com/gp/product/0735667454/ref=as_li_ss_il?ie=UTF8&amp;camp=1789&amp;creative=390957&amp;creativeASIN=0735667454&amp;linkCode=as2&amp;tag=blacguitandge-20&#34;&gt;&lt;img border=&#34;0&#34; src=&#34;http://ws.assoc-amazon.com/widgets/q?_encoding=UTF8&amp;ASIN=0735667454&amp;Format=_SL160_&amp;ID=AsinImage&amp;MarketPlace=US&amp;ServiceVersion=20070822&amp;WS=1&amp;tag=blacguitandge-20&#34; &gt;&lt;/a&gt;&lt;img src=&#34;http://www.assoc-amazon.com/e/ir?t=blacguitandge-20&amp;l=as2&amp;o=1&amp;a=0735667454&#34; width=&#34;1&#34; height=&#34;1&#34; border=&#34;0&#34; alt=&#34;&#34; style=&#34;border:none !important; margin:0px !important;&#34; /&gt;&lt;a href=&#34;http://www.amazon.com/gp/product/032143482X/ref=as_li_ss_il?ie=UTF8&amp;camp=1789&amp;creative=390957&amp;creativeASIN=032143482X&amp;linkCode=as2&amp;tag=blacguitandge-20&#34;&gt;&lt;img border=&#34;0&#34; src=&#34;http://ws.assoc-amazon.com/widgets/q?_encoding=UTF8&amp;ASIN=032143482X&amp;Format=_SL160_&amp;ID=AsinImage&amp;MarketPlace=US&amp;ServiceVersion=20070822&amp;WS=1&amp;tag=blacguitandge-20&#34; &gt;&lt;/a&gt;&lt;img src=&#34;http://www.assoc-amazon.com/e/ir?t=blacguitandge-20&amp;l=as2&amp;o=1&amp;a=032143482X&#34; width=&#34;1&#34; height=&#34;1&#34; border=&#34;0&#34; alt=&#34;&#34; style=&#34;border:none !important; margin:0px !important;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;If you looking for a book on TPL/parallel programming then Parallel Programming with Microsoft .NET by Stephen Toub et al. is also a good read.&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;http://www.amazon.com/gp/product/0735651590/ref=as_li_ss_il?ie=UTF8&amp;camp=1789&amp;creative=390957&amp;creativeASIN=0735651590&amp;linkCode=as2&amp;tag=blacguitandge-20&#34;&gt;&lt;img border=&#34;0&#34; src=&#34;http://ws.assoc-amazon.com/widgets/q?_encoding=UTF8&amp;ASIN=0735651590&amp;Format=_SL160_&amp;ID=AsinImage&amp;MarketPlace=US&amp;ServiceVersion=20070822&amp;WS=1&amp;tag=blacguitandge-20&#34; &gt;&lt;/a&gt;&lt;img src=&#34;http://www.assoc-amazon.com/e/ir?t=blacguitandge-20&amp;l=as2&amp;o=1&amp;a=0735651590&#34; width=&#34;1&#34; height=&#34;1&#34; border=&#34;0&#34; alt=&#34;&#34; style=&#34;border:none !important; margin:0px !important;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;Anyway, enough of the book references lets look at an iOS example of async using the &lt;a href=&#34;https://github.com/xamarin/monotouch-samples&#34;&gt;MonoTouch samples&lt;/a&gt; from Xamarin as a reference.&lt;/p&gt;

&lt;p&gt;We are going to use the &lt;a href=&#34;https://github.com/xamarin/monotouch-samples/tree/master/HttpClient&#34;&gt;HttpSample&lt;/a&gt;.  Its a relatively simple example that has several buttons which trigger an asynchronous request for data, when the data is returned it&amp;rsquo;s simply rendered onto the screen.&lt;/p&gt;

&lt;p&gt;Lets look at the first asynchronous call in the &lt;a href=&#34;https://github.com/xamarin/monotouch-samples/blob/master/HttpClient/DotNet.cs&#34;&gt;DotNet.cs&lt;/a&gt; file, the &lt;code&gt;HttpSample&lt;/code&gt;  method:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-csharp&#34;&gt;// Asynchronous HTTP request
public void HttpSample ()
{
	Application.Busy ();
	var request = WebRequest.Create (Application.WisdomUrl);
	request.BeginGetResponse (FeedDownloaded, request);
}

// Invoked when we get the stream back from the twitter feed
// We parse the RSS feed and push the data into a table.
void FeedDownloaded (IAsyncResult result)
{
	Application.Done ();
	var request = result.AsyncState as HttpWebRequest;
	
	try {
    		var response = request.EndGetResponse (result);
		    ad.RenderRssStream (response.GetResponseStream ());
	} catch {
		// Error				
	}
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;To convert this to the async await style all we have to do is use the async and await keywords (surprise surprise!), and in this instance use the new &lt;strong&gt;Async&lt;/strong&gt; suffixed methods on the &lt;code&gt;WebRequest&lt;/code&gt; class.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-csharp&#34;&gt;// Asynchronous HTTP request
public async void HttpSample ()
{
	Application.Busy ();
	var request = WebRequest.Create (Application.WisdomUrl);

	//async await version
	try{
		var response = await request.GetResponseAsync();
		Application.Done ();
	    ad.RenderRssStream(response.GetResponseStream());
	} catch {
		// Error
	}
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;As you can see the &lt;code&gt;request.BeginGetResponse&lt;/code&gt; method has been changed to &lt;code&gt;await request.GetResponseAsync()&lt;/code&gt; and the callback method &lt;code&gt;FeedDownloaded&lt;/code&gt; which was passed into the &lt;code&gt;BeginGetRespose&lt;/code&gt; method has now been assimilated into the &lt;code&gt;HttpSample&lt;/code&gt; method.  The await keyword is acting as a wait point or suspension while the asynchronous method completes.  As soon the asynchronous call completes then processing continues to the line below, much in the same way that the callback code is executed in the IAsyncResult version.  For an in depth description then you can take a look at the &lt;a href=&#34;http://msdn.microsoft.com/en-gb/library/vstudio/hh191443.aspx&#34;&gt;MSDN documentation&lt;/a&gt; on the subject.&lt;/p&gt;

&lt;p&gt;You could add a WebException to the catch block here, you would expect on situations like network outage which would result in DNS lookup failures from the async call.&lt;/p&gt;

&lt;p&gt;We can look at the next asynchronous method too the &amp;lsquo;HttpSecureSample&amp;rsquo; method&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-csharp&#34;&gt;// Asynchornous HTTPS request
public void HttpSecureSample ()
{
	var https = (HttpWebRequest) WebRequest.Create (&amp;quot;https://gmail.com&amp;quot;);

	// To not depend on the root certficates, we will accept any certificates:
	ServicePointManager.ServerCertificateValidationCallback = (sender, cert, chain, ssl) =&amp;gt;  true;

	https.BeginGetResponse (GmailDownloaded, https);
}

// This sample just gets the result from calling https://gmail.com, an HTTPS secure 
// connection, we do not attempt to parse the output, but merely dump it as text
void GmailDownloaded (IAsyncResult result)
{
	Application.Done ();
	var request = result.AsyncState as HttpWebRequest;

	try {
    		var response = request.EndGetResponse (result);
		    ad.RenderStream (response.GetResponseStream ());
	} catch {
		// Error
	}
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Lets have a look at the async await version of that:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-csharp&#34;&gt;// Asynchornous HTTPS request
public async void HttpSecureSample ()
{
	var https = (HttpWebRequest) WebRequest.Create (&amp;quot;https://gmail.com&amp;quot;);

	// To not depend on the root certficates, we will accept any certificates:
	ServicePointManager.ServerCertificateValidationCallback = (sender, cert, chain, ssl) =&amp;gt;  true;

    try {
			var response = await https.GetResponseAsync();
			Application.Done ();
			ad.RenderRssStream (response.GetResponseStream ());
	} catch {
		// Error
	}
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;In this situation there was also a version of the IAsyncResult Begin/End pattern that had been converted to async - &lt;code&gt;https.GetResponseAsync()&lt;/code&gt; and we also had to add the &lt;code&gt;async&lt;/code&gt; keyword to the &lt;code&gt;HttpSecureSample&lt;/code&gt; method.&lt;/p&gt;

&lt;p&gt;For the situations where there is no &lt;strong&gt;Async&lt;/strong&gt; suffixed method available you can build your own using the &lt;a href=&#34;http://msdn.microsoft.com/en-us/library/system.threading.tasks.taskfactory.fromasync.aspx&#34;&gt;Task.Factory.FromAsync&lt;/a&gt; methods.  I wont go into the details of that here but if anyone wants any information on that then just give me a shout and I can revisit in in a future post.&lt;/p&gt;

&lt;p&gt;Ah yes, I almost forgot, there are some common pitfalls of using async await and Tomas Petricek posted a good compilation of them the other day: &lt;a href=&#34;http://tomasp.net/blog/csharp-async-gotchas.aspx&#34;&gt;C# async gotchas&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;Until next time!&lt;/p&gt;

&lt;hr style=&#34;margin: 1em 0&#34;&gt;
&lt;h1 id=&#34;essential-listening&#34;&gt;Essential listening:&lt;/h1&gt;


&lt;div class=&#34;pure-g&#34;&gt;

  
  
  
  
  &lt;div class=&#34;&#34;&gt;
    &lt;div style=&#34;width: 20%; float: left;padding: 0 .2em .2em 0&#34;&gt;
        &lt;figure style=&#34;margin: 0&#34;&gt;
            &lt;img src=&#34;http://upload.wikimedia.org/wikipedia/en/6/69/Silence_Followed_By_a_Deafening_Roar_album.jpg&#34; style=&#34;margin: 0&#34;
                 alt=&#34;Paul Gilbert - Silence Followed By A Deafening Roar&#34; /&gt;
            &lt;figcaption&gt;
                &lt;h6&gt;Paul Gilbert - Silence Followed By A Deafening Roar&lt;/h4&gt;
            &lt;/figcaption&gt;
        &lt;/figure&gt;
    &lt;/div&gt;
  &lt;/div&gt;
  

  
  
  
  
  &lt;div class=&#34;&#34;&gt;
    &lt;div style=&#34;width: 20%; float: left;padding: 0 .2em .2em 0&#34;&gt;
        &lt;figure style=&#34;margin: 0&#34;&gt;
            &lt;img src=&#34;http://upload.wikimedia.org/wikipedia/en/0/0d/FooFighters-TheColourAndTheShape.jpg&#34; style=&#34;margin: 0&#34;
                 alt=&#34;FooFighters - The Colour And The Shape&#34; /&gt;
            &lt;figcaption&gt;
                &lt;h6&gt;FooFighters - The Colour And The Shape&lt;/h4&gt;
            &lt;/figcaption&gt;
        &lt;/figure&gt;
    &lt;/div&gt;
  &lt;/div&gt;
  

&lt;/div&gt;




</description>
    </item>
    
    <item>
      <title>Back to the Primitive II</title>
      <link>http://7sharpnine.com/2012/04/22/2012-04-22-back-to-the-primitive-ii/</link>
      <pubDate>Sun, 22 Apr 2012 00:00:00 +0000</pubDate>
      
      <guid>http://7sharpnine.com/2012/04/22/2012-04-22-back-to-the-primitive-ii/</guid>
      <description>

&lt;p&gt;In the last post I discussed an asynchronous version of the &lt;code&gt;ManualResetEvent&lt;/code&gt; and as promised this time we will be looking at an
 asynchronous version of the &lt;code&gt;AutoResetEvent&lt;/code&gt;.  I&amp;rsquo;m using &lt;a href=&#34;http://blogs.msdn.com/b/pfxteam/archive/2012/02/11/10266923.aspx&#34;&gt;Stephen Toubs post&lt;/a&gt;
as reference and we will be building a version that is functional in style that maps straight into asynchronous work flows without and conversion
or adaptors.&lt;/p&gt;

&lt;h3 id=&#34;what-is-an-autoresetevent&#34;&gt;What is an AutoResetEvent?&lt;/h3&gt;

&lt;p&gt;An &lt;code&gt;AutoResetEvent&lt;/code&gt; can be described as a turnstile mechanism, it lets a single waiting person through before re-latching
waiting for the next signal.  This is opposed to a &lt;code&gt;ManualResetEvent&lt;/code&gt; which functions like an ordinary gate. Calling Set opens
the gate, allowing any number of threads that are waiting to be let through. Calling Reset closes the gate.&lt;/p&gt;

&lt;h3 id=&#34;asyncautoresetevent&#34;&gt;AsyncAutoResetEvent&lt;/h3&gt;

&lt;p&gt;First of all here is the shape of the type that we will be building:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;type AsyncAutoResetEvent =
    new : ?reusethread:bool -&amp;gt; AsyncAutoResetEvent
    member Set : unit -&amp;gt; unit
    member WaitAsync : unit -&amp;gt; Async&amp;lt;bool&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Fairly simple: implied constructor, &lt;code&gt;Set&lt;/code&gt; and &lt;code&gt;WaitAsync&lt;/code&gt; members.&lt;/p&gt;

&lt;h3 id=&#34;implied-constructor&#34;&gt;Implied Constructor&lt;/h3&gt;

&lt;p&gt;Thinking about this logically we may need the following items:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;A queue mechanism to store asynchronous waiters - &lt;code&gt;let mutable awaits = Queue&amp;lt;_&amp;gt;()&lt;/code&gt;.&lt;/li&gt;
&lt;li&gt;A way of knowing if a signal has been made in the absence of any waiters - &lt;code&gt;let mutable signalled = false&lt;/code&gt;.&lt;/li&gt;
&lt;li&gt;We can also declare a short-circuit asynchronous workflow for the situation that &lt;code&gt;Set()&lt;/code&gt; is called before &lt;code&gt;WaitAsync()&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;let completed = async.Return true&lt;/code&gt;.  This will save us constructing an &lt;code&gt;AsyncResultCell&amp;lt;_&amp;gt;&lt;/code&gt; and going though the
rest of the asynchronous mechanism.&lt;br /&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Also notice that an optional parameter called &lt;code&gt;reusethread&lt;/code&gt; is defined, we use the &lt;code&gt;?&lt;/code&gt; prefix when defining it to make it
optional.  We then make use of the &lt;code&gt;defaultArg&lt;/code&gt; function to give it a default value of false if a one is not passed in.  This
will be used in the &lt;code&gt;Set&lt;/code&gt; operation to determine if the code will run on the same thread or a thread in the ThreadPool.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;open System
open System.Threading
open System.Collections.Generic
 
    type AsyncAutoResetEvent(?reusethread) =
		let mutable awaits = Queue&amp;lt;_&amp;gt;()
		let mutable signalled = false
        let completed = async.Return true
        let reuseThread = defaultArg reusethread false
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;waitasync&#34;&gt;WaitAsync()&lt;/h3&gt;

&lt;p&gt;The first step is to use  a locking construct to control access to the mutable queue &lt;code&gt;awaits&lt;/code&gt;.  Inside this lock we
check to see if &lt;code&gt;signalled&lt;/code&gt; is true and if so we reset it to false and return our pre-built &lt;code&gt;completed&lt;/code&gt; asynchronous workflow.  If
signalled is false then we create a new &lt;code&gt;AsyncResultCell&amp;lt;_&amp;gt;&lt;/code&gt; and add it to the queue then return the &lt;code&gt;AsyncResult&lt;/code&gt; to the caller.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;        member x.WaitAsync() =
            lock awaits (fun () -&amp;gt;
                if signalled then
                    signalled &amp;lt;- false
                    completed
                else
                    let are = AsyncResultCell&amp;lt;_&amp;gt;()
                    awaits.Enqueue are
                    are.AsyncResult)
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;set&#34;&gt;Set()&lt;/h3&gt;

&lt;p&gt;We first declare a function called &lt;code&gt;getWaiter()&lt;/code&gt;, we use this function to return an &lt;a href=&#34;http://msdn.microsoft.com/en-us/library/dd233245.aspx&#34;&gt;option type&lt;/a&gt;
 that is either &lt;code&gt;Some AsyncResultCell&amp;lt;bool&amp;gt;&lt;/code&gt; or &lt;code&gt;None&lt;/code&gt;.  We use the lock function to control access to the mutable queue &lt;code&gt;lock awaits&lt;/code&gt;.  Once
inside the lock we use pattern matching to capture &lt;code&gt;awaits.Count&lt;/code&gt; and &lt;code&gt;signalled&lt;/code&gt;:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;The first pattern match &lt;code&gt;(x,_)&lt;/code&gt; checks if there are any waiters (&lt;code&gt;awaits.Count &amp;gt; 0&lt;/code&gt;) and then dequeues an &lt;code&gt;AsyncResultCell&amp;lt;bool&amp;gt;&lt;/code&gt; from the
queue and returns it within an option type: &lt;code&gt;Some &amp;lt;| awaits.Dequeue()&lt;/code&gt;.&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;The second pattern match &lt;code&gt;(_,y)&lt;/code&gt; checks whether &lt;code&gt;signalled&lt;/code&gt; is set to false before setting its value to true.  This causes next &lt;code&gt;WaitAsync()&lt;/code&gt;
caller to get the short-circuited value &lt;code&gt;completed&lt;/code&gt;.  This means that an &lt;code&gt;AsyncResultCell&amp;lt;bool&amp;gt;&lt;/code&gt; does not need to be created and go though the
whole async mechanism.  We then return &lt;code&gt;None&lt;/code&gt; as there is no waiter to be notified.&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;The final pattern match &lt;code&gt;(_,_)&lt;/code&gt; is used when there are no waiting callers and &lt;code&gt;signalled&lt;/code&gt; has already being set, there is simply nothing to do in
this situation so we return &lt;code&gt;None&lt;/code&gt;.&lt;br /&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;We use the &lt;code&gt;getWaiter()&lt;/code&gt; function via pattern match.  If we have a result i.e. Some AsyncResultCell&lt;bool&gt; then we call &lt;code&gt;RegisterResult&lt;/code&gt;
passing in &lt;code&gt;AsyncOK(true)&lt;/code&gt; to indicate a completion.  Notice that we also pass in the &lt;code&gt;reuseThread&lt;/code&gt; boolean that was declared as part of the
constructor.  If &lt;code&gt;reuseThread&lt;/code&gt; is true then the notification to the waiter happens &lt;strong&gt;synchronously&lt;/strong&gt; use this with care!  Personally I would stick
with the default of false to ensure that the operation is completed via the thread pool, unless you have a performance critical reason and the
waiting code that executes is &lt;strong&gt;very fast&lt;/strong&gt;.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;		member x.Set() =
		    let getWaiter()=
		        lock awaits (fun () -&amp;gt;
		            match (awaits.Count, signalled) with
		            | (x,_) when x &amp;gt; 0 -&amp;gt; Some &amp;lt;| awaits.Dequeue()
		            | (_,y) when not y -&amp;gt; signalled &amp;lt;- true;None
		            | (_,_) -&amp;gt; None)
		    match getWaiter() with
		    | Some a -&amp;gt; a.RegisterResult(AsyncOk(true), reuseThread)
		    | None _ -&amp;gt; ()
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The reason for using the &lt;code&gt;getWaiter()&lt;/code&gt; function is to separate the locking function away from the notification, if &lt;code&gt;RegisterResult&lt;/code&gt;
was called within the lock and &lt;code&gt;reuseThread&lt;/code&gt; was true then the awaiting function would be called synchronously within the lock which
would not be a very good situation to be in.&lt;/p&gt;

&lt;p&gt;So there we have it, I could take this series further and convert the other primitives that Stephen Toub describes but there should be
enough information in these two posts to set you on your way.  If anyone would like me to complete the series then let me know.  I
may well finish them off and post them on GitHub in the future, time permitting.&lt;/p&gt;

&lt;p&gt;Thanks for tuning in, until next time&amp;hellip;&lt;/p&gt;

&lt;hr style=&#34;margin: 1em 0&#34;&gt;
&lt;h1 id=&#34;essential-listening&#34;&gt;Essential listening:&lt;/h1&gt;


&lt;div class=&#34;pure-g&#34;&gt;

  
  
  
  
  &lt;div class=&#34;&#34;&gt;
    &lt;div style=&#34;width: 20%; float: left;padding: 0 .2em .2em 0&#34;&gt;
        &lt;figure style=&#34;margin: 0&#34;&gt;
            &lt;img src=&#34;http://upload.wikimedia.org/wikipedia/en/a/a8/CowboysFromHell.jpg&#34; style=&#34;margin: 0&#34;
                 alt=&#34;Pantera - Cowboys From Hell&#34; /&gt;
            &lt;figcaption&gt;
                &lt;h6&gt;Pantera - Cowboys From Hell&lt;/h4&gt;
            &lt;/figcaption&gt;
        &lt;/figure&gt;
    &lt;/div&gt;
  &lt;/div&gt;
  

  
  
  
  
  &lt;div class=&#34;&#34;&gt;
    &lt;div style=&#34;width: 20%; float: left;padding: 0 .2em .2em 0&#34;&gt;
        &lt;figure style=&#34;margin: 0&#34;&gt;
            &lt;img src=&#34;http://upload.wikimedia.org/wikipedia/en/0/09/Cacophony_-_1988_-_Go_Off%21.jpg&#34; style=&#34;margin: 0&#34;
                 alt=&#34;Cacophony - Go Off&#34; /&gt;
            &lt;figcaption&gt;
                &lt;h6&gt;Cacophony - Go Off&lt;/h4&gt;
            &lt;/figcaption&gt;
        &lt;/figure&gt;
    &lt;/div&gt;
  &lt;/div&gt;
  

&lt;/div&gt;




</description>
    </item>
    
    <item>
      <title>Back to the Primitive</title>
      <link>http://7sharpnine.com/2012/04/12/2012-04-12-back-to-the-primitive/</link>
      <pubDate>Thu, 12 Apr 2012 00:00:00 +0000</pubDate>
      
      <guid>http://7sharpnine.com/2012/04/12/2012-04-12-back-to-the-primitive/</guid>
      <description>&lt;p&gt;In this post we are going &lt;strong&gt;back to the primitive&lt;/strong&gt;.  No it&amp;rsquo;s not about the same named song by Soulfly, &lt;em&gt;(which incidentally does contains F# notes)&lt;/em&gt; but a return to thread synchronisation primitives and their asynchronous counterparts.&lt;/p&gt;

&lt;p&gt;We are going to be looking at an asynchronous version of the &lt;a href=&#34;http://msdn.microsoft.com/en-us/library/system.threading.manualresetevent.aspx&#34;&gt;ManualResetEvent&lt;/a&gt;.  This was
recently covered by Stephen Toub on the &lt;a href=&#34;http://blogs.msdn.com/b/pfxteam/archive/2012/02/11/10266920.aspx&#34;&gt;pfx team blog&lt;/a&gt;.  We will be taking a slightly different view on
this as we will be using asynchronous workflows which will give us nice idiomatic usage within F#.&lt;/p&gt;

&lt;p&gt;First lets look of the shape of the type that Stephen defined:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;public class AsyncManualResetEvent 
{ 
    public Task WaitAsync(); 
    public void Set(); 
    public void Reset(); 
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Now this can be used from within F# by using the &lt;code&gt;Async.AwaitTask&lt;/code&gt; function from the Async module but this is like wrapping one asynchronous paradigm with another, and
although this does work, what if you want to avoid the overhead of wrappers and stay strictly within async workflows.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-fsharp&#34;&gt;type asyncManualResetEvent() =
    member x.WaitAsync() : unit -&amp;gt; Async&amp;lt;bool&amp;gt;
    member x.Set() : unit -&amp;gt; unit
    member x.Reset() : unit -&amp;gt; unit
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;That&amp;rsquo;s what we want to see!  I don&amp;rsquo;t want to get into the details of the description of how the C# version works as Stephen does a very good job of that already.  What I will explain though is how we essentially do the same thing while staying with the realm of functional programming.  As we are getting into the lower lever details no doubt we will have to start relying on some low level locking primitives like Monitors, Semaphores, and Interlocked operations, even the F# core libraries have a
cornucopia of those.&lt;/p&gt;

&lt;p&gt;Lets look at the first member &lt;code&gt;WaitAsync()&lt;/code&gt;.  The first step is to create a something to store the result of the operation, all we will just be storing and returning
asynchronously is a boolean to indicate that the wait handle has been set.  To do this we use one of the types from the
&lt;a href=&#34;http://fsharppowerpack.codeplex.com/&#34;&gt;F# power pack&lt;/a&gt; &lt;code&gt;AsyncResultCell&amp;lt;&#39;T&amp;gt;&lt;/code&gt;.  I think that such a type should of been exposed from the F# core libraries but it was
omitted for some reason.  There is a type called &lt;code&gt;ResultCell&amp;lt;&#39;T&amp;gt;&lt;/code&gt; with much the same functionality in the FSharp.Core.Control namespace but it is marked internal so
it&amp;rsquo;s not available for our use.&lt;/p&gt;

&lt;p&gt;We declare a &lt;a href=&#34;http://msdn.microsoft.com/en-us/library/dd233186.aspx&#34;&gt;reference cell&lt;/a&gt; of type &lt;code&gt;AsyncResultCell&amp;lt;&#39;T&amp;gt;&lt;/code&gt; and then create the &lt;code&gt;WaitAsync()&lt;/code&gt; member, all we have
to do is dereference the value of the reference cell with &lt;code&gt;!&lt;/code&gt; and call its &lt;code&gt;AsyncResult&lt;/code&gt; member, this gives us an &lt;code&gt;Async&amp;lt;bool&amp;gt;&lt;/code&gt; which we can easily use in an asynchronous workflow.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-fsharp&#34;&gt;type asyncManualResetEvent() =
    let aResCell = ref &amp;lt;| AsyncResultCell&amp;lt;_&amp;gt;()

    member x.WaitAsync() = (!aResCell).AsyncResult
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The next bit is fairly simple too.  All we need to do is dereference the value of the reference cell, and invoke the &lt;code&gt;RegisterResult&lt;/code&gt; member by passing in a value of
 &lt;code&gt;AsyncOk(true)&lt;/code&gt;.  The boolean value of true will be used by the type inference system to constrain the value of the &lt;code&gt;Async&amp;lt;_&amp;gt;&lt;/code&gt; returned from &lt;code&gt;WaitAsync&lt;/code&gt;.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-fsharp&#34;&gt;    member x.Set() = (!aResCell).RegisterResult(AsyncOk(true))
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The last part is the most complex &lt;em&gt;(as usual)&lt;/em&gt;.  Here we create a recursive function called &lt;code&gt;swap&lt;/code&gt; that will try to exchange the &lt;code&gt;AsyncResultCell&amp;lt;&#39;T&amp;gt;&lt;/code&gt; for a new
one.  We dereference the reference cell to &lt;code&gt;currentValue&lt;/code&gt;, then we use a CAS (Compare And Swap) operation to compare the &lt;code&gt;aResCell&lt;/code&gt; with &lt;code&gt;currentValue&lt;/code&gt; and if they
are equal &lt;code&gt;newVal&lt;/code&gt; will replace &lt;code&gt;aResCell&lt;/code&gt;.  On the next line if the result of the CAS operation means that &lt;code&gt;result&lt;/code&gt; and &lt;code&gt;currentValue&lt;/code&gt; are equal then we are finished,
otherwise we spin the current thread for 20 cycles using &lt;code&gt;Thread.SpinWait 20&lt;/code&gt; before retrying the operation via recursion &lt;code&gt;swap newVal&lt;/code&gt;.  This will be a lot less
expensive than switching to user or kernel mode locking, and the period of contention between threads should be very small.  Finally the swap operation is started
by passing in a new &lt;code&gt;AsyncResultCell&amp;lt;&#39;T&amp;gt;&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;There are various other methods we could of used, for instance we could of wrapped a &lt;code&gt;ManualResetEvent&lt;/code&gt; with a call to &lt;code&gt;Async.AwaitWaitHandle&lt;/code&gt;, although this
would of meant using the kernel mode locking of the &lt;code&gt;ManualResetEvent&lt;/code&gt; which is a bit more expensive.&lt;/p&gt;

&lt;p&gt;In Stephen Toub&amp;rsquo;s post he mentions Task&amp;rsquo;s being orphaned due to the &lt;code&gt;Reset()&lt;/code&gt; method being called before the &lt;code&gt;Task&amp;lt;&#39;T&amp;gt;&lt;/code&gt; has been completed, that shouldn&amp;rsquo;t happen in our
implementation due the the closures being stored internally for completion by the async infrastructure.  Heres a quick test harness to make sure everything works as expected anyway.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-fsharp&#34;&gt;    member x.Reset() =
        let rec swap newVal = 
            let currentValue = !aResCell
            let result = Interlocked.CompareExchange&amp;lt;_&amp;gt;(aResCell, newVal, currentValue)
            if obj.ReferenceEquals(result, currentValue) then ()
            else Thread.SpinWait 20
                 swap newVal
        swap &amp;lt;| AsyncResultCell&amp;lt;_&amp;gt;()
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&#34;language-fsharp&#34;&gt;let amre = asyncManualResetEvent()
let x = async{let! x = amre.WaitAsync()
              Console.WriteLine(&amp;quot;First signalled&amp;quot;)}

let y = async{let! x = amre.WaitAsync()
             Console.WriteLine(&amp;quot;Second signalled&amp;quot;)}

let z = async{let! x = amre.WaitAsync()
              Console.WriteLine(&amp;quot;Third signalled&amp;quot;)}
//start async workflows x and y
Async.Start x
Async.Start y

//reset the asyncManualResetEvent, this will test whether the async workflows x and y 
// are orphaned due to the AsyncResultCell being recycled.
amre.Reset()

//now start the async z
Async.Start z

//we set a single time, this should result in the three async workflows completing
amre.Set()

Console.ReadLine() |&amp;gt; ignore
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Here we can see everything works out as we expected:&lt;/p&gt;


&lt;figure &gt;
    
        &lt;img src=&#34;https://lh6.googleusercontent.com/-NYIKC5Gaahs/T4YAQGtP9RI/AAAAAAAABR8/_cTOriC1_Fw/amre.png&#34; /&gt;
    
    
&lt;/figure&gt;


&lt;p&gt;Thats all there is too it, next time I will be exploring an asyncAutoResetEvent in much the same vein.&lt;/p&gt;

&lt;p&gt;Until next time&amp;hellip;&lt;/p&gt;

&lt;hr style=&#34;margin: 1em 0&#34;&gt;
&lt;h1 id=&#34;essential-listening&#34;&gt;Essential listening:&lt;/h1&gt;


&lt;div class=&#34;pure-g&#34;&gt;

  
  
  
  
  &lt;div class=&#34;&#34;&gt;
    &lt;div style=&#34;width: 20%; float: left;padding: 0 .2em .2em 0&#34;&gt;
        &lt;figure style=&#34;margin: 0&#34;&gt;
            &lt;img src=&#34;http://upload.wikimedia.org/wikipedia/en/f/fb/Zeitgeist_cover.png&#34; style=&#34;margin: 0&#34;
                 alt=&#34;Smashing Pumpkins Zeitgeist&#34; /&gt;
            &lt;figcaption&gt;
                &lt;h6&gt;Smashing Pumpkins Zeitgeist&lt;/h4&gt;
            &lt;/figcaption&gt;
        &lt;/figure&gt;
    &lt;/div&gt;
  &lt;/div&gt;
  

  
  
  
  
  &lt;div class=&#34;&#34;&gt;
    &lt;div style=&#34;width: 20%; float: left;padding: 0 .2em .2em 0&#34;&gt;
        &lt;figure style=&#34;margin: 0&#34;&gt;
            &lt;img src=&#34;http://upload.wikimedia.org/wikipedia/en/3/34/Primitive.png&#34; style=&#34;margin: 0&#34;
                 alt=&#34;Soulfly Primitive&#34; /&gt;
            &lt;figcaption&gt;
                &lt;h6&gt;Soulfly Primitive&lt;/h4&gt;
            &lt;/figcaption&gt;
        &lt;/figure&gt;
    &lt;/div&gt;
  &lt;/div&gt;
  

  
  
  
  
  &lt;div class=&#34;&#34;&gt;
    &lt;div style=&#34;width: 20%; float: left;padding: 0 .2em .2em 0&#34;&gt;
        &lt;figure style=&#34;margin: 0&#34;&gt;
            &lt;img src=&#34;http://upload.wikimedia.org/wikipedia/en/0/0d/FooFighters-FooFighters.jpg&#34; style=&#34;margin: 0&#34;
                 alt=&#34;FooFighters&#34; /&gt;
            &lt;figcaption&gt;
                &lt;h6&gt;FooFighters&lt;/h4&gt;
            &lt;/figcaption&gt;
        &lt;/figure&gt;
    &lt;/div&gt;
  &lt;/div&gt;
  

&lt;/div&gt;




</description>
    </item>
    
  </channel>
</rss>