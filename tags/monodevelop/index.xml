<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Monodevelop on 7sharp9</title>
    <link>http://7sharpnine.com/tags/monodevelop/</link>
    <description>Recent content in Monodevelop on 7sharp9</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <copyright>Dave Thomas</copyright>
    <lastBuildDate>Wed, 10 Dec 2014 00:00:00 +0000</lastBuildDate>
    <atom:link href="http://7sharpnine.com/tags/monodevelop/index.xml" rel="self" type="application/rss+xml" />
    
    <item>
      <title>Terror From The Deep</title>
      <link>http://7sharpnine.com/2014/12/10/2014-12-07-terror-from-the-deep/</link>
      <pubDate>Wed, 10 Dec 2014 00:00:00 +0000</pubDate>
      
      <guid>http://7sharpnine.com/2014/12/10/2014-12-07-terror-from-the-deep/</guid>
      <description>


&lt;figure class=&#34;img-left&#34;&gt;
    
        &lt;img src=&#34;https://dl.dropboxusercontent.com/s/29mripr5z1ik5tr/tftd.png?dl=0&#34; /&gt;
    
    
&lt;/figure&gt;


&lt;p&gt;So this is my Christmas special.  I&amp;rsquo;ve been asked on numerous times to write about the F# addin for Xamarin studio which is in the &lt;a href=&#34;https://github.com/fsharp/fsharpbinding&#34;&gt;fsharpbinding repo&lt;/a&gt;, this repo is shared with the emacs support and also the Sublime Text support.  So in this edition we will be taking a deep dive into the terrifying deep depths of the F# compiler and F# addin development&amp;hellip;&lt;/p&gt;

&lt;p&gt;Actually I&amp;rsquo;m only joking, adding features to the F# compiler and F# addin is fairly easy depending on what you want to do.  You can run into issues along the way which means you might need to delve into more of the F# compilers functionality, essentially to derive and adapt new functions that you might need.&lt;/p&gt;

&lt;p&gt;What I&amp;rsquo;m going to show is how to add a new autocompletion list where instead of a standard completion list, its categorised by the type that the methods are derived from.  As an example you would be able to see the &lt;code&gt;ToString&lt;/code&gt; methods etc on the &lt;code&gt;Obj&lt;/code&gt; type andy other methods defined on their particular derived type.&lt;/p&gt;

&lt;h2 id=&#34;one-door-leads-to-the-source&#34;&gt;One door leads to the source&lt;/h2&gt;

&lt;p&gt;Lets have a look at the current completion list function in the F# compiler:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-fsharp&#34;&gt;member GetDeclarationsAlternate : 
	ParsedFileResultsOpt:ParseFileResults option * 
	line: int * 
	colAtEndOfPartialName: int * 
	lineText:string * qualifyingNames: 
	string list * 
	partialName: string * 
	?hasTextChangedSinceLastTypecheck: (obj * range -&amp;gt; bool) 
	-&amp;gt; Async&amp;lt;DeclarationSet&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Essentially this function takes a lot of parameters, I don&amp;rsquo;t want to go into the details too much as the &lt;a href=&#34;http://fsharp.github.io/FSharp.Compiler.Service/editor.html#Getting-auto-complete-lists&#34;&gt;FCS sample pages&lt;/a&gt; does a good job of that.  So what is a &lt;code&gt;DeclarationSet&lt;/code&gt;?  Well as you expect its a collection of &lt;code&gt;Declarations&lt;/code&gt;.  A Declaration has a &lt;code&gt;Glyph&lt;/code&gt;, &lt;code&gt;Name&lt;/code&gt;, and &lt;code&gt;DescriptionText&lt;/code&gt;.  The &lt;code&gt;DescriptionText&lt;/code&gt; is a &lt;code&gt;ToolTipText&lt;/code&gt; which is a text based rendering of the declaration in question.&lt;/p&gt;

&lt;h3 id=&#34;tooltipelement&#34;&gt;ToolTipElement&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&#34;language-fsharp&#34;&gt;/// Describe a comment as either a block of text or a file+signature reference into an intellidoc file.
type XmlComment =
| XmlCommentNone
| XmlCommentText of string
| XmlCommentSignature of (*File and Signature*) string * string

/// A single data tip display element
type ToolTipElement = 
| ToolTipElementNone
/// A single type, method, etc with comment.
| ToolTipElement of (* text *) string * XmlComment
// /// A parameter of a method.
// | ToolTipElementParameter of string * XmlComment * string
/// For example, a method overload group.
| ToolTipElementGroup of ((* text *) string * XmlComment) list
/// An error occurred formatting this element
| ToolTipElementCompositionError of string
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;At first glance this information is quite interesting but in use the limitation of text based rendering becomes apparent.  How can you break down the information into easily renderable parts or know the underlying types that make up the declaration.  Text based manipulation means a lot of work, and also lots of potential bugs, as you would expect with text based or weakly typed system.&lt;/p&gt;

&lt;p&gt;Lets have a look at the &lt;code&gt;GetDeclarationsAlternate&lt;/code&gt; function and see if we have access to any detailed information:&lt;/p&gt;

&lt;h3 id=&#34;getdeclarationsalternate&#34;&gt;GetDeclarationsAlternate&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&#34;language-fsharp&#34;&gt;    member info.GetDeclarationsAlternate(parseResultsOpt, line, colAtEndOfNamesAndResidue, lineStr, qualifyingNames, partialName, ?hasTextChangedSinceLastTypecheck) = 
        let hasTextChangedSinceLastTypecheck = defaultArg hasTextChangedSinceLastTypecheck (fun _ -&amp;gt; false)
        reactorOp DeclarationSet.Empty (fun scope -&amp;gt; scope.GetDeclarations(parseResultsOpt, line, lineStr, colAtEndOfNamesAndResidue, qualifyingNames, partialName, hasTextChangedSinceLastTypecheck))
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;OK, so that just calls &lt;code&gt;GetDeclarations&lt;/code&gt; after doing a check for changes since the last type check, lets go deeper&amp;hellip;&lt;/p&gt;

&lt;h3 id=&#34;getdeclarations&#34;&gt;GetDeclarations&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&#34;language-fsharp&#34;&gt;    member x.GetDeclarations (parseResultsOpt:ParseFileResults option, line, lineStr, colAtEndOfNamesAndResidue, qualifyingNames, partialName, hasTextChangedSinceLastTypecheck) : DeclarationSet =
        let isInterfaceFile = SourceFileImpl.IsInterfaceFile mainInputFileName
        ErrorScope.Protect 
            Range.range0 
            (fun () -&amp;gt; 
                match GetDeclItemsForNamesAtPosition(parseResultsOpt, Some qualifyingNames, Some partialName, line, lineStr, colAtEndOfNamesAndResidue, ResolveTypeNamesToCtors, ResolveOverloads.Yes, hasTextChangedSinceLastTypecheck) with
                | None -&amp;gt; DeclarationSet.Empty  
                | Some(items,denv,m) -&amp;gt; 
                    let items = items |&amp;gt; filterIntellisenseCompletionsBasedOnParseContext (parseResultsOpt |&amp;gt; Option.bind (fun x -&amp;gt; x.ParseTree)) (mkPos line colAtEndOfNamesAndResidue)
                    let items = if isInterfaceFile then items |&amp;gt; List.filter IsValidSignatureFileItem else items
                    DeclarationSet.Create(infoReader,m,denv,items,reactorOps,checkAlive))
            (fun msg -&amp;gt; DeclarationSet.Error msg)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Right, this is more interesting, if we look at the pattern match &lt;code&gt;match filterIntellisenseCompletionsBasedOnParseContext&lt;/code&gt; you can see we have there are &lt;code&gt;items&lt;/code&gt;, &lt;code&gt;denv&lt;/code&gt;, and &lt;code&gt;m&lt;/code&gt;.  Now what exactly is an &lt;code&gt;Item&lt;/code&gt;?&lt;/p&gt;

&lt;p&gt;Lets go deeper still and take a look&amp;hellip;.&lt;/p&gt;

&lt;h3 id=&#34;item&#34;&gt;Item&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&#34;language-fsharp&#34;&gt;/// Represents an item that results from name resolution
type Item = 
    /// Represents the resolution of a name to an F# value or function.
    | Value of  ValRef
    /// Represents the resolution of a name to an F# union case.
    | UnionCase of UnionCaseInfo
    /// Represents the resolution of a name to an F# active pattern result.
    | ActivePatternResult of ActivePatternInfo * TType * int  * range
    /// Represents the resolution of a name to an F# active pattern case within the body of an active pattern.
    | ActivePatternCase of ActivePatternElemRef 
    /// Represents the resolution of a name to an F# exception definition.
    | ExnCase of TyconRef 
    /// Represents the resolution of a name to an F# record field.
    | RecdField of RecdFieldInfo

    // The following are never in the items table but are valid results of binding an identitifer in different circumstances. 

    /// Represents the resolution of a name at the point of its own definition.
    | NewDef of Ident
    /// Represents the resolution of a name to a .NET field 
    | ILField of ILFieldInfo
    /// Represents the resolution of a name to an event
    | Event of EventInfo
    /// Represents the resolution of a name to a property
    | Property of string * PropInfo list
    /// Represents the resolution of a name to a group of methods
    | MethodGroup of string * MethInfo list
    /// Represents the resolution of a name to a constructor
    | CtorGroup of string * MethInfo list
    /// Represents the resolution of a name to the fake constructor simulated for an interface type.
    | FakeInterfaceCtor of TType
    /// Represents the resolution of a name to a delegate
    | DelegateCtor of TType
    /// Represents the resolution of a name to a group of types
    | Types of string * TType list
    /// CustomOperation(nm, helpText, methInfo)
    /// Used to indicate the availability or resolution of a custom query operation such as &#39;sortBy&#39; or &#39;where&#39; in computation expression syntax
    | CustomOperation of string * (unit -&amp;gt; string option) * MethInfo option
    /// Represents the resolution of a name to a custom builder in the F# computation expression syntax
    | CustomBuilder of string * ValRef
    /// Represents the resolution of a name to a type variable
    | TypeVar of string * Typar
    /// Represents the resolution of a name to a module or namespace
    | ModuleOrNamespaces of Tast.ModuleOrNamespaceRef list
    /// Represents the resolution of a name to an operator
    | ImplicitOp of Ident * TraitConstraintSln option ref
    /// Represents the resolution of a name to a named argument
    | ArgName of Ident * TType * ArgumentContainer option
    /// Represents the resolution of a name to a named property setter
    | SetterArg of Ident * Item 
    /// Represents the potential resolution of an unqualified name to a type.
    | UnqualifiedType of TyconRef list
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Finally lets look at the &lt;code&gt;Create&lt;/code&gt; function of &lt;code&gt;DeclarationSet&lt;/code&gt; to see what&amp;rsquo;s involved:&lt;/p&gt;

&lt;h3 id=&#34;declarationset-create&#34;&gt;DeclarationSet - Create&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&#34;language-fsharp&#34;&gt;// Make a &#39;Declarations&#39; object for a set of selected items
static member Create(infoReader:InfoReader, m, denv, items, reactor, checkAlive) = 
    let g = infoReader.g
     
    let items = items |&amp;gt; RemoveExplicitlySuppressed g
    
    // Sort by name. For things with the same name, 
    //     - show types with fewer generic parameters first
    //     - show types before over other related items - they usually have very useful XmlDocs 
    let items = 
        items |&amp;gt; List.sortBy (fun d -&amp;gt; 
            let n = 
                match d with  
                | Item.Types (_,(TType_app(tcref,_) :: _)) -&amp;gt; 1 + tcref.TyparsNoRange.Length
                // Put delegate ctors after types, sorted by #typars. RemoveDuplicateItems will remove FakeInterfaceCtor and DelegateCtor if an earlier type is also reported with this name
                | Item.FakeInterfaceCtor (TType_app(tcref,_)) 
                | Item.DelegateCtor (TType_app(tcref,_)) -&amp;gt; 1000 + tcref.TyparsNoRange.Length
                // Put type ctors after types, sorted by #typars. RemoveDuplicateItems will remove DefaultStructCtors if a type is also reported with this name
                | Item.CtorGroup (_, (cinfo :: _)) -&amp;gt; 1000 + 10 * (tcrefOfAppTy g cinfo.EnclosingType).TyparsNoRange.Length 
                | _ -&amp;gt; 0
            (d.DisplayName,n))

    // Remove all duplicates. We&#39;ve put the types first, so this removes the DelegateCtor and DefaultStructCtor&#39;s.
    let items = items |&amp;gt; RemoveDuplicateItems g

    if verbose then dprintf &amp;quot;service.ml: mkDecls: %d found groups after filtering\n&amp;quot; (List.length items); 

    // Group by display name
    let items = items |&amp;gt; List.groupBy (fun d -&amp;gt; d.DisplayName) 

    // Filter out operators (and list)
    let items = 
        // Check whether this item looks like an operator.
        let isOpItem(nm,item) = 
            match item with 
            | [Item.Value _]
            | [Item.MethodGroup(_,[_])] -&amp;gt; 
                (IsOpName nm) &amp;amp;&amp;amp; nm.[0]=&#39;(&#39; &amp;amp;&amp;amp; nm.[nm.Length-1]=&#39;)&#39;
            | [Item.UnionCase _] -&amp;gt; IsOpName nm
            | _ -&amp;gt; false              
        let isFSharpList nm = (nm = &amp;quot;[]&amp;quot;) // list shows up as a Type and a UnionCase, only such entity with a symbolic name, but want to filter out of intellisense
        items |&amp;gt; List.filter (fun (nm,items) -&amp;gt; not (isOpItem(nm,items)) &amp;amp;&amp;amp; not(isFSharpList nm)) 


    let decls = 
        // Filter out duplicate names
        items |&amp;gt; List.map (fun (nm,itemsWithSameName) -&amp;gt; 
            match itemsWithSameName with
            | [] -&amp;gt; failwith &amp;quot;Unexpected empty bag&amp;quot;
            | items -&amp;gt; 
                new Declaration(nm, GlyphOfItem(denv,items.Head), Choice1Of2 (items, infoReader, m, denv, reactor, checkAlive)))

    new DeclarationSet(Array.ofList decls)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;This looks very promising, this information could be just what we need.  If we do a quick search and see what else uses &lt;code&gt;Items&lt;/code&gt; so we can get a better idea of how its used.  Lets just see if there are any pattern matches for Item.Value to get a quick idea:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;nameres.fs&lt;/li&gt;
&lt;li&gt;tc.fs&lt;/li&gt;
&lt;li&gt;fsi.fs&lt;/li&gt;
&lt;li&gt;service.fs&lt;/li&gt;
&lt;li&gt;ServiceDeclarations.fs&lt;/li&gt;
&lt;li&gt;Symbols.fs&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;you-re-a-symbol-for-your-kind&#34;&gt;You&amp;rsquo;re a symbol for your kind&lt;/h2&gt;

&lt;p&gt;The matches in &lt;code&gt;Symbol.fs&lt;/code&gt; look interesting, you can see it&amp;rsquo;s relatively easy to construct a &lt;code&gt;Symbol&lt;/code&gt; if you have access to the relevant parts.  Having a list of symbols available rather than a &lt;code&gt;DeclarationSet&lt;/code&gt; of &lt;code&gt;ToolTipElement&lt;/code&gt; could be just what we need.&lt;/p&gt;

&lt;p&gt;Lets look at constructing a symbol rather than the declaration set:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-fsharp&#34;&gt;member x.GetDeclarationListSymbols (parseResultsOpt:FSharpParseFileResults option, line, lineStr, colAtEndOfNamesAndResidue, qualifyingNames, partialName, hasTextChangedSinceLastTypecheck) =
    let isInterfaceFile = SourceFileImpl.IsInterfaceFile mainInputFileName
    ErrorScope.Protect 
        Range.range0 
        (fun () -&amp;gt; 
            match GetDeclItemsForNamesAtPosition(parseResultsOpt, Some qualifyingNames, Some partialName, line, lineStr, colAtEndOfNamesAndResidue, ResolveTypeNamesToCtors, ResolveOverloads.Yes, hasTextChangedSinceLastTypecheck) with
            | None -&amp;gt; List.Empty  
            | Some(items,_denv,_m) -&amp;gt; 
                let items = items |&amp;gt; filterIntellisenseCompletionsBasedOnParseContext (parseResultsOpt |&amp;gt; Option.bind (fun x -&amp;gt; x.ParseTree)) (mkPos line colAtEndOfNamesAndResidue)
                let items = if isInterfaceFile then items |&amp;gt; List.filter IsValidSignatureFileItem else items

                //do filtering like Declarationset
                let items = items |&amp;gt; RemoveExplicitlySuppressed g
                
                // Sort by name. For things with the same name, 
                //     - show types with fewer generic parameters first
                //     - show types before over other related items - they usually have very useful XmlDocs 
                let items = 
                    items |&amp;gt; List.sortBy (fun d -&amp;gt; 
                        let n = 
                            match d with  
                            | Item.Types (_,(TType_app(tcref,_) :: _)) -&amp;gt; 1 + tcref.TyparsNoRange.Length
                            // Put delegate ctors after types, sorted by #typars. RemoveDuplicateItems will remove FakeInterfaceCtor and DelegateCtor if an earlier type is also reported with this name
                            | Item.FakeInterfaceCtor (TType_app(tcref,_)) 
                            | Item.DelegateCtor (TType_app(tcref,_)) -&amp;gt; 1000 + tcref.TyparsNoRange.Length
                            // Put type ctors after types, sorted by #typars. RemoveDuplicateItems will remove DefaultStructCtors if a type is also reported with this name
                            | Item.CtorGroup (_, (cinfo :: _)) -&amp;gt; 1000 + 10 * (tcrefOfAppTy g cinfo.EnclosingType).TyparsNoRange.Length 
                            | _ -&amp;gt; 0
                        (d.DisplayName,n))

                // Remove all duplicates. We&#39;ve put the types first, so this removes the DelegateCtor and DefaultStructCtor&#39;s.
                let items = items |&amp;gt; RemoveDuplicateItems g

                if verbose then dprintf &amp;quot;service.ml: mkDecls: %d found groups after filtering\n&amp;quot; (List.length items); 

                // Group by display name
                let items = items |&amp;gt; List.groupBy (fun d -&amp;gt; d.DisplayName) 

                // Filter out operators (and list)
                let items = 
                    // Check whether this item looks like an operator.
                    let isOpItem(nm,item) = 
                        match item with 
                        | [Item.Value _]
                        | [Item.MethodGroup(_,[_])] -&amp;gt; 
                            (IsOpName nm) &amp;amp;&amp;amp; nm.[0]=&#39;(&#39; &amp;amp;&amp;amp; nm.[nm.Length-1]=&#39;)&#39;
                        | [Item.UnionCase _] -&amp;gt; IsOpName nm
                        | _ -&amp;gt; false              
                    let isFSharpList nm = (nm = &amp;quot;[]&amp;quot;) // list shows up as a Type and a UnionCase, only such entity with a symbolic name, but want to filter out of intellisense
                    items |&amp;gt; List.filter (fun (nm,items) -&amp;gt; not (isOpItem(nm,items)) &amp;amp;&amp;amp; not(isFSharpList nm)) 

                let items = 
                    // Filter out duplicate names
                    items |&amp;gt; List.map (fun (_nm,itemsWithSameName) -&amp;gt; 
                        match itemsWithSameName with
                        | [] -&amp;gt; failwith &amp;quot;Unexpected empty bag&amp;quot;
                        | items -&amp;gt;
                            items 
                            |&amp;gt; List.map (fun item -&amp;gt; let symbol = FSharpSymbol.Create(g, thisCcu, tcImports, item)
                                                     FSharpSymbolUse(g, _denv, symbol, ItemOccurence.Use, _m)))

                //end filtering
                items)
        (fun _msg -&amp;gt; [])
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Looking at the code you can see its various pieces &lt;em&gt;cobbled&lt;/em&gt; together to construct an &lt;code&gt;FSharpSymbolUSe&lt;/code&gt; rather than a &lt;code&gt;DeclarationSet&lt;/code&gt;.  This should allow us to create a more elaborate autocompletion which displays members by base type rather than a flat list.&lt;/p&gt;

&lt;h2 id=&#34;there-are-no-flowers-in-the-real-world&#34;&gt;There Are No Flowers in the Real World…&lt;/h2&gt;

&lt;p&gt;So that&amp;rsquo;s the easy bit done, now over to MonoDevelop.  We need to rip out the old completions and splice in the new one, currently it&amp;rsquo;s defined in &lt;code&gt;FSharpTextEditorCompletion&lt;/code&gt; and &lt;code&gt;FSharpMemberCompletionData&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;Lets have a look at &lt;code&gt;CompletionData&lt;/code&gt; which we will need to recreate for our purposes:&lt;/p&gt;

&lt;h3 id=&#34;completiondata&#34;&gt;CompletionData&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&#34;language-fsharp&#34;&gt;type CompletionData
	abstract member Icon : IconId with get, set
	abstract member DisplayText : string with get, set
	abstract member Description : string with get, set
	abstract member CompletionText : string with get, set
	abstract member GetDisplayDescription : bool -&amp;gt; string
	abstract member GetRightSideDescription : bool -&amp;gt; string
	abstract member CompletionCategory : CompletionCategory with get, set
	abstract member DisplayFlags : DisplayFlags with get, set
	abstract member CreateTooltipInformation : bool -&amp;gt; TooltipInformation
	abstract member HasOverloads : () -&amp;gt; bool
	abstract member OverloadedData : () -&amp;gt; IEnumerable&amp;lt;ICompletionData&amp;gt;
	abstract member AddOverload : ICompletionData -&amp;gt; () 
	abstract member InsertCompletionText : CompletionListWindow * ref KeyActions * Gdk.Key * char * Gdk.ModifierType -&amp;gt; ()
	abstract member CompareTo : obj -&amp;gt; int
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;All of these are virtual in the &lt;code&gt;CompletionData&lt;/code&gt; type, what we will need to do is add overrides for the &lt;code&gt;HasOverloads&lt;/code&gt;, &lt;code&gt;OverloadedData&lt;/code&gt;, &lt;code&gt;AddOverload&lt;/code&gt;, and &lt;code&gt;CreateTooltipInformation&lt;/code&gt; to give us the functionality we require.  It&amp;rsquo;s going to be vety similar to the old code except we will be using symbols rather than &lt;code&gt;ToolTipElement&lt;/code&gt; data to create the completion data.&lt;/p&gt;

&lt;p&gt;Lets create a new &lt;code&gt;FSharpMemberCompletionData&lt;/code&gt;:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-fsharp&#34;&gt;type internal FSharpMemberCompletionDataSorted(name, icon, symbol:FSharpSymbol, overloads:FSharpSymbol seq) =
    inherit CompletionData(CompletionText = Lexhelp.Keywords.QuoteIdentifierIfNeeded name, 
                           DisplayText = name, 
                           DisplayFlags = DisplayFlags.DescriptionHasMarkup,
                           Icon = icon)

    /// Check if the datatip has multiple overloads
    override x.HasOverloads = not (Seq.isEmpty overloads)

    /// Split apart the elements into separate overloads
    override x.OverloadedData =
        overloads
        |&amp;gt; Seq.map (fun symbol -&amp;gt; FSharpMemberCompletionDataSorted(symbol.DisplayName, icon, symbol, Seq.empty) :&amp;gt; _ )

    override x.AddOverload (data: ICompletionData) = ()

    override x.CreateTooltipInformation (smartWrap: bool) = 
      let tip = SymbolTooltips.getTooltipFromSymbol symbol FSharpDisplayContext.Empty None
      match tip  with
      | ToolTips.ToolTip (signature, xmldoc) -&amp;gt;
            let toolTipInfo = new TooltipInformation(SignatureMarkup = signature)
            match xmldoc with
            | Full(summary) -&amp;gt; toolTipInfo.SummaryMarkup &amp;lt;- summary
                               toolTipInfo
            | Lookup(key, potentialFilename) -&amp;gt;
                let summary = 
                    maybe {let! filename = potentialFilename
                           let! markup = TipFormatter.findDocForEntity(filename, key)
                           let summary = Tooltips.getTooltip Styles.simpleMarkup markup
                           return summary }
                summary |&amp;gt; Option.iter (fun summary -&amp;gt; toolTipInfo.SummaryMarkup &amp;lt;- summary)
                toolTipInfo
            | EmptyDoc -&amp;gt; toolTipInfo
      | _ -&amp;gt; TooltipInformation()
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;In this section you can see the use of the &lt;code&gt;maybe&lt;/code&gt; computation expression &lt;em&gt;(You wont find the &amp;rsquo;M&amp;rsquo; word mentioned here thank you very much!)&lt;/em&gt; to simplify the creation of the &lt;code&gt;Lookup&lt;/code&gt; tooltip&amp;rsquo;s.  &lt;code&gt;Lookup&lt;/code&gt; means pulling the information from &lt;a href=&#34;http://www.mono-project.com/docs/tools+libraries/tools/monodoc/&#34;&gt;monodoc&lt;/a&gt; which loads the xmldoc files, and &lt;code&gt;Full&lt;/code&gt; means there is xmldoc&amp;rsquo;s present in the compiler.  &lt;code&gt;Full&lt;/code&gt; will occur in your own files and &lt;code&gt;Lookup&lt;/code&gt; will occur in referenced assemblies.&lt;/p&gt;

&lt;p&gt;We also need a define little type to hold the category as the &lt;code&gt;CompletionCategory&lt;/code&gt; type is abstract:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-fsharp&#34;&gt;type Category(category) =
    inherit CompletionCategory(category, null)
    override x.CompareTo other = compare x.DisplayText other.DisplayText
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Next we will add a function called &lt;code&gt;getCompletionData&lt;/code&gt; to the existing &lt;code&gt;FSharpTextEditorCompletion&lt;/code&gt;.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-fsharp&#34;&gt;let getCompletionData (symbols:FSharpSymbol list list) =

    let categories = Dictionary&amp;lt;string, Category&amp;gt;()

    let getOrAddCategory id =
        let found, item = categories.TryGetValue id
        if found then item
        else let cat = Category id 
             categories.Add (id,cat)
             cat

    let (|Function|Val|Unknown|) (symbol:FSharpSymbol) =
      match symbol with
      | MemberOrFunctionOrValue symbol
          when not (isConstructor symbol) -&amp;gt;
              if symbol.FullType.IsFunctionType &amp;amp;&amp;amp; not symbol.IsPropertyGetterMethod &amp;amp;&amp;amp; not symbol.IsPropertySetterMethod 
              then Function symbol                         
              else Val symbol
      | _ -&amp;gt; Unknown symbol

    let symbolToIcon (s:FSharpSymbol) = 
        match s with
        | ActivePatternCase _ -&amp;gt; Stock.Enum
        | Field _ -&amp;gt; Stock.Field
        | UnionCase _ -&amp;gt; Stock.Enum
        | Class -&amp;gt; Stock.Class
        | Delegate -&amp;gt; Stock.Delegate
        | Event -&amp;gt; Stock.Event
        | Property -&amp;gt; Stock.Property
        | Function _ -&amp;gt; MStock.Method
        | Val _ -&amp;gt; Stock.Field
        | Enum -&amp;gt; Stock.Enum
        | Interface -&amp;gt; Stock.Interface
        | Module -&amp;gt; Stock.Class
        | Namespace -&amp;gt; Stock.NameSpace
        | Record -&amp;gt; Stock.Class
        | Union -&amp;gt; Stock.Enum
        | ValueType -&amp;gt; Stock.Struct
        | _ -&amp;gt; Stock.Struct

    let symbolToCompletionData (symbol:FSharpSymbol) =
       let cd = FSharpMemberCompletionDataSorted(symbol.Head.DisplayName, symbolToIcon symbol.Head, symbol.Head, symbol.Tail)
       match symbol.Head with
       | :? FSharpMemberOrFunctionOrValue as func -&amp;gt;
           d.CompletionCategory &amp;lt;- getOrAddCategory func.EnclosingEntity.FullName
       | other -&amp;gt;
       cd.CompletionCategory &amp;lt;- getOrAddCategory (other.FullName.Substring (0, other.FullName.LastIndexOf &#39;.&#39;))

    symbols
    |&amp;gt; List.map symbolToCompletionData
    :&amp;gt; ICompletionData)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;We have a few helper function&amp;rsquo;s here, &lt;code&gt;getOrAddCategory&lt;/code&gt; to get or add categories.  An active pattern &lt;code&gt;(|Function|Val|Unknown|)&lt;/code&gt; to help to split &lt;code&gt;MemberOrFunctionOrValue&lt;/code&gt; into &lt;code&gt;Function&lt;/code&gt;, &lt;code&gt;Val&lt;/code&gt; or &lt;code&gt;Unknown&lt;/code&gt; sub types.  &lt;code&gt;symbolToIcon&lt;/code&gt; to get a stock icon to represent the different types of item that will appear in the completion list.  And finally we have a map function, &lt;code&gt;symbolToCompletionData&lt;/code&gt; which uses all of the other helper functions to project each symbol into a new &lt;code&gt;FSharpMemberCompletionDataSorted&lt;/code&gt;.  This is done by using either &lt;code&gt;func.EnclosingEntity.FullName&lt;/code&gt; if the type match is &lt;code&gt;FSharpMemberOrFunctionOrValue&lt;/code&gt; or &lt;code&gt;other.FullName.Substring (0, other.FullName.LastIndexOf &#39;.&#39;)&lt;/code&gt; if the type match is anything else.&lt;/p&gt;

&lt;p&gt;You can see that the symbols are mapped using &lt;code&gt;List.map&lt;/code&gt; and &lt;code&gt;symbolToCompletionData&lt;/code&gt; at the end of the function.  The resulting &lt;code&gt;FSharpMemberCompletionDataSorted&lt;/code&gt; is finally coerced into an &lt;code&gt;ICompletionData&lt;/code&gt; with the &lt;code&gt;:&amp;gt;&lt;/code&gt; operator.&lt;/p&gt;

&lt;p&gt;Finally all that&amp;rsquo;s left is to change &lt;code&gt;x.CodeCompletionCommandImpl&lt;/code&gt; in &lt;code&gt;FSharpTextEditorCompletion&lt;/code&gt;, all we need to do is change the match statement to use the functions we defined above:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-fsharp&#34;&gt;match tyRes.GetDeclarations(line, col, lineStr) with
| Some(decls, residue) when decls.Items.Any() -&amp;gt;
      let items = decls.Items
                  |&amp;gt; Array.map (fun mi -&amp;gt; FSharpMemberCompletionData(mi) :&amp;gt; ICompletionData)
      result.AddRange(items)
| _ -&amp;gt; ()
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;To use the new &lt;code&gt;GetDeclarationSymbols&lt;/code&gt; function:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-fsharp&#34;&gt;match tyRes.GetDeclarationSymbols(line, col, lineStr) with
| Some (symbols, residue) -&amp;gt; result.AddRange (getCompletionData symbols)
| None -&amp;gt; ()
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Phew! I think we are done.  Spinning up Xamarin Studio with the new addin shows the new completion list:&lt;br /&gt;

&lt;figure &gt;
    
        &lt;img src=&#34;https://dl.dropboxusercontent.com/s/hkojvf87qyuxvla/completion.png?dl=0&#34; /&gt;
    
    
&lt;/figure&gt;
&lt;/p&gt;

&lt;p&gt;We now have completion list sorted by the inheritor, which is especially nice for displaying members on hierarchical API&amp;rsquo;s.  As a little bonus pressing &lt;code&gt;Shift Up/Down&lt;/code&gt; will also move between the categories.&lt;/p&gt;

&lt;p&gt;See, that wasn&amp;rsquo;t so scary was it?&lt;/p&gt;

&lt;p&gt;Until next time!&lt;/p&gt;

&lt;hr style=&#34;margin: 1em 0&#34;&gt;
&lt;h1 id=&#34;essential-listening&#34;&gt;Essential listening:&lt;/h1&gt;


&lt;div class=&#34;pure-g&#34;&gt;

  
  
  
  
  &lt;div class=&#34;&#34;&gt;
    &lt;div style=&#34;width: 20%; float: left;padding: 0 .2em .2em 0&#34;&gt;
        &lt;figure style=&#34;margin: 0&#34;&gt;
            &lt;img src=&#34;http://upload.wikimedia.org/wikipedia/en/4/40/Megadeth_-_Peace_Sells..._But_Who%27s_Buying-.jpg&#34; style=&#34;margin: 0&#34;
                 alt=&#34;Megadeth - Peace Sells... But Who&amp;#39;s Buying&#34; /&gt;
            &lt;figcaption&gt;
                &lt;h6&gt;Megadeth - Peace Sells... But Who&amp;#39;s Buying&lt;/h4&gt;
            &lt;/figcaption&gt;
        &lt;/figure&gt;
    &lt;/div&gt;
  &lt;/div&gt;
  

  
  
  
  
  &lt;div class=&#34;&#34;&gt;
    &lt;div style=&#34;width: 20%; float: left;padding: 0 .2em .2em 0&#34;&gt;
        &lt;figure style=&#34;margin: 0&#34;&gt;
            &lt;img src=&#34;http://upload.wikimedia.org/wikipedia/en/7/7f/Megadeth-SoFar.jpg&#34; style=&#34;margin: 0&#34;
                 alt=&#34;Megadeth - So far, so good, so what&#34; /&gt;
            &lt;figcaption&gt;
                &lt;h6&gt;Megadeth - So far, so good, so what&lt;/h4&gt;
            &lt;/figcaption&gt;
        &lt;/figure&gt;
    &lt;/div&gt;
  &lt;/div&gt;
  

  
  
  
  
  &lt;div class=&#34;&#34;&gt;
    &lt;div style=&#34;width: 20%; float: left;padding: 0 .2em .2em 0&#34;&gt;
        &lt;figure style=&#34;margin: 0&#34;&gt;
            &lt;img src=&#34;http://upload.wikimedia.org/wikipedia/en/d/dc/Megadeth-RustInPeace.jpg&#34; style=&#34;margin: 0&#34;
                 alt=&#34;Megadeth - Rust in Peace&#34; /&gt;
            &lt;figcaption&gt;
                &lt;h6&gt;Megadeth - Rust in Peace&lt;/h4&gt;
            &lt;/figcaption&gt;
        &lt;/figure&gt;
    &lt;/div&gt;
  &lt;/div&gt;
  

  
  
  
  
  &lt;div class=&#34;&#34;&gt;
    &lt;div style=&#34;width: 20%; float: left;padding: 0 .2em .2em 0&#34;&gt;
        &lt;figure style=&#34;margin: 0&#34;&gt;
            &lt;img src=&#34;http://upload.wikimedia.org/wikipedia/en/7/72/Exodus_-_Fabulous_Disaster.jpg&#34; style=&#34;margin: 0&#34;
                 alt=&#34;Exodus - Fabulous Disaster&#34; /&gt;
            &lt;figcaption&gt;
                &lt;h6&gt;Exodus - Fabulous Disaster&lt;/h4&gt;
            &lt;/figcaption&gt;
        &lt;/figure&gt;
    &lt;/div&gt;
  &lt;/div&gt;
  

&lt;/div&gt;




</description>
    </item>
    
    <item>
      <title>MonoTouch and F# part II</title>
      <link>http://7sharpnine.com/2013/02/07/2013-02-04-monotouch-and-fsharp-part-ii/</link>
      <pubDate>Thu, 07 Feb 2013 00:00:00 +0000</pubDate>
      
      <guid>http://7sharpnine.com/2013/02/07/2013-02-04-monotouch-and-fsharp-part-ii/</guid>
      <description>

&lt;p&gt;In the last post we left at the point where everything was running fine and dandy on the Simulator.  So what happens if we compile for the real hardware?&lt;/p&gt;

&lt;p&gt;Lets change the active configuration to &lt;code&gt;Debug|iPhone&lt;/code&gt; and hit build, what do we get?&lt;!-- more --&gt;&lt;/p&gt;

&lt;h3 id=&#34;boom&#34;&gt;Boom!&lt;/h3&gt;

&lt;p&gt;&lt;em&gt;Error MT2002: Could not resolve: FSharp.Core, Version=4.3.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a (MT2002) (singleview)&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;So I guess we need to tell it where the FSharp.Core.dll is, lets add a reference to it:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;/Libraries/FrameWorks/Mono.FrameWork/Libraries/mono/Microsoft F#/v4.0/Fsharp.Core.dll
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Now try and build &amp;hellip; another weird error:&lt;/p&gt;

&lt;p&gt;&lt;em&gt;unknown-file(1,1): Error FS2020: The assembly &amp;lsquo;F#/v4.0/FSharp.Core.dll&amp;rsquo; is listed on the command line. Assemblies should be referenced using a command line flag such as &amp;lsquo;-r&amp;rsquo;. (FS2020) (singleview)&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;Hmmm, lets look in the F# compiler source, were going to have to break out the big guns for this one.&lt;/p&gt;

&lt;p&gt;What we need to do is look at the different targets that are available.  I remember seeing different targets when I was nosing through the source files a while ago.  Also if you look at the &lt;code&gt;readme.md&lt;/code&gt; file that comes with the open source compiler:&lt;/p&gt;

&lt;p&gt;You can also build FSharp.Core for: .NET 2.0, Mono 2.1, Silverlight 5.0, Portable Profile47 (net4+sl4+wp71+win8) and XNA 4.0 for Xbox 360 profiles:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;msbuild fsharp-library-build.proj /p:TargetFramework=net20 
msbuild fsharp-library-build.proj /p:TargetFramework=mono21
msbuild fsharp-library-build.proj /p:TargetFramework=portable-net4+sl4+wp71+win8
msbuild fsharp-library-build.proj /p:TargetFramework=sl5
msbuild fsharp-library-build.proj /p:TargetFramework=net40-xna40-xbox360
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;So lets build the &lt;code&gt;mono21&lt;/code&gt; target with &lt;code&gt;xbuild&lt;/code&gt;:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;xbuild fsharp-library-build.proj /p:TargetFramework=mono21
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Now that&amp;rsquo;s build lets reference the output and see what happens:&lt;/p&gt;

&lt;p&gt;Arrgh another error this time relating the the version of the framework that we have compiled against.&lt;/p&gt;

&lt;p&gt;If you read the documentation for &lt;a href=&#34;http://xamarin.com/monotouch&#34;&gt;MonoTouch&lt;/a&gt; in a little more detail you will discover that a different mscorlib is required.  We need to modify this in the build script:&lt;/p&gt;

&lt;p&gt;Open up &lt;code&gt;FSharp.Source.Targets&lt;/code&gt; and find the &lt;code&gt;&amp;lt;PropertyGroup Condition=&amp;quot;&#39;$(TargetFramework)&#39;==&#39;mono21&#39;&amp;quot;&amp;gt;&lt;/code&gt; section, add the following after the &lt;code&gt;&amp;lt;DefineConstants&amp;gt;&lt;/code&gt; elements.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;lt;OtherFlags&amp;gt;$(OtherFlags) --simpleresolution -r:&amp;quot;/Developer/MonoTouch/usr/lib/mono/2.1/mscorlib-runtime.dll&amp;quot;  &amp;lt;/OtherFlags&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Right, fingers crossed&amp;hellip;&lt;/p&gt;

&lt;p&gt;Sigh, another error:&lt;/p&gt;

&lt;p&gt;&lt;em&gt;Error MT2002: Can not resolve reference: System.Reflection.Emit.AssemblyBuilder (MT2002) (singleview)&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;Were getting closer though.&lt;/p&gt;

&lt;p&gt;Lets look at the &lt;code&gt;&amp;lt;DefineConstants/&amp;gt;&lt;/code&gt; that are declared in the build file, if you have a quick look you will notice that there is one called &lt;code&gt;FX_NO_REFLECTION_EMIT&lt;/code&gt; that&amp;rsquo;s what we need so that &lt;code&gt;Reflection.Emit&lt;/code&gt; is not included.  MonoTouch does not support &lt;code&gt;Reflection.Emit&lt;/code&gt; due to the meta data not being available once the code have been compiled with the &lt;a href=&#34;http://www.mono-project.com/AOT&#34;&gt;AOT compiler&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;Lets add that constant to the end of the rest:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;lt;DefineConstants&amp;gt;$(DefineConstants);FX_NO_REFLECTION_EMIT&amp;lt;/DefineConstants&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;If we rebuild &lt;code&gt;Fsharp.Core&lt;/code&gt; again with &lt;code&gt;xbuild&lt;/code&gt; and rebind the reference in our test project&amp;hellip;&lt;/p&gt;

&lt;h3 id=&#34;wow-it-works&#34;&gt;Wow it works!&lt;/h3&gt;

&lt;p&gt;You should now have a working hello world application that can be deployed and run on real hardware.&lt;/p&gt;

&lt;h2 id=&#34;final-words&#34;&gt;Final Words&lt;/h2&gt;

&lt;p&gt;As this is just a documented hackathon I have mainly brain dumped what I remembered doing after the fact, so some steps may be slightly different.  As soon as time permits Ill be adding a couple of project templates to the &lt;a href=&#34;https://github.com/fsharp/fsharpbinding&#34;&gt;FSharpBinding&lt;/a&gt; to allow building F# MonoTouch libraries and applications.&lt;/p&gt;

&lt;p&gt;I also have some ideas for dealing with the UI and tooling with &lt;a href=&#34;https://developer.apple.com/technologies/tools/&#34;&gt;Xcode&lt;/a&gt; but Ill need a little time to investigate to see if it&amp;rsquo;s a viable option&amp;hellip;&lt;/p&gt;

&lt;p&gt;&lt;hr style=&#34;margin: 1em 0&#34;&gt;
&lt;h1 id=&#34;essential-listening&#34;&gt;Essential listening:&lt;/h1&gt;


&lt;div class=&#34;pure-g&#34;&gt;

  
  
  
  
  &lt;div class=&#34;&#34;&gt;
    &lt;div style=&#34;width: 20%; float: left;padding: 0 .2em .2em 0&#34;&gt;
        &lt;figure style=&#34;margin: 0&#34;&gt;
            &lt;img src=&#34;http://upload.wikimedia.org/wikipedia/en/4/44/Soilscars.jpg&#34; style=&#34;margin: 0&#34;
                 alt=&#34;Soil - Scars&#34; /&gt;
            &lt;figcaption&gt;
                &lt;h6&gt;Soil - Scars&lt;/h4&gt;
            &lt;/figcaption&gt;
        &lt;/figure&gt;
    &lt;/div&gt;
  &lt;/div&gt;
  

  
  
  
  
  &lt;div class=&#34;&#34;&gt;
    &lt;div style=&#34;width: 20%; float: left;padding: 0 .2em .2em 0&#34;&gt;
        &lt;figure style=&#34;margin: 0&#34;&gt;
            &lt;img src=&#34;http://upload.wikimedia.org/wikipedia/en/e/e9/AlbinoSlug.jpg&#34; style=&#34;margin: 0&#34;
                 alt=&#34;Buckethead - Albino Slug&#34; /&gt;
            &lt;figcaption&gt;
                &lt;h6&gt;Buckethead - Albino Slug&lt;/h4&gt;
            &lt;/figcaption&gt;
        &lt;/figure&gt;
    &lt;/div&gt;
  &lt;/div&gt;
  

&lt;/div&gt;



&lt;br /&gt;
Until next time!&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>MonoTouch and F# part I</title>
      <link>http://7sharpnine.com/2013/02/03/2013-02-03-monotouch-and-fsharp-part-i/</link>
      <pubDate>Sun, 03 Feb 2013 00:00:00 +0000</pubDate>
      
      <guid>http://7sharpnine.com/2013/02/03/2013-02-03-monotouch-and-fsharp-part-i/</guid>
      <description>

&lt;p&gt;&lt;a href=&#34;http://xamarin.com/monotouch&#34;&gt;MonoTouch&lt;/a&gt; and F# that would be a cool duo right?&lt;/p&gt;

&lt;p&gt;Well let me explain what needs to be done and why to get this pair working together.&lt;/p&gt;

&lt;p&gt;I heard rumours a while ago that F# and &lt;a href=&#34;http://xamarin.com/monotouch&#34;&gt;MonoTouch&lt;/a&gt; would not play together nicely because of &lt;a href=&#34;http://docs.xamarin.com/ios/about/limitations&#34;&gt;limitations&lt;/a&gt; in the ahead of time compilation &lt;a href=&#34;http://www.mono-project.com/AOT&#34;&gt;(AOT)&lt;/a&gt;.  So I thought I would either prove or disprove this with some concentrated hacking.  How hard can it be?&lt;/p&gt;

&lt;p&gt;As my good friend and colleague Dr. Kewin would quote:&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;“No problem can withstand the assault of sustained thinking.”—Voltaire&lt;!-- more --&gt;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h2 id=&#34;prerequisites&#34;&gt;Prerequisites&lt;/h2&gt;

&lt;p&gt;These are the same as MonoTouch, I&amp;rsquo;m using a Mac and MonoDevelop at the moment.  You would need a Mac anyway to be able to do the compile and deploy to an iOS device.  &lt;a href=&#34;https://developer.apple.com/technologies/tools/&#34;&gt;Xcode&lt;/a&gt; with an Apple profile and certificates are required for code signing etc.&lt;/p&gt;

&lt;h2 id=&#34;first-steps&#34;&gt;First steps&lt;/h2&gt;

&lt;p&gt;So how do we tackle this?&lt;/p&gt;

&lt;p&gt;First lets look at the &lt;strong&gt;C# Single View&lt;/strong&gt; MonoTouch project file (&lt;code&gt;.csproj&lt;/code&gt;) up to the end of the first PropertyGroup:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;lt;?xml version=&amp;quot;1.0&amp;quot; encoding=&amp;quot;utf-8&amp;quot;?&amp;gt;
&amp;lt;Project DefaultTargets=&amp;quot;Build&amp;quot; ToolsVersion=&amp;quot;4.0&amp;quot; xmlns=&amp;quot;http://schemas.microsoft.com/developer/msbuild/2003&amp;quot;&amp;gt;
  &amp;lt;PropertyGroup&amp;gt;
    &amp;lt;Configuration Condition=&amp;quot; &#39;$(Configuration)&#39; == &#39;&#39; &amp;quot;&amp;gt;Debug&amp;lt;/Configuration&amp;gt;
    &amp;lt;Platform Condition=&amp;quot; &#39;$(Platform)&#39; == &#39;&#39; &amp;quot;&amp;gt;iPhoneSimulator&amp;lt;/Platform&amp;gt;
    &amp;lt;ProductVersion&amp;gt;10.0.0&amp;lt;/ProductVersion&amp;gt;
    &amp;lt;SchemaVersion&amp;gt;2.0&amp;lt;/SchemaVersion&amp;gt;
    &amp;lt;ProjectGuid&amp;gt;{822346B5-6805-42FD-9B6A-65446A688E63}&amp;lt;/ProjectGuid&amp;gt;
    &amp;lt;ProjectTypeGuids&amp;gt;{6BC8ED88-2882-458C-8E55-DFD12B67127B};
                      {FAE04EC0-301F-11D3-BF4B-00C04F79EFBC}&amp;lt;/ProjectTypeGuids&amp;gt;
    &amp;lt;OutputType&amp;gt;Exe&amp;lt;/OutputType&amp;gt;
    &amp;lt;RootNamespace&amp;gt;HelloWorld&amp;lt;/RootNamespace&amp;gt;
    &amp;lt;AssemblyName&amp;gt;HelloWorld&amp;lt;/AssemblyName&amp;gt;
  &amp;lt;/PropertyGroup&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The bits we are interested in are the &lt;strong&gt;ProjectTypeGuids&lt;/strong&gt;.  Visual Studio/MonoDevelop projects use these guid&amp;rsquo;s to identify the type of the project.  If you do a bit of Googling &lt;em&gt;(or Binging&amp;hellip;)&lt;/em&gt; you would find that:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;6BC8ED88-2882-458C-8E55-DFD12B67127B&lt;/strong&gt;  is a MonoTouch project type guid&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;FAE04EC0-301F-11D3-BF4B-00C04F79EFBC&lt;/strong&gt;  is a C# project type guid&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;The F# project type guid is &lt;strong&gt;F2A71F9B-5D33-465A-A702-920D77279786&lt;/strong&gt;.  We can now replace &lt;strong&gt;FAE04EC0-301F-11D3-BF4B-00C04F79EFBC&lt;/strong&gt; with the F# one.  For a comprehensive list of project type guid&amp;rsquo;s have a look at &lt;a href=&#34;http://workblog.pilin.name/2012/11/visual-studio-project-type-guids.html&#34;&gt;Mikhail Pilin&amp;rsquo;s blog&lt;/a&gt;.  Next scroll down to the bottom of the project file and update the  &lt;Import Project=&#34;$(MSBuildBinPath)\Microsoft.CSharp.targets&#34; /&gt; to &lt;Import Project=&#34;$(MSBuildExtensionsPath32)\..\Microsoft F#\v4.0\Microsoft.FSharp.Targets&#34; /&gt;.  the final step on the project file is to change the project file extension from &lt;code&gt;.csproj&lt;/code&gt; to &lt;code&gt;.fsproj&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;The last of the tweaking is to open up the &lt;code&gt;.sln&lt;/code&gt; file and make a slight change to that too:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;Microsoft Visual Studio Solution File, Format Version 11.00
# Visual Studio 2010
Project(&amp;quot;{FAE04EC0-301F-11D3-BF4B-00C04F79EFBC}&amp;quot;) = &amp;quot;singleview&amp;quot;, &amp;quot;singleview\singleview.fsproj&amp;quot;, &amp;quot;{4465399C-4EE8-4F60-AD9A-EB9AEDD1C5BF}&amp;quot;
EndProject
Global
...snip...
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Modify the  Project sections Guid &lt;strong&gt;FAE04EC0-301F-11D3-BF4B-00C04F79EFBC&lt;/strong&gt; to the F# project type Guid &lt;strong&gt;4925A630-B079-445d-BCD4-3A9C94FE9307&lt;/strong&gt;.  If you forget this step then MonoDevelop will get really confused and try to compile the F# project with the C# compiler.&lt;/p&gt;

&lt;h2 id=&#34;code-changes&#34;&gt;Code Changes&lt;/h2&gt;

&lt;p&gt;For the sake of simplicity I&amp;rsquo;m going to port the C# code verbatim showing the C# code first then the F# code.  The easiest way would probably be to change all the  C# files to have the &lt;code&gt;.fs&lt;/code&gt; extension and edit them in place, remembering to also update the entries in the &lt;code&gt;.fsproj&lt;/code&gt; file too this only takes a second to do.&lt;/p&gt;

&lt;p&gt;I know what you are going to say: &amp;ldquo;Why didn&amp;rsquo;t you just create a nice project template for us all to use?&amp;rdquo;&lt;/p&gt;

&lt;p&gt;I am, I am, patience!&lt;/p&gt;

&lt;p&gt;A number of people wanted to know what I did to get things going so this is my documented &amp;lsquo;hack-a-thon&amp;rsquo; if you like.  The project template will be along shortly.  Lets move along to the code changes.&lt;/p&gt;

&lt;h2 id=&#34;viewcontroller&#34;&gt;ViewController&lt;/h2&gt;

&lt;pre&gt;&lt;code&gt;using System;
using System.Drawing;
using MonoTouch.Foundation;
using MonoTouch.UIKit;

namespace singleview
{
	public partial class singleviewViewController : UIViewController
	{
		public singleviewViewController () : base (&amp;quot;singleviewViewController&amp;quot;, null)
		{
		}
		
		public override void DidReceiveMemoryWarning ()
		{
			// Releases the view if it doesn&#39;t have a superview.
			base.DidReceiveMemoryWarning ();
			// Release any cached data, images, etc that aren&#39;t in use.
		}
		
		public override void ViewDidLoad ()
		{
			base.ViewDidLoad ();
			// Perform any additional setup after loading the view, typically from a nib.
		}
		
		public override void ViewDidUnload ()
		{
			base.ViewDidUnload ();
			// Clear any references to subviews of the main view in order to
			// allow the Garbage Collector to collect them sooner.
			// e.g. myOutlet.Dispose (); myOutlet = null;
			ReleaseDesignerOutlets ();
		}
		
		public override bool ShouldAutorotateToInterfaceOrientation (UIInterfaceOrientation toInterfaceOrientation)
		{
			// Return true for supported orientations
			return (toInterfaceOrientation != UIInterfaceOrientation.PortraitUpsideDown);
		}
	}
}

// This file has been generated automatically by MonoDevelop to store outlets and
// actions made in the Xcode designer. If it is removed, they will be lost.
// Manual changes to this file may not be handled correctly.
using MonoTouch.Foundation;

namespace singleview
{
	[Register (&amp;quot;singleviewViewController&amp;quot;)]
	partial class singleviewViewController
	{
		void ReleaseDesignerOutlets ()
		{
		}
	}
}
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&#34;language-fsharp&#34;&gt;namespace Singleview

open System
open System.Drawing
open MonoTouch.Foundation
open MonoTouch.UIKit

[&amp;lt;Register (&amp;quot;singleviewViewController&amp;quot;)&amp;gt;]
type singleviewViewController() =
    inherit UIViewController(&amp;quot;singleviewViewController&amp;quot;, null)
        
    let ReleaseDesignerOutlets() = ( (* No outlets to release  *))

    override x.DidReceiveMemoryWarning() =
    // Releases the view if it doesn&#39;t have a superview.
        base.DidReceiveMemoryWarning();
        // Release any cached data, images, etc that aren&#39;t in use.

    override x.ViewDidLoad() =
        base.ViewDidLoad()
        // Perform any additional setup after loading the view, typically from a nib.

    override x.ViewDidUnload() =
        base.ViewDidUnload()
        // Clear any references to subviews of the main view in order to
        // allow the Garbage Collector to collect them sooner.
        // e.g. myOutlet.Dispose (); myOutlet = null;
        ReleaseDesignerOutlets()

    override x.ShouldAutorotateToInterfaceOrientation(toInterfaceOrientation) =
        // Return true for supported orientations
        toInterfaceOrientation &amp;lt;&amp;gt; UIInterfaceOrientation.PortraitUpsideDown
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;On looking at this section you will notice that there is no partial class in the F# version, that&amp;rsquo;s because F# doesn&amp;rsquo;t have any notion of partial classes.  In this simple project we don&amp;rsquo;t actually have any interaction with the UI so designer interaction is a moot point at the moment.&lt;/p&gt;

&lt;p&gt;The &lt;code&gt;.fsproj&lt;/code&gt; file still needs to be edited to remove the nested partial class that is present in the C# version:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;   &amp;lt;Compile Include=&amp;quot;singleviewViewController.designer.cs&amp;quot;&amp;gt;
      &amp;lt;DependentUpon&amp;gt;singleviewViewController.cs&amp;lt;/DependentUpon&amp;gt;
    &amp;lt;/Compile&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Simply remove the &lt;code&gt;DependUpon&lt;/code&gt; element and just use the name &lt;code&gt;singleviewViewController.fs&lt;/code&gt;:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;lt;Compile&amp;gt;singleviewViewController.fs/&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The lack of partial classes in F# makes the tooling available for UI designer a pain to integrate tightly into F# without a bit of work work &lt;em&gt;(I have some ideas on that that I&amp;rsquo;m currently experimenting with that Ill return to after finishing this article)&lt;/em&gt;.  Currently MonoTouch uses the Xcodes interface designer to build the UI which is stored in a xib file.  This is simply a file describing the user interface and its interaction points.  The Properties of the UI are called &lt;code&gt;Outlets&lt;/code&gt; and events spawned from the UI are called &lt;code&gt;Actions&lt;/code&gt;.&lt;/p&gt;

&lt;h2 id=&#34;appdelegate&#34;&gt;AppDelegate&lt;/h2&gt;

&lt;pre&gt;&lt;code&gt;using System;
using System.Collections.Generic;
using System.Linq;
using MonoTouch.Foundation;
using MonoTouch.UIKit;

namespace singleview
{
	// The UIApplicationDelegate for the application. This class is responsible for launching the 
	// User Interface of the application, as well as listening (and optionally responding) to 
	// application events from iOS.
	[Register (&amp;quot;AppDelegate&amp;quot;)]
	public partial class AppDelegate : UIApplicationDelegate
	{
		// class-level declarations
		UIWindow window;
		singleviewViewController viewController;

		// This method is invoked when the application has loaded and is ready to run. In this 
		// method you should instantiate the window, load the UI into it and then make the window visible.
		// You have 17 seconds to return from this method, or iOS will terminate your application.
		public override bool FinishedLaunching (UIApplication app, NSDictionary options)
		{
			window = new UIWindow (UIScreen.MainScreen.Bounds);
			
			viewController = new singleviewViewController ();
			window.RootViewController = viewController;
			window.MakeKeyAndVisible ();
			
			return true;
		}
	}
}
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&#34;language-fsharp&#34;&gt;namespace Singleview
open System
open System.Collections.Generic
open MonoTouch.Foundation
open MonoTouch.UIKit

// The UIApplicationDelegate for the application. This class is responsible for launching the 
// User Interface of the application, as well as listening (and optionally responding) to application events from iOS.
[&amp;lt;Register (&amp;quot;AppDelegate&amp;quot;)&amp;gt;]
type AppDelegate() =
    inherit UIApplicationDelegate()
    
    let mutable window = Unchecked.defaultof&amp;lt;_&amp;gt;
    let mutable viewController = Unchecked.defaultof&amp;lt;_&amp;gt;

    // This method is invoked when the application has loaded and is ready to run. In this 
    // method you should instantiate the window, load the UI into it and then make the window visible.
    // You have 17 seconds to return from this method, or iOS will terminate your application.
    override x.FinishedLaunching ( app: UIApplication,  options: NSDictionary) =
        window &amp;lt;- new UIWindow(UIScreen.MainScreen.Bounds)
        viewController &amp;lt;- new singleviewViewController()
        window.RootViewController &amp;lt;- viewController
        window.MakeKeyAndVisible()
        true
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The code is pretty similar between the two implementations, with the F# version omitting the type annotations, semicolons and curly braces.  The other area to notice is that the &lt;code&gt;mutable&lt;/code&gt; variable declarations for the &lt;code&gt;window&lt;/code&gt; and &lt;code&gt;viewController&lt;/code&gt; bindings.  The C# implementation defaults to mutable variables whereas F# defaults to the safer immutable ones.&lt;/p&gt;

&lt;h2 id=&#34;program-main&#34;&gt;Program/main&lt;/h2&gt;

&lt;pre&gt;&lt;code&gt;using System;
using System.Collections.Generic;
using System.Linq;
using MonoTouch.Foundation;
using MonoTouch.UIKit;

namespace singleview
{
	public class Application
	{
		// This is the main entry point of the application.
		static void Main (string[] args)
		{
			// if you want to use a different Application Delegate class from &amp;quot;AppDelegate&amp;quot;
			// you can specify it here.
			UIApplication.Main (args, null, &amp;quot;AppDelegate&amp;quot;);
		}
	}
}
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&#34;language-fsharp&#34;&gt;module main
open System
open System.Collections.Generic
open MonoTouch.Foundation
open MonoTouch.UIKit

    [&amp;lt;EntryPoint&amp;gt;]
    let main( args) = 
        UIApplication.Main (args, null, &amp;quot;AppDelegate&amp;quot;)
        0
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The main thing you will notice is that the F# code is terser, again dropping the type annotations, semicolons and curly braces.  Oh, I also called the entry point main.  To be precise it&amp;rsquo;s a function called main in a module named main, there&amp;rsquo;s no need to create a class or type for this.&lt;/p&gt;

&lt;h2 id=&#34;the-xib-file&#34;&gt;The Xib file&lt;/h2&gt;

&lt;p&gt;In C# MonoToch projects the &lt;code&gt;xib&lt;/code&gt; file is compiled and embedded for you as part of the build process, unfortunately this is not currently possible in F# so we have to do it manually.  In an ideal world this would all be done by the F# project at build time and this is something that I&amp;rsquo;m working on too.  In the mean time we have to do it manually so open up your trusty friend the &lt;code&gt;Terminal&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;I&amp;rsquo;m going to split the command line into separate parts due to its size:&lt;/p&gt;

&lt;p&gt;First of all we invoke the &lt;code&gt;ibtool&lt;/code&gt;:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;/Applications/Xcode.app/Contents/Developer/usr/bin/ibtool --errors --warnings --notices --output-format human-readable-text --compile
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Followed by name of the &lt;code&gt;.nib&lt;/code&gt; file you want to compile to:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;quot;/yourPath/singleviewViewController.nib&amp;quot;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The path of the &lt;code&gt;.xib&lt;/code&gt; you want to compile from:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;quot;/yourPath/singleviewViewController.xib&amp;quot;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Finally the sdk that you want to use for compilation, in this instance it is The iPhoneSimulator6.0.sdk as we are targetting the simulator:
    &amp;ndash;sdk &amp;ldquo;/Applications/Xcode.app/Contents/Developer/Platforms/iPhoneSimulator.platform/Developer/SDKs/iPhoneSimulator6.0.sdk&amp;rdquo;&lt;/p&gt;

&lt;p&gt;Once you have compiled to a &lt;code&gt;.nib&lt;/code&gt; file include it in the project, set the build action to &lt;code&gt;Content&lt;/code&gt;.  You can still include the &lt;code&gt;.xib&lt;/code&gt; version within the project if you want but you would have to set the build action to &lt;code&gt;None&lt;/code&gt;.  Currently the F# binding does not support the build action of &lt;code&gt;Interface Definition&lt;/code&gt; if it did then we probably wouldn&amp;rsquo;t have to go through the manual compilation process either.&lt;/p&gt;

&lt;p&gt;That ought to do it, everything should now work on the simulator.  If you try to compile to a real phone then everything will quickly come grinding to a halt but Ill explain all of that next time and how to resolve it too.&lt;/p&gt;

&lt;p&gt;Until next time!&lt;/p&gt;

&lt;hr style=&#34;margin: 1em 0&#34;&gt;
&lt;h1 id=&#34;essential-listening&#34;&gt;Essential listening:&lt;/h1&gt;


&lt;div class=&#34;pure-g&#34;&gt;

  
  
  
  
  &lt;div class=&#34;&#34;&gt;
    &lt;div style=&#34;width: 20%; float: left;padding: 0 .2em .2em 0&#34;&gt;
        &lt;figure style=&#34;margin: 0&#34;&gt;
            &lt;img src=&#34;http://upload.wikimedia.org/wikipedia/en/5/5f/MegadethThirteen.jpg&#34; style=&#34;margin: 0&#34;
                 alt=&#34;Megadeth - TH1RT3EN&#34; /&gt;
            &lt;figcaption&gt;
                &lt;h6&gt;Megadeth - TH1RT3EN&lt;/h4&gt;
            &lt;/figcaption&gt;
        &lt;/figure&gt;
    &lt;/div&gt;
  &lt;/div&gt;
  

  
  
  
  
  &lt;div class=&#34;&#34;&gt;
    &lt;div style=&#34;width: 20%; float: left;padding: 0 .2em .2em 0&#34;&gt;
        &lt;figure style=&#34;margin: 0&#34;&gt;
            &lt;img src=&#34;http://upload.wikimedia.org/wikipedia/en/7/7a/Worship_Music.jpg&#34; style=&#34;margin: 0&#34;
                 alt=&#34;Anthrax - Worship Music&#34; /&gt;
            &lt;figcaption&gt;
                &lt;h6&gt;Anthrax - Worship Music&lt;/h4&gt;
            &lt;/figcaption&gt;
        &lt;/figure&gt;
    &lt;/div&gt;
  &lt;/div&gt;
  

&lt;/div&gt;




</description>
    </item>
    
    <item>
      <title>MonoGame subdivision and platonics</title>
      <link>http://7sharpnine.com/2013/01/04/2013-01-04-monogame-subdivision-and-platonics/</link>
      <pubDate>Fri, 04 Jan 2013 00:00:00 +0000</pubDate>
      
      <guid>http://7sharpnine.com/2013/01/04/2013-01-04-monogame-subdivision-and-platonics/</guid>
      <description>

&lt;p&gt;I&amp;rsquo;ve been on a bit of a break from my normal jovial self due to a shit storm of bad stuff happening that I wont go into here, but hopefully this years going to be awesome.  Anyway, here&amp;rsquo;s the next exciting installment in my series on MonoGame.   &lt;em&gt;(Well I find it exciting anyway :-) )&lt;/em&gt;&lt;br /&gt;
&lt;!-- more --&gt;
If you remember back to the &lt;a href=&#34;https://github.com/7sharp9/PlatonicSolids&#34;&gt;last post&lt;/a&gt; I mentioned the &lt;a href=&#34;http://en.wikipedia.org/wiki/Platonic_solid&#34;&gt;platonic solids&lt;/a&gt;, and we created and rendered the tetrahedron, lets recap on what the five solids are:&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;Tetrahedron (four faces)&lt;/li&gt;
&lt;li&gt;Cube or hexahedron (six faces)&lt;/li&gt;
&lt;li&gt;Octahedron (eight faces)&lt;/li&gt;
&lt;li&gt;Dodecahedron (twelve faces)&lt;/li&gt;
&lt;li&gt;Icosahedron (twenty faces)&lt;br /&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;We covered the tetrahedron in the &lt;a href=&#34;https://github.com/7sharp9/PlatonicSolids&#34;&gt;previous post&lt;/a&gt; and the hexahedron is pretty humdrum so I&amp;rsquo;m not going to cover that here so lets move onto the next one the octahedron.&lt;/p&gt;

&lt;h2 id=&#34;creating-the-octahedron&#34;&gt;Creating the Octahedron&lt;/h2&gt;

&lt;p&gt;Here&amp;rsquo;s a function that we will use to generate an octahedron:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-fsharp&#34;&gt;module Platonic
  let createOctahedron()=    
      let top = Vector3.Up
      let midOne =   top |&amp;gt; Vector3.transform (Matrix.CreateRotationX(toRad 90.0f) * Matrix.CreateRotationY(toRad 45.f))
      let midTwo =   top |&amp;gt; Vector3.transform (Matrix.CreateRotationX(toRad 90.0f) * Matrix.CreateRotationY(toRad 135.f))
      let midThree = top |&amp;gt; Vector3.transform (Matrix.CreateRotationX(toRad 90.0f) * Matrix.CreateRotationY(toRad 225.f))
      let midFour =  top |&amp;gt; Vector3.transform (Matrix.CreateRotationX(toRad 90.0f) * Matrix.CreateRotationY(toRad 315.f))
      let bottom =   top |&amp;gt; Vector3.transform (Matrix.CreateRotationX(toRad 180.f))
      
      [| midOne; top;  midTwo
         midTwo; top; midThree
         midThree; top; midFour
         midFour;  top; midOne 
         midOne; midTwo; bottom
         midTwo; midThree; bottom
         midThree; midFour; bottom
         midFour; midOne; bottom |]
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;You can see that the bulk of the code is centred around rotating a Y axis &lt;a href=&#34;http://en.wikipedia.org/wiki/Unit_vector&#34;&gt;unit vector&lt;/a&gt; &lt;code&gt;top&lt;/code&gt; around the X and Y axis.  All the vertices around the centre od the octahedron lie on the same plain and are simply rotated by 90 degrees in the X axis and then rotated by multiples of 90 degrees in the Y axis starting at 45 degrees (45, 135, 225, 315).  Finally the the &lt;code&gt;top&lt;/code&gt; unit vector is flipped to the bottom by rotating around 180 degrees in the X axis, this forms the bottom point.  The final step consists of combining the vertices into an array with the array syntax &lt;code&gt;[| ... |]&lt;/code&gt; specifing each triangle of the octahedron in turn.&lt;/p&gt;

&lt;p&gt;If you were looking carefully you might have noticed that the &lt;code&gt;Vector3.transform&lt;/code&gt; function is not part of the MonoGame library.  I wrapped MonoGames&amp;rsquo;s &lt;code&gt;Vector3.Transform&lt;/code&gt; function so that the &lt;code&gt;Vector3&lt;/code&gt; is the last parameter so we can use the forward pipeline operator &lt;code&gt;|&amp;gt;&lt;/code&gt;:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-fsharp&#34;&gt;module Vector3 =
    let transform (m:Matrix) v = 
        Vector3.Transform(v, m)
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;drawing-the-octahedron&#34;&gt;Drawing the Octahedron&lt;/h2&gt;

&lt;p&gt;What now?  Well, with this code we have just been working with the raw vertices, we now need to get this into a form that &lt;a href=&#34;http://monogame.codeplex.com&#34;&gt;MonoGame&lt;/a&gt; can render, namely an array of the &lt;code&gt;VertexPositionColor&lt;/code&gt; structure.  It&amp;rsquo;s a bit of a mouthful so lets alias this so we can simply refer to it as &lt;code&gt;vpc&lt;/code&gt;:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-fsharp&#34;&gt;let vpc v c = VertexPositionColor(v, c)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;To render the octahedron we can now modify the draw method of the tetrahedron code from the &lt;a href=&#34;https://github.com/7sharp9/PlatonicSolids&#34;&gt;last post&lt;/a&gt; maybe something like this should illustrate:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-fsharp&#34;&gt;override x.Draw (gameTime) =
  // Clear the backbuffer
  x.GraphicsDevice.Clear (Color.CornflowerBlue)
  for pass in basicEffect.CurrentTechnique.Passes do
      pass.Apply()
      let octahedron = 
          Platonic.createOctahedron() 
          |&amp;gt; Array.mapi (fun i -&amp;gt; Platonic.vpc (if i % 2 = 0 then Color.BlueViolet
                                                else Color.Orange) )
      x.GraphicsDevice.DrawUserPrimitives(PrimitiveType.TriangleList, octahedron, 0, octahedron.Length / 3)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Bear in mind we are not looking at optimisation at all at this stage purely visualising what we have.  We are using the &lt;code&gt;mapi&lt;/code&gt; function to alternate between defining blue violet and orange vertex colours.  At the moment because we haven&amp;rsquo;t set up any lights the octahedron would just appear as diamond chunk of colour with no shading, with these two simple vertex colours we can see the separate facets and see the 3D form.&lt;/p&gt;


&lt;figure &gt;
    
        &lt;img src=&#34;https://lh6.googleusercontent.com/-v5uELxAJljU/UOS6FEGjzYI/AAAAAAAABkY/WIxT8AYFUpY/s640/octahedron.png&#34; /&gt;
    
    
&lt;/figure&gt;


&lt;h2 id=&#34;subdivision-surfaces&#34;&gt;Subdivision Surfaces&lt;/h2&gt;

&lt;p&gt;According to &lt;a href=&#34;http://en.wikipedia.org/wiki/Subdivision_surface&#34;&gt;Wikipedia&lt;/a&gt;:&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;A subdivision surface, in the field of 3D computer graphics, is a method of representing a smooth surface via the specification of a coarser piecewise linear polygon mesh. The smooth surface can be calculated from the coarse mesh as the limit of a recursive process of subdividing each polygonal face into smaller faces that better approximate the smooth surface.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;They are also known as scalable geometry.  I&amp;rsquo;m not going to get into the realm of true sub-divisional modelling such as providing a visible control surface with editing and crease support, I just wouldn&amp;rsquo;t be able to do it justice within the scope of this introductory series.  Applications like &lt;a href=&#34;http://usa.autodesk.com/adsk/servlet/pc/index?id=13571168&amp;amp;siteID=123112&#34;&gt;Softimage&lt;/a&gt; or &lt;a href=&#34;http://usa.autodesk.com/maya/&#34;&gt;Maya&lt;/a&gt; are masters of sub-divisional modelling, you might want to check those out if you are interested in what can be done in that area.  Subdivision surfaces have been quite popular in the computer graphics industry as it allows modellers and animators to work with simple mesh surfaces with far less control points that can be rendered with super smooth detail but without the constraints of having to work with millions of points on the screen at once which can be computationally very expensive and distracting.  Nowadays that kind of processing is done by a &lt;a href=&#34;http://en.wikipedia.org/wiki/Graphics_processing_unit&#34;&gt;GPU&amp;rsquo;s&lt;/a&gt; &lt;a href=&#34;http://en.wikipedia.org/wiki/Shader#Vertex_shaders&#34;&gt;vertex shader&amp;rsquo;s&lt;/a&gt; or more recently the &lt;a href=&#34;http://en.wikipedia.org/wiki/Shader#Geometry_shaders&#34;&gt;geometry shader&amp;rsquo;s&lt;/a&gt; which can take a simple triangle as an input and produce zero or more triangles as its output.&lt;/p&gt;

&lt;p&gt;One of the properties of platonic solids is that all of the defining vertices lie on a sphere.  If we were to take each of the defining faces or triangles and recursively divide them into four smaller triangles, and project each of the containing vertices onto the sphere then eventually we would get an approximation of a sphere.  This was the basis of Charles Loop&amp;rsquo;s thesis &lt;a href=&#34;http://research.microsoft.com/~cloop/thesis.pdf&#34;&gt;Smooth Subdivision Surfaces Based on Triangles&lt;/a&gt;.  What I am going to present here will not go into that level of detail and we will not be generating any control surfaces to act on the subdivision mesh.  We could call this a poor man&amp;rsquo;s subdivision surface or sphere approximation :-).&lt;/p&gt;

&lt;p&gt;Lets create a quick and dirty function to try this out anyway:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-fsharp&#34;&gt;let rec subdivide(v1, v2, v3, depth) =
  seq{match depth with
      | 0 -&amp;gt; yield vpc Color.LightBlue (v1 |&amp;gt; Vector3.Normalize) 
             yield vpc Color.AliceBlue (v2 |&amp;gt; Vector3.Normalize) 
             yield vpc Color.SlateGray (v3 |&amp;gt; Vector3.Normalize) 
             
      | _ -&amp;gt; let u12 = ((v1 + v2) / 2.0f) |&amp;gt; Vector3.Normalize
             let u23 = ((v2 + v3) / 2.0f) |&amp;gt; Vector3.Normalize
             let u31 = ((v3 + v1) / 2.0f) |&amp;gt; Vector3.Normalize

             yield! subdivide(v1, u12, u31, depth-1)
             yield! subdivide(v2, u23, u12, depth-1)
             yield! subdivide(v3, u31, u23, depth-1)
             yield! subdivide(u12, u23, u31, depth-1) }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Here we have a recursive function that takes three vertices &lt;code&gt;v1, v2, v3&lt;/code&gt; and a depth parameter.   When the depth parameter is zero we are at our subdivision maximum and we return a normalized triangle.  Incidentally for the same lighting issues mentioned above we use three different colours for the vertices: light blue, alice blue, and slate grey.  The three vertices &lt;code&gt;u12, u23, u31&lt;/code&gt; define the points in-between the input triangle, we calculate them by adding the vertices together and dividing them by two &lt;code&gt;((v1 + v2) / 2.0f)&lt;/code&gt; then pipe-lining the result to the normalize function (&lt;code&gt;|&amp;gt; Vector3.Normalize&lt;/code&gt;).  We do this for each of the points.  The final step is the &lt;code&gt;yield!&lt;/code&gt; section which creates the next level of subdivision for each of the resulting four triangles.  Remember our input triangle is divided into four.  If fact in the previous article there are several images of this:&lt;/p&gt;

&lt;p&gt;
&lt;figure class=&#34;third&#34;&gt;
    
        &lt;img src=&#34;https://lh4.googleusercontent.com/-NpV1nz3K-kI/ULKY-KY6emI/AAAAAAAABio/565nXCNC9xY/s425/texture&amp;#43;coords.png&#34; alt=&#34;Tetrahedron-coordinates&#34; /&gt;
    
    
    &lt;figcaption&gt;
        &lt;p&gt;
        Tetrahedron-coordinates
        
            
        
        &lt;/p&gt; 
    &lt;/figcaption&gt;
    
&lt;/figure&gt;


&lt;figure class=&#34;third&#34;&gt;
    
        &lt;img src=&#34;https://lh4.googleusercontent.com/-hLyy6qGXjWc/ULKn_4p-CUI/AAAAAAAABjA/azvh8cUNrAY/s310/Tetrahedron.png&#34; alt=&#34;Tetrahedron&#34; /&gt;
    
    
    &lt;figcaption&gt;
        &lt;p&gt;
        Tetrahedron
        
            
        
        &lt;/p&gt; 
    &lt;/figcaption&gt;
    
&lt;/figure&gt;
&lt;/p&gt;

&lt;p&gt;The &lt;a href=&#34;http://en.wikipedia.org/wiki/Sierpinski_triangle&#34;&gt;Sierpinski triangle&lt;/a&gt; (&lt;em&gt;without the holes&lt;/em&gt;) is actually our subdivision method, except the we subdivide every triangle produced.&lt;/p&gt;

&lt;p&gt;To try this out lets change the &lt;code&gt;Draw&lt;/code&gt; method so that it looks like this:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-fsharp&#34;&gt;override x.Draw (gameTime) =
    x.GraphicsDevice.Clear (Color.CornflowerBlue)
    for pass in basicEffect.CurrentTechnique.Passes do
        pass.Apply()
        let subdiv = Platonic.createOctahedron() 
                     |&amp;gt; Seq.windowed 3
                     |&amp;gt; Seq.map (function 
                                 | [|a;b;c|] -&amp;gt; subdivide(a,b,c, 3)         
                                 | _ -&amp;gt; failwith &amp;quot;Unsupported array size.&amp;quot; )                 
                     |&amp;gt; Seq.concat 
                     |&amp;gt; Seq.toArray                                                                         
        x.GraphicsDevice.DrawUserPrimitives(PrimitiveType.TriangleList, subdiv, 0, subdiv.Length / 3)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Here we are using some of the functions from the sequence module to group and process the vertices.&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;First the result of &lt;code&gt;Platonic.createOctahedron()&lt;/code&gt; is grouped into triangles using &lt;code&gt;Seq.windowed 3&lt;/code&gt;.&lt;/li&gt;
&lt;li&gt;Now we map each the triangle using the using the &lt;code&gt;subdivide&lt;/code&gt; function.&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;Next we merge the sequence back together using &lt;code&gt;Seq.concat&lt;/code&gt;.&lt;/li&gt;
&lt;li&gt;Finally we convert the sequence back into an array with &lt;code&gt;Seq.toArray&lt;/code&gt;.&lt;br /&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;The image below shows the octahedron at various levels of subdivision from one through to four:

&lt;figure &gt;
    
        &lt;img src=&#34;https://lh3.googleusercontent.com/-oHWbg56xaXA/UOYSZVvgsZI/AAAAAAAABks/mCbZMz8Fy38/s739/subdivisions.png&#34; /&gt;
    
    
&lt;/figure&gt;
&lt;/p&gt;

&lt;p&gt;Well I hope you enjoyed this brief sojourn into subdivision, if you want to investigate further I recommend looking at the following papers.&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;http://www.cs.berkeley.edu/~sequin/CS284/PAPERS/CatmullClark_SDSurf.pdf&#34;&gt;Recursively generated B-spline surfaces on arbitrary topological meshes&lt;/a&gt;&lt;br /&gt;
&lt;a href=&#34;http://research.microsoft.com/~cloop/thesis.pdf&#34;&gt;Smooth Subdivision Surfaces Based on Triangles&lt;/a&gt;&lt;br /&gt;
&lt;a href=&#34;http://www.dgp.toronto.edu/people/stam/reality/Research/pdf/loop.pdf&#34;&gt;Evaluation of Loop Subdivision Surfaces&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;It&amp;rsquo;s a very interesting area and I dont think will be able to resist doing another article delving deaper later on.&lt;/p&gt;

&lt;p&gt;Until next time&amp;hellip;&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>MonoGame 3D basics</title>
      <link>http://7sharpnine.com/2012/11/25/2012-11-25-monogame-3d-basics/</link>
      <pubDate>Sun, 25 Nov 2012 00:00:00 +0000</pubDate>
      
      <guid>http://7sharpnine.com/2012/11/25/2012-11-25-monogame-3d-basics/</guid>
      <description>

&lt;p&gt;This time we are going to get into a little bit of code and produce the simplest of all 3d solids, the
tetrahedron.  I know its not the most exciting of things but we have to start somewhere.  The scope of 3D
graphics in computers is so vast that its very easy to get lost in the vast piles of research papers.&lt;!-- more --&gt;&lt;/p&gt;

&lt;p&gt;First lets do some basic setup, if you followed my last post then you will will have a project template to use, this
makes this a little easier.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;For those of you that are running on Windows and want to use Visual Studio please leave a comment if you would like
a project template for F#&lt;/strong&gt;.  The beauty of MonoGame is that it is cross platform and there is only a small amount of code
that differers between the different platforms, and that is localised to the main entry point rather than the &lt;code&gt;Game&lt;/code&gt; type.&lt;/p&gt;

&lt;p&gt;First create a new &lt;code&gt;MonoGame Mac Application project&lt;/code&gt;, you should end up with a Game1 type that looks like this:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-fsharp&#34;&gt;type MonoGame3DBasics() as x =
    inherit Game()
    let graphics = new GraphicsDeviceManager(x)
    let mutable spriteBatch = Unchecked.defaultof&amp;lt;_&amp;gt;
    let mutable logoTexture = Unchecked.defaultof&amp;lt;_&amp;gt;
    do x.Content.RootDirectory &amp;lt;- &amp;quot;Content&amp;quot;
       graphics.IsFullScreen &amp;lt;- false
 
    /// Overridden from the base Game.Initialize. Once the GraphicsDevice is setup,
    /// we&#39;ll use the viewport to initialize some values.
    override x.Initialize() = base.Initialize()

    /// Load your graphics content.
    override x.LoadContent() =
        // Create a new SpriteBatch, which can be use to draw textures.
        spriteBatch &amp;lt;- new SpriteBatch (graphics.GraphicsDevice)
        
        // TODO: use this.Content to load your game content here eg.
        logoTexture &amp;lt;- x.Content.Load&amp;lt;_&amp;gt;(&amp;quot;logo&amp;quot;)

    /// Allows the game to run logic such as updating the world,
    /// checking for collisions, gathering input, and playing audio.
    override x.Update ( gameTime:GameTime) =
        // TODO: Add your update logic here                 
        base.Update (gameTime)

    /// This is called when the game should draw itself. 
    override x.Draw (gameTime:GameTime) =
        // Clear the backbuffer
        graphics.GraphicsDevice.Clear (Color.CornflowerBlue)

        spriteBatch.Begin()

        // draw the logo
        spriteBatch.Draw (logoTexture, Vector2 (130.f, 200.f), Color.White);
        spriteBatch.End()

        //TODO: Add your drawing code here
        base.Draw (gameTime)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;We are going to need a few extra field for this sample and we wont be using and 2d so remove the &lt;code&gt;spriteBatch&lt;/code&gt; and the
&lt;code&gt;logoTexture&lt;/code&gt; as we wont be needing those.  The following fields need to be added in their place:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-fsharp&#34;&gt;let mutable basicEffect = Unchecked.defaultof&amp;lt;_&amp;gt;
let mutable texture = Unchecked.defaultof&amp;lt;_&amp;gt;
let mutable vertexBuffer = Unchecked.defaultof&amp;lt;_&amp;gt;
let mutable view = Unchecked.defaultof&amp;lt;_&amp;gt;
let mutable world = Unchecked.defaultof&amp;lt;_&amp;gt;
let mutable projection = Unchecked.defaultof&amp;lt;_&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;What&amp;rsquo;s this!  &lt;strong&gt;mutable&lt;/strong&gt; fields! I know, but this simplifies things until I can put together a friendly functional
scaffolding around &lt;a href=&#34;http://monogame.codeplex.com&#34;&gt;MonoGame&lt;/a&gt;.  We are creating a &lt;code&gt;basicEffect&lt;/code&gt;, this is used to draw the 3D objects, its actually
just a basic shader implementation with simple lighting.  We also have &lt;code&gt;texture&lt;/code&gt; which will be used as our texture
map.  We have a &lt;code&gt;vertexBuffer&lt;/code&gt; which is used to store the vertices for out primitive.  &lt;code&gt;view&lt;/code&gt;, &lt;code&gt;world&lt;/code&gt;, and &lt;code&gt;projection&lt;/code&gt;
are our matrices which are used to look into our 3D scene.  For more information on the theory behind 3D projection have
a look &lt;a href=&#34;http://en.wikipedia.org/wiki/3D_projection&#34;&gt;here&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;Lets more to the &lt;code&gt;LoadContent&lt;/code&gt; override:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-fsharp&#34;&gt;override x.LoadContent() =
    //load texture
    texture &amp;lt;- x.Content.Load&amp;lt;Texture2D&amp;gt;(&amp;quot;Tetrahedron&amp;quot;)
    
    //world, view, projection
    world &amp;lt;- Matrix.Identity
    view &amp;lt;- Matrix.CreateLookAt(Vector3(0.f, 0.f, 10.f), Vector3.Zero, Vector3.Up)
    projection &amp;lt;- Matrix.CreatePerspectiveFieldOfView(MathHelper.PiOver4,
                                                      x.GraphicsDevice.Viewport.AspectRatio,
                                                      1.f,
                                                      1000.f)
        
    basicEffect &amp;lt;- new BasicEffect(x.GraphicsDevice,
                                   World = world,
                                   View = view,
                                   Projection = projection,
                                   Texture = texture,
                                   TextureEnabled = true)
                                     
    let tetrahedronData = generateTetrahedron 3.5f
    vertexBuffer &amp;lt;- new VertexBuffer(x.GraphicsDevice, 
                                     VertexPositionTexture.VertexDeclaration, 
                                     tetrahedronData.Length, 
                                     BufferUsage.WriteOnly)
    vertexBuffer.SetData(tetrahedronData)
    x.GraphicsDevice.SetVertexBuffer(vertexBuffer)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The first thing that we do is load the texture map:&lt;br /&gt;
&lt;code&gt;texture &amp;lt;- x.Content.Load&amp;lt;Texture2D&amp;gt;(&amp;quot;Tetrahedron&amp;quot;)&lt;/code&gt;&lt;br /&gt;
This simply loads in the texture named &lt;code&gt;Tetrahedron&lt;/code&gt; using the content loader.&lt;/p&gt;

&lt;p&gt;Next we set up the default values for the world matrix, view and projection matrices.  The &lt;code&gt;world&lt;/code&gt; is simply initialised using
&lt;code&gt;Matrix.Identity&lt;/code&gt; which is a matrix defined as:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;[1,0,0,0]
[0,1,0,0]
[0,0,1,0]
[0,0,0,1]
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The &lt;code&gt;view&lt;/code&gt; is initialised using the &lt;code&gt;CreateLookAt&lt;/code&gt; method of the Matrix type.  This sets up a transformation that points from
0,0,10 to the centre of the world using &lt;code&gt;Vector3.Zero&lt;/code&gt;.  It also uses the &lt;code&gt;Vector3.Up&lt;/code&gt; as the orientation direction &lt;em&gt;(Positive Y is up)&lt;/em&gt;.&lt;/p&gt;

&lt;p&gt;The &lt;code&gt;projection&lt;/code&gt; is also initialised using the helper method &lt;code&gt;CreatePerspectiveFieldOfView&lt;/code&gt; which as you might guess, creates
a perspective with a field of view.  In this instance our field of view uses the constant &lt;code&gt;PiOver4&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;The basic effect is now initialised with the matrices we just initialised.&lt;/p&gt;

&lt;p&gt;For now I want you to ignore the line &lt;code&gt;let tetrahedronData = generateTetrahedron 3.5f&lt;/code&gt;.  I need to explain how to generate a
tetrahedron before that will make sense, just assume that is returns the vertices that we need for the tetrahedron.&lt;/p&gt;

&lt;p&gt;The &lt;code&gt;vertexBuffer&lt;/code&gt; is now created which will hold all the vertices for the tetrahedron.  We need to tell the &lt;code&gt;vertexBuufer&lt;/code&gt;
what format we want to use to hold the vertices, here, we are going to use vertices with Position, Colour, and Texture
coordinates so we we use the predefined format of &lt;code&gt;VertexPositionTexture.VertexDeclaration&lt;/code&gt;.  There are various different
predefined formats and its also possible to create custom user defined formats, for more information have a look
&lt;a href=&#34;http://devblog.phillipspiess.com/2010/03/21/xnas-vertex-structs-and-custom-vertex-formats/&#34;&gt;here&lt;/a&gt;.  I realise I&amp;rsquo;m glossing over a lot of information, this is because the field of 3D graphics is huge even an API
such as XNA/MonoGame which tries to simplify things, there is still a vast array of different concepts and I don&amp;rsquo;t want to
get too bogged down with all the specifics.&lt;/p&gt;

&lt;p&gt;Finally the &lt;code&gt;vertexBuffer&lt;/code&gt; is assigned to the graphics device: &lt;code&gt;x.GraphicsDevice.SetVertexBuffer(vertexBuffer)&lt;/code&gt;, this
loads the vertex buffer into the graphics card ready to be draw later.&lt;/p&gt;

&lt;p&gt;Next we move on to the &lt;code&gt;Update&lt;/code&gt; override:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-fsharp&#34;&gt;        override x.Update(gameTime) = 
            if Keyboard.GetState().IsKeyDown(Keys.Escape) then x.Exit()
            
            let time = float32 gameTime.ElapsedGameTime.TotalSeconds

            // Compute camera matrices.
            let rotationz = Matrix.CreateRotationY(time * 1.2f)
            basicEffect.View &amp;lt;- rotationz * Matrix.CreateLookAt(Vector3(0.f, 0.f, 10.f), Vector3.Zero, Vector3.Up)
                    
            base.Update (gameTime)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The &lt;a href=&#34;http://msdn.microsoft.com/en-us/library/microsoft.xna.framework.game.update.aspx&#34;&gt;&lt;code&gt;Update&lt;/code&gt;&lt;/a&gt; method is called every time the game decides that game logic needs to be processed. This includes the
management of game state, the processing of user input, and also the updating of simulation data or AI.&lt;/p&gt;

&lt;p&gt;First of all we check the Escape key has been pressed so that the application can exit: &lt;code&gt;if Keyboard.GetState().IsKeyDown(Keys.Escape) then x.Exit()&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;Next we capture the amount of elapsed time since the last update so that we can calculate distance moved over time etc.&lt;/p&gt;

&lt;p&gt;To make our view of the world less static we create a rotation around the z axis of the world so that we see the tetrahedron
from different angles.   We multiply the rotation matrix by our initial &lt;code&gt;Matrix.CreateLookAt...&lt;/code&gt; that we used earlier on, and
assign it back to the &lt;code&gt;View&lt;/code&gt; property of the &lt;code&gt;basicEffect&lt;/code&gt;.   I want to stress that the aim of this is not super optimal code
it&amp;rsquo;s merely to show the easiest possible method of achieving a result.  In a future post we will be looking at some functional
scaffolding to allow us to apply functional thinking to this domain.  Perhaps introducing a small &lt;a href=&#34;http://en.wikipedia.org/wiki/Domain-specific_language&#34;&gt;Domain Specific Languagee&lt;/a&gt; to help.&lt;/p&gt;

&lt;p&gt;Finally we have the &lt;code&gt;Draw&lt;/code&gt; override:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-fsharp&#34;&gt;        /// This is called when the game should draw itself. 
        override x.Draw (gameTime) =
            // Clear the backbuffer
            x.GraphicsDevice.Clear (Color.CornflowerBlue)

            for pass in basicEffect.CurrentTechnique.Passes do
                pass.Apply()
                x.GraphicsDevice.DrawPrimitives(PrimitiveType.TriangleList, 0, 4)
                 
            base.Draw (gameTime)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The &lt;a href=&#34;http://msdn.microsoft.com/en-us/library/microsoft.xna.framework.game.draw.aspx&#34;&gt;&lt;code&gt;Draw&lt;/code&gt;&lt;/a&gt; override is called every time the game needs to draw a frame, we put all out rendering code in here.&lt;/p&gt;

&lt;p&gt;The first step is to clear the screen to a nice blue colour:&lt;/p&gt;

&lt;p&gt;&lt;code&gt;x.GraphicsDevice.Clear (Color.CornflowerBlue)&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;To draw our tetrahedron we need to loop through the different techniques in out shader (In this instance our basicEffect only has 1), apply the technique, then draw out triangles.  You might remember earlier to created a the &lt;code&gt;vertexBuffer&lt;/code&gt; and assigned it to the graphics device.  All we have to do is tell MonoGame that we want to draw 4 triangles and they are in a &lt;code&gt;TriangleList&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;That&amp;rsquo;s it all done!  Well almost, now lets backtrack slightly and look at how we build the vertices for that tetrahedron.&lt;/p&gt;

&lt;h2 id=&#34;building-a-tetrahedron&#34;&gt;Building a tetrahedron&lt;/h2&gt;

&lt;p&gt;What is a tetrahedron?  Well if you look on &lt;a href=&#34;http://en.wikipedia.org/wiki/Tetrahedron&#34;&gt;wikipedia&lt;/a&gt;&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;A tetrahedron is a polyhedron composed of four triangular faces, three of which meet at each vertex. It has six edges and four vertices. The tetrahedron is the only convex polyhedron that has four faces.
&amp;hellip;&lt;/p&gt;

&lt;p&gt;In the case of a tetrahedron the base is a triangle(any of the four faces can be considered the base), so a tetrahedron is also known as a &amp;ldquo;triangular pyramid&amp;rdquo;.
&amp;hellip;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;For any tetrahedron there exists a sphere (the circumsphere) such that the tetrahedron&amp;rsquo;s vertices lie on the sphere&amp;rsquo;s surface.&lt;/p&gt;

&lt;p&gt;The tetrahedron is also the simplest of the five &lt;a href=&#34;http://en.wikipedia.org/wiki/Platonic_solid&#34;&gt;platonic solids&lt;/a&gt;.  There are lots of interesting properties of these
but I don&amp;rsquo;t really want to go into that here we just want to draw and texture one for now.&lt;/p&gt;

&lt;p&gt;So how do we construct a tetrahedron?&lt;/p&gt;

&lt;p&gt;There are various methods that can be used to construct a tetrahedron ranging from formula such as:&lt;/p&gt;

&lt;p&gt;Cartesian coordinate based
(±1, 0, -1/sqrt2)
(0, ±1, 1/sqrt2)&lt;/p&gt;

&lt;p&gt;V0 =(0,0,1)
V1=(2sqrt2 /3, 0, −1/3)&lt;br /&gt;
V2 =(− sqrt2 /3, sqrt6 /3, −1/3)&lt;br /&gt;
V3=(− sqrt2 /3,− sqrt6 /3,−1/3)&lt;/p&gt;

&lt;p&gt;Yes I know I need to get latex maths expression working in my blog!  Ill have to work on that.&lt;/p&gt;

&lt;p&gt;I don&amp;rsquo;t know about you, but I always feel uneasy unless I can clearly see exactly what&amp;rsquo;s been done, I also don&amp;rsquo;t
want to turn this into a 3D geometry lesson because that&amp;rsquo;s not what I intend this post to be about.&lt;/p&gt;

&lt;p&gt;Here&amp;rsquo;s what works for me anyway.&lt;/p&gt;

&lt;p&gt;Calculate the radius of the circumsphere, this is the sphere in which all of the vertices of the tetrahedron sit,
this is calculated by sqrt &lt;sup&gt;3&lt;/sup&gt;&amp;frasl;&lt;sub&gt;8&lt;/sub&gt;.&lt;/p&gt;

&lt;p&gt;The angle between each vertex and its centre point is acos -&lt;sup&gt;1&lt;/sup&gt;&amp;frasl;&lt;sub&gt;3&lt;/sub&gt; or ~ 109.471 degrees.&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;The first vertex is (0, sqrt (&lt;sup&gt;3&lt;/sup&gt;&amp;frasl;&lt;sub&gt;8&lt;/sub&gt;) * length, 0)&lt;/li&gt;
&lt;li&gt;To get our second vertex we need to rotate the first vertex by acos -&lt;sup&gt;1&lt;/sup&gt;&amp;frasl;&lt;sub&gt;3&lt;/sub&gt; in the X axis&lt;/li&gt;
&lt;li&gt;To get the third vertex we rotate second vertex by 120 degrees in the Y axis&lt;/li&gt;
&lt;li&gt;For the last vertex we rotate the second vertex by -120 degrees in the Y axis&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;A picture can often be a worth a thousand words, I think this is one of those times, I will refer you to
&lt;a href=&#34;http://www.f-lohmueller.de/pov_tut/x_sam/sam_440e.htm&#34;&gt;Friedrich A. Lohmüllers site&lt;/a&gt; for an excellent pictorial and description.  The code for this process is below.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-fsharp&#34;&gt;let generateTetrahedron size = 
    let circumSphereRadius = sqrt (3.f/8.f) * size
    let centerVertexAngle = acos (-1.f/3.f)
    let v1 = Vector3(0.f, circumSphereRadius, 0.f)
    let v2 = v1 |&amp;gt; Vector3.rotateX centerVertexAngle
    let v3 = v2 |&amp;gt; Vector3.rotateY (radians 120.f)
    let v4 = v2 |&amp;gt; Vector3.rotateY (-radians 120.f)
    
    let uv1 = Vector2(0.5f, 1.f - sqrt 0.75f)
    let uv2 = Vector2(0.75f, 1.f - (sqrt 0.75f)/2.f)
    let uv3 = Vector2(0.25f, 1.f - (sqrt 0.75f)/2.f)
    let uv4 = Vector2(0.5f, 1.f)
    let uv5 = Vector2.UnitY
    let uv6 = Vector2.One

    [| VertexPositionTexture(v1, uv1)
       VertexPositionTexture(v3, uv2)
       VertexPositionTexture(v2, uv3)  
       
       VertexPositionTexture(v1, uv2)
       VertexPositionTexture(v4, uv6)
       VertexPositionTexture(v3, uv4)

       VertexPositionTexture(v1, uv3)
       VertexPositionTexture(v2, uv4)
       VertexPositionTexture(v4, uv5)

       VertexPositionTexture(v2, uv3)
       VertexPositionTexture(v3, uv2)
       VertexPositionTexture(v4, uv4) |] 
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The last piece of the puzzle is the texture coordinates.  There is some amazing software available to help model both texture
and 3d geometry, projecting the vertices onto a 2d plane can be an art-form in itself.  Luckily the tetrahedron is one
of the simplest models, if you imagine the tetrahedron unfolded it would look like this from the top:&lt;/p&gt;


&lt;figure class=&#34;third&#34;&gt;
    
        &lt;img src=&#34;http://upload.wikimedia.org/wikipedia/commons/thumb/8/88/Tetrahedron_flat.svg/240px-Tetrahedron_flat.svg.png&#34; /&gt;
    
    
&lt;/figure&gt;


&lt;p&gt;To map a texture to the tetrahedron we have to include a texture coordinate with every vertex.  These coordinates are &lt;code&gt;uv1-uv6&lt;/code&gt;
in the code above.  We use some ratios to select the correct coordinates within the texture.  The texture coordinates are always
between 0 and 1.  Here&amp;rsquo;s the location of the above points so you can see the locations clearly.&lt;/p&gt;


&lt;figure class=&#34;third&#34;&gt;
    
        &lt;img src=&#34;https://lh4.googleusercontent.com/-NpV1nz3K-kI/ULKY-KY6emI/AAAAAAAABio/565nXCNC9xY/s425/texture&amp;#43;coords.png&#34; /&gt;
    
    
&lt;/figure&gt;


&lt;p&gt;To make sure that the texture is in the right place we are going to use a type of fractal called the
&lt;a href=&#34;http://en.wikipedia.org/wiki/Sierpinski_triangle&#34;&gt;Sierpinski triangle&lt;/a&gt;.  The Sierpinski triangle had exactly the same net, or unfolded shape as the texture we need to use.  Each
of the first iterations of the fractal is coloured separately as this will make it easy to see if the mapping is  correct.  Here
is what the texture looks like:&lt;/p&gt;


&lt;figure class=&#34;third&#34;&gt;
    
        &lt;img src=&#34;https://lh4.googleusercontent.com/-hLyy6qGXjWc/ULKn_4p-CUI/AAAAAAAABjA/azvh8cUNrAY/s310/Tetrahedron.png&#34; /&gt;
    
    
&lt;/figure&gt;


&lt;p&gt;This is how everything will look, I know its not incredibly impressive but its &lt;a href=&#34;http://monogame.codeplex.com&#34;&gt;MonoGame&lt;/a&gt; in 3d, F#, and all running on a
Mac, what more could you want! ;)&lt;/p&gt;


&lt;figure &gt;
    
        &lt;img src=&#34;https://lh5.googleusercontent.com/-P_7wHvJbdY0/ULO2xNStVwI/AAAAAAAABjQ/SGA5DT4ChgU/s800/Screen&amp;#43;Shot&amp;#43;2012-11-26&amp;#43;at&amp;#43;18.33.57.png&#34; /&gt;
    
    
&lt;/figure&gt;


&lt;p&gt;Its feels like we covered a lot of ground here but all we have is a spinning tetrahedron, its tricky to know what level of
detail to go down to.  I don&amp;rsquo;t want to teach anyone how to suck eggs, and I want to alienate people who are new
to this area and want to learn, I hope I got the balance about right.&lt;/p&gt;

&lt;p&gt;If you want to just get the code and have a look then here&amp;rsquo;s my &lt;a href=&#34;https://github.com/7sharp9/PlatonicSolids&#34;&gt;GitHub repo&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;As usual I appreciate any comments and feedback.&lt;/p&gt;

&lt;p&gt;Until next time!&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>F# and MonoGame on the Mac</title>
      <link>http://7sharpnine.com/2012/11/11/2012-11-11-fsharp-and-monogame-on-the-mac/</link>
      <pubDate>Sun, 11 Nov 2012 00:00:00 +0000</pubDate>
      
      <guid>http://7sharpnine.com/2012/11/11/2012-11-11-fsharp-and-monogame-on-the-mac/</guid>
      <description>

&lt;p&gt;What we are going to do in this post is take a whistle stop tour of getting &lt;a href=&#34;http://monogame.codeplex.com&#34;&gt;MonoGame&lt;/a&gt; up and running along with a
simple demo in F#.  Over the last few days I have been building an F# project template for MonoDevelop, this post will
also how to get that installed too.  &lt;!-- more --&gt;&lt;/p&gt;

&lt;p&gt;First of all I&amp;rsquo;m going to assume that you have the following installed:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Mono 3.0 beta&lt;/li&gt;
&lt;li&gt;MonoDevelop&lt;/li&gt;
&lt;li&gt;MonoDevelop F# language binding&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;If you don&amp;rsquo;t have a look at my &lt;a href=&#34;http://7sharpnine.com/posts/Fsharp-3-in-the-Mac-and-Mono-World/&#34;&gt;previous post&lt;/a&gt; that explains all that, if you don&amp;rsquo;t want to build the F# binding from source
then you can use the &lt;code&gt;Add-in Manager&lt;/code&gt;.  If you look in &lt;code&gt;Gallery&lt;/code&gt; the language binding section contains the F# language
binding.  I prefer using the source at the moment as I like to tweak a few things here and there and nosy around in the code.&lt;/p&gt;

&lt;h2 id=&#34;cloning-and-building&#34;&gt;Cloning and building&lt;/h2&gt;

&lt;p&gt;First clone my &lt;a href=&#34;https://github.com/7sharp9/MonoGame&#34;&gt;MonoGame repo&lt;/a&gt;, why my repo?  Well, I have been doing F# specific work and I have been submitting my
pull requests but there will always be a lag while I&amp;rsquo;m waiting for one of the maintainers to merge in my code, an I might
fix a bug in between writing this blog and you reading it.  The main repo is located &lt;a href=&#34;https://github.com/mono/MonoGame&#34;&gt;here&lt;/a&gt; if you are interested in
looking at that too.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;git clone git@github.com:7sharp9/MonoGame.git
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;OK, now we need to initialise and get the submodules:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;git submodule init
git subbmodule update
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Now go and make a cup of tea or coffee or something because this will take a little while! :-)&lt;/p&gt;

&lt;p&gt;if you get any serious errors from the submodules you cold try this:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;git submodule sync
git submodule update
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Check that the main framework builds, this will test if all the submodules updated correctly as well.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;cd MonoGame
xbuild MonoGame.Framework.MacOS.sln
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;building-the-project-templates&#34;&gt;Building the Project templates&lt;/h2&gt;

&lt;p&gt;I was going to go through the manual steps required to get things up and running but I figured I may as well go through
getting the project templates installed too.  Now the project templates are not 100% by any means and there is currently
work under way to produce a cross platform installer that will take care of everything.&lt;/p&gt;

&lt;p&gt;There are currently the following C# based templates:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;MonoGame for Android&lt;/li&gt;
&lt;li&gt;MonoGame for iOS&lt;/li&gt;
&lt;li&gt;MonoGame for Windows Application&lt;/li&gt;
&lt;li&gt;MonoGame for Linux&lt;/li&gt;
&lt;li&gt;MonoGame for Mac Application&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;And the following brand new shiny F# templates that I added a few days ago:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;MonoGame for Mac Application&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Yeah I know there&amp;rsquo;s only one for now but Ill get there&amp;hellip;&lt;/p&gt;

&lt;p&gt;Right, we&amp;rsquo;re going to rattle through some commands to build the project templates:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;#Change directory to the project templates
cd ProjectTemplates/MonoDevelop/MonoDevelop.MonoGame/

#Build the Project templates solution:

xbuild MonoDevelop.MonoGame.sln 
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Now we&amp;rsquo;re going to create the add-in structure and install it in MonoDevelop&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;#create a folder for the add-in:
mkdir /Applications/MonoDevelop.app/Contents/MacOS/lib/monodevelop/AddIns/MonoDevelop.MonoGame

#Copy the templates and icons into that folder:
cp -R MonoDevelop.MonoGame/templates /Applications/MonoDevelop.app/Contents/MacOS/lib/monodevelop/AddIns/MonoDevelop.MonoGame
cp -R MonoDevelop.MonoGame/icons /Applications/MonoDevelop.app/Contents/MacOS/lib/monodevelop/AddIns/MonoDevelop.MonoGame
cp -R MonoDevelop.MonoGame/bin/Release/MonoDevelop.MonoGame.dll /Applications/MonoDevelop.app/Contents/MacOS/lib/monodevelop/AddIns/MonoDevelop.MonoGame
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;If you fire up MonoDevelop and create a new solution now you should see a new project type:&lt;/p&gt;


&lt;figure &gt;
    
        &lt;img src=&#34;https://lh5.googleusercontent.com/-5_khSpX_ong/UJ-MeJOyTpI/AAAAAAAABh4/oftw3zWSMqo/s1062/MonoGame&amp;#43;Mac&amp;#43;Application.png&#34; /&gt;
    
    
&lt;/figure&gt;


&lt;p&gt;I know this is a bit long winded but it will get you started until a proper installer finished.&lt;/p&gt;

&lt;p&gt;Oh yeah there are currently a couple of caveats, once you have created a new project from the template you &lt;strong&gt;must&lt;/strong&gt; do
the following:&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;Open the project references and re-add the &lt;strong&gt;Lidgren.Network.dll&lt;/strong&gt; and the &lt;strong&gt;MonoGame.FrameWork.MacOS.dll&lt;/strong&gt; references.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;I know I know that&amp;rsquo;s a &lt;strong&gt;major pain&lt;/strong&gt; but let me tell you the reason for this.&lt;/p&gt;

&lt;h3 id=&#34;package-references-in-monodevelop&#34;&gt;Package references in MonoDevelop&lt;/h3&gt;

&lt;p&gt;You might of noticed that the aforementioned references were shown in red when the new project was opened, this was
because there was no way for MonoDevelop to know where they were currently located.  We could of added a
&lt;a href=&#34;http://en.wikipedia.org/wiki/Pkg-config&#34;&gt;package config file&lt;/a&gt; to the &lt;code&gt;/Library/Frameworks/Mono.framework/Versions/3.0.0/lib/pkgconfig&lt;/code&gt; folder which would
allow MonoDevelop to know how to resolve the references but this then leads to a further problem:&lt;/p&gt;

&lt;p&gt;Package references in MonoDevelop are expected to be located in the GAC, and because of this assumption the copy local property has no
effect.  There is an &lt;a href=&#34;https://bugzilla.xamarin.com/show_bug.cgi?id=4030&#34;&gt;oustanding bug&lt;/a&gt; logged for this issue.  There are workarounds for these issues as mentioned in
the &lt;a href=&#34;https://bugzilla.xamarin.com/show_bug.cgi?id=4030&#34;&gt;bug report&lt;/a&gt; but it is still currently an issue in MonoGame.  Hopefully it will be addressed in the near future.&lt;/p&gt;

&lt;p&gt;You might be asking why cant we put the assemblies it in the GAC?&lt;/p&gt;

&lt;p&gt;Well we could do although you would have then have to sign the assembly as it is currently not strongly named and then
install it in the GAC with &lt;code&gt;gacutil&lt;/code&gt;, and as this is still an early beta so I&amp;rsquo;m happy to keep the assembly out of the GAC for now.&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;You should be ready to put MonoGame to use now.  If you run the template project you will get a MonoGame logo drawn to
the screen.  I suggest looking at some of the demo&amp;rsquo;s in the Samples folder and maybe try porting a couple of them over
to F#.  In future posts Ill try to address some of the functional aspect of using F# with MonoGame.&lt;/p&gt;

&lt;h2 id=&#34;what-s-next&#34;&gt;What&amp;rsquo;s next?&lt;/h2&gt;

&lt;p&gt;I&amp;rsquo;m currently starting work on a post which shows F# using some of the 3D aspects of MonoGame.  Exciting!&lt;/p&gt;

&lt;p&gt;Until next time&amp;hellip;&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>F# 3.0 In The Mac And Mono World</title>
      <link>http://7sharpnine.com/2012/11/03/2012-11-03-fsharp-3-in-the-mac-and-mono-world/</link>
      <pubDate>Sat, 03 Nov 2012 00:00:00 +0000</pubDate>
      
      <guid>http://7sharpnine.com/2012/11/03/2012-11-03-fsharp-3-in-the-mac-and-mono-world/</guid>
      <description>

&lt;p&gt;So what have I been up to lately?  Well, lots of different things.  I have been taking it easy on the open source and blogging side of things as its been a hectic time of late in my personal life.  This seems to be changing now so I&amp;rsquo;m starting to get all of the ideas spinning around in my head into physical reality, or virtual reality, or what ever you want to call it.  Anyway, here&amp;rsquo;s the first post on the subject of programming in F# using &lt;a href=&#34;http://monodevelop.com&#34;&gt;MonoDevelop&lt;/a&gt; and &lt;a href=&#34;http://www.mono-project.com/What_is_Mono&#34;&gt;Mono&lt;/a&gt; natively on Macs.  &lt;!-- more --&gt;&lt;/p&gt;

&lt;p&gt;I have always been a fan of &lt;a href=&#34;http://www.mono-project.com/What_is_Mono&#34;&gt;Mono&lt;/a&gt; but I have always shied away from using it in anger, this is mainly due to my Windows heritage and using Visual Studio almost exclusively at work.  Times are changing though, and over the past few years I have been using Macs more and more.  In fact the only place where I still use Windows natively is at work, so it makes sense to get a development environment up and running to support me.&lt;/p&gt;

&lt;p&gt;Once the Beta of Mono 3.0 goes live it should contain within it a nice shiny new &lt;a href=&#34;http://msdn.microsoft.com/en-us/vstudio/hh388569&#34;&gt;F# 3.0&lt;/a&gt; installation, but until then we have to do a number of manual steps:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Install Mono 3.0&lt;/li&gt;
&lt;li&gt;Install MonoDevelop&lt;/li&gt;
&lt;li&gt;Compile and install F#3.0&lt;/li&gt;
&lt;li&gt;Compile and install the MonoDevelop F# Language Binding&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;install-mono-3-0&#34;&gt;Install Mono 3.0&lt;/h2&gt;

&lt;p&gt;Head over to the &lt;a href=&#34;http://www.go-mono.com/mono-downloads/download.html&#34;&gt;Mono site&lt;/a&gt; and install Mono 3.0 and the Mono MDK, they can be both found on the &lt;a href=&#34;http://www.mono-project.com/What_is_Mono&#34;&gt;download page&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;IF you think you already have these installed you can check which version you have by Navigating to the directory: &lt;code&gt;/Library/Frameworks/Mono.framework/Versions&lt;/code&gt;
You should see version 3.0 in the list:&lt;/p&gt;


&lt;figure &gt;
    
        &lt;img src=&#34;https://lh3.googleusercontent.com/-N3cTmmXXvxI/UJUR1CIw4DI/AAAAAAAABgs/dQUFqgpQrvQ/s209/Mono3.0&amp;#43;install.png&#34; /&gt;
    
    
&lt;/figure&gt;


&lt;p&gt;Also ensure that the &lt;code&gt;Current&lt;/code&gt; symbolic link points to Mono version 3.0, when I was first tried to get things running I couldn&amp;rsquo;t understand why I kept getting a version mismatches, this was because my link was pointing to Mono 2.10.9.&lt;/p&gt;

&lt;h2 id=&#34;install-monodevelop&#34;&gt;Install MonoDevelop&lt;/h2&gt;

&lt;p&gt;I would recommend installing &lt;a href=&#34;http://monodevelop.com&#34;&gt;MonoDevelop&lt;/a&gt; straight from the packaged installer, as I write this the stable version is 3.0.4.7.  You can find the download page &lt;a href=&#34;http://monodevelop.com/Download&#34;&gt;here&lt;/a&gt;.&lt;/p&gt;

&lt;h2 id=&#34;building-f-3-0&#34;&gt;Building F#3.0&lt;/h2&gt;

&lt;p&gt;These instruction can also be found &lt;a href=&#34;https://github.com/fsharp/fsharp&#34;&gt;here&lt;/a&gt; but I thought it might be helpful to keep everything at hand here, if nothing else it will serve as a reference if I need to do this again or help anybody out.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;#Make sure you have automake installed:
brew install automake

#First of all clone the F#3.0 repo from GitHub
git clone git://github.com/fsharp/fsharp.git\

#change the directory
cd fsharp

#run autogen script pointing at the current version of Mono
./autogen.sh --prefix=/Library/Frameworks/Mono.framework/Versions/Current/

#run make to compile the code
make

#run make to install
sudo make install
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Once that&amp;rsquo;s all finished you can check everything is working by running &lt;code&gt;fsharpc&lt;/code&gt;:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;fsharpc
F# Compiler for F# 3.0 (Open Source Edition)
Freely distributed under the Apache 2.0 Open Source License

error FS0207: No inputs specified
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;If you didn&amp;rsquo;t get a version 3.0 Compiler build displayed then check where &lt;code&gt;fsharpc&lt;/code&gt; is running from by using the &lt;code&gt;type&lt;/code&gt; command:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;type fsharpc
fsharpc is /usr/bin/fsharpc
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;You can now navigate there and check where the symbolic link is pointing to be using the &lt;code&gt;-l&lt;/code&gt; parameter of the &lt;code&gt;ls&lt;/code&gt; command:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;cd /usr/bin
ls -l fsharpc
lrwxr-xr-x  1 root  wheel  51  3 Nov 09:33 fsharpc -&amp;gt; /Library/Frameworks/Mono.framework/Commands/fsharpc
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;When I first tried to get the F# 3.0 compiler installed I had all sorts of problem with the symbolic link pointing to the old version.  I don&amp;rsquo;t know whether the installer had failed or whether an old version of the F# compiler or the F# language binding had caused issues, the process was so much smoother on my MacBook Pro as it was a clean install.&lt;/p&gt;

&lt;h2 id=&#34;build-the-monodevelop-f-language-binding&#34;&gt;Build the MonoDevelop F# language binding&lt;/h2&gt;

&lt;pre&gt;&lt;code&gt;git clone git://github.com/fsharp/fsharpbinding.git
cd fsharpbinding
./configure.sh
make
make install
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;That&amp;rsquo;s it we&amp;rsquo;re all done!  Pretty easy stuff thanks to &lt;a href=&#34;http://twitter.com/winkler_ben&#34;&gt;Ben Winkel&lt;/a&gt; and others for putting in some time to fix up the issues.&lt;/p&gt;

&lt;p&gt;Now you should be able to fire up &lt;a href=&#34;http://monodevelop.com&#34;&gt;MonoDevelop&lt;/a&gt; and start building some F# code!&lt;/p&gt;

&lt;p&gt;You can check the add-in is installed properly my opening the Add-in Manager from the &lt;a href=&#34;http://monodevelop.com&#34;&gt;MonoDevelop&lt;/a&gt; menu.  The F# language binding should be shown as:&lt;/p&gt;


&lt;figure &gt;
    
        &lt;img src=&#34;https://lh5.googleusercontent.com/-ubaW6iROJyc/UJUR1MKOaJI/AAAAAAAABgw/PgUNUmFHhBM/s791/Addin&amp;#43;manager.png&#34; /&gt;
    
    
&lt;/figure&gt;


&lt;p&gt;When you start a new solution you should now be presented with some F# specific options:&lt;/p&gt;


&lt;figure &gt;
    
        &lt;img src=&#34;https://lh4.googleusercontent.com/-p3GdkcD14aA/UJUR1WHLuhI/AAAAAAAABg0/TnpTuEkuC30/s932/New&amp;#43;Solution.png&#34; /&gt;
    
    
&lt;/figure&gt;


&lt;p&gt;Next time I will take this a step further by showing how to build, install and integrate &lt;a href=&#34;http://monogame.codeplex.com&#34;&gt;MonoGame&lt;/a&gt; with F#.  I will also be releasing an F# specific project template for use with &lt;a href=&#34;http://monodevelop.com&#34;&gt;MonoDevelop&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;Until next time&amp;hellip;&lt;/p&gt;
</description>
    </item>
    
  </channel>
</rss>